<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="📑 目录 ➕ C/C++ ⭐️ Effective 📦 STL 〽️ 数据结构 ⚡️ 算法 ❓ Problems 💻 操作系统 ☁️ 计算机网络 🌩 网络编程 💾 数据库 📏 设计模式 ⚙️ 链接装载库 📚 书籍 🔱 C/C++ 发展方向 💯 复习刷题网站 📝 面试题目经验  ➕ C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常">
<meta property="og:type" content="article">
<meta property="og:title" content="会问到的问题">
<meta property="og:url" content="https://yoursite.com/2019/08/18/会问到的问题/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="📑 目录 ➕ C/C++ ⭐️ Effective 📦 STL 〽️ 数据结构 ⚡️ 算法 ❓ Problems 💻 操作系统 ☁️ 计算机网络 🌩 网络编程 💾 数据库 📏 设计模式 ⚙️ 链接装载库 📚 书籍 🔱 C/C++ 发展方向 💯 复习刷题网站 📝 面试题目经验  ➕ C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/SqStack.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/SqQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/SqLoopStack.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/SqList.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/LinkQueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/LinkList.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/DuLinkList.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/CirLinkList.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/HashTable.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/SqBinaryTree.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/LinkBinaryTree.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/Self-balancingBinarySearchTree.png">
<meta property="og:image" content="https://i.stack.imgur.com/l6UyF.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Big-Endian.svg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Little-Endian.svg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E9%A6%96%E9%83%A8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/UDP%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/UDP%E9%A6%96%E9%83%A8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/WindowsLoadLibrary.png">
<meta property="og:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/WindowsFreeLibrary.png">
<meta property="og:updated_time" content="2019-08-18T06:45:35.306Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="会问到的问题">
<meta name="twitter:description" content="📑 目录 ➕ C/C++ ⭐️ Effective 📦 STL 〽️ 数据结构 ⚡️ 算法 ❓ Problems 💻 操作系统 ☁️ 计算机网络 🌩 网络编程 💾 数据库 📏 设计模式 ⚙️ 链接装载库 📚 书籍 🔱 C/C++ 发展方向 💯 复习刷题网站 📝 面试题目经验  ➕ C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常">
<meta name="twitter:image" content="https://raw.githubusercontent.com/huihut/interview/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/2019/08/18/会问到的问题/">





  <title>会问到的问题 | し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/08/18/会问到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">会问到的问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T10:14:23+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="📑-目录"><a href="#📑-目录" class="headerlink" title="📑 目录"></a>📑 目录</h2><ul>
<li><a href="#-cc">➕ C/C++</a></li>
<li><a href="#️-effective">⭐️ Effective</a></li>
<li><a href="#-stl">📦 STL</a></li>
<li><a href="#️-数据结构">〽️ 数据结构</a></li>
<li><a href="#️-算法">⚡️ 算法</a></li>
<li><a href="#-problems">❓ Problems</a></li>
<li><a href="#-操作系统">💻 操作系统</a></li>
<li><a href="#️-计算机网络">☁️ 计算机网络</a></li>
<li><a href="#-网络编程">🌩 网络编程</a></li>
<li><a href="#-数据库">💾 数据库</a></li>
<li><a href="#-设计模式">📏 设计模式</a></li>
<li><a href="#️-链接装载库">⚙️ 链接装载库</a></li>
<li><a href="#-书籍">📚 书籍</a></li>
<li><a href="#-cc-发展方向">🔱 C/C++ 发展方向</a></li>
<li><a href="#-复习刷题网站">💯 复习刷题网站</a></li>
<li><a href="#-面试题目经验">📝 面试题目经验</a></li>
</ul>
<h2 id="➕-C-C"><a href="#➕-C-C" class="headerlink" title="➕ C/C++"></a>➕ C/C++</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。(在C++中，只有被声明为const的成员函数才能被一个const类对象调用。)</li>
</ol>
<p><strong><em>注意：</em></strong></p>
<p><strong>1、对于const修饰的成员函数</strong></p>
<p>1）值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。</p>
<p>2）const成员函数可以被具有相同参数列表的非const成员函数重载。在这种情况下，类对象的常量性决定调用哪个函数。</p>
<p>3）对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将voidFunc(A a) 改为void Func(const A &amp;a)</p>
<p>​      对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，     又降低了函数的可理解性。例如void Func(int x) 不应该改为voidFunc(const int &amp;x)。</p>
<p>4）const 函数只能调用 const函数，即使某个函数本质上没有修改任何数据，但没有声明为const，也是不能被const函数调用的。</p>
<p><strong>2、常量指针</strong>和<strong>指针常量</strong></p>
<p>1:常量指针</p>
<p><span style="color:red">定义：具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针，称为指向常量的指针，简称常量指针。</span></p>
<p>声明：const int * p; int const * p;</p>
<p>注：可以将一个常量的地址赋值给一个对应类型的常量指针，因为常量指针不能够通过指针修改内粗数据。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象。</p>
<hr>
<p>2.指针常量<br><span style="color:red">定义：指针常量是指指针所指向的位置不能改变，即指针本身是一个常量，但是指针所指向的内容可以改变。</span></p>
<p>声明：int * const p=&a;</p>
<p>注：指针常量必须在声明的同时对其初始化，不允许先声明一个指针常量随后再对其赋值，这和声明一般的常量是一样的</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//定义常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr1=&amp;a;</span><br><span class="line"><span class="comment">//定义指针常量，必须赋值</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2=&amp;a;</span><br><span class="line"><span class="comment">//错误，不能把常量的地址赋给指针变量</span></span><br><span class="line"><span class="keyword">int</span> *ptr3=&amp;b;</span><br><span class="line"><span class="comment">//正确，可以把常量的地址赋给常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr4=&amp;b;</span><br><span class="line"><span class="comment">//错误，间接引用常量指针不可以修改内存中的数据</span></span><br><span class="line">*ptr1=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//正确，间接引用指针常量可以修改内存中的数据</span></span><br><span class="line">*ptr2=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//正确，常量指针可以指向其他变量</span></span><br><span class="line">ptr1=&amp;b;</span><br><span class="line"><span class="comment">//错误，指针常量不可以指向其他变量</span></span><br><span class="line">ptr2=&amp;b;</span><br><span class="line"><span class="comment">//常量指针常量，即不可以间接引用修改内存数据，也不可以指向别的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr5=&amp;a;</span><br><span class="line"><span class="comment">//错误，不可以间接引用修改内存数据</span></span><br><span class="line">*ptr5=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//错误，不可以修改指向的对象</span></span><br><span class="line">ptr5=&amp;b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>const 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul>
<li>静态成员变量（面向对象）</li>
<li>静态成员函数（面向对象）</li>
<li>静态全局变量（面向过程）</li>
<li>静态局部变量（面向过程）</li>
<li>静态函数（面向过程）</li>
</ul>
<h5 id="1-（面向对象的）静态成员变量"><a href="#1-（面向对象的）静态成员变量" class="headerlink" title="1. （面向对象的）静态成员变量"></a><strong>1. （面向对象的）静态成员变量</strong></h5><p>在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;    <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">	<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">	Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Myclass::GetSum()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Sum="</span>&lt;&lt;Sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	M.GetSum();</span><br><span class="line">	<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">	N.GetSum();</span><br><span class="line">	M.GetSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态成员变量有以下特点：</strong></p>
<ol>
<li><p>静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</p>
</li>
<li><p><span style="color:red">因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；</span></p>
</li>
<li><p>静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。<span style="color:red">静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。</span>在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。</p>
</li>
<li><p>static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
</li>
<li><p>静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</p>
</li>
<li><p>类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞</p>
</li>
<li><p>类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。</p>
</li>
<li><p>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</p>
</li>
<li><p>如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；</p>
</li>
<li><p>sizeof 运算符不会计算 静态成员变量。</p>
</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;    <span class="comment">//则sizeof（CMyclass）等于4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>何时采用静态数据成员？</strong></p>
<p>设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：</p>
<ol>
<li>不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。</li>
<li>一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</li>
</ol>
<p>你也许会问，用全局变量不是也可以达到这个效果吗？</p>
<p>同全局变量相比，使用静态数据成员有两个优势：</p>
<ol>
<li><span style="color:red">静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。</span></li>
<li><span style="color:red">可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。</span></li>
</ol>
<h5 id="2-（面向对象的）-静态成员函数"><a href="#2-（面向对象的）-静态成员函数" class="headerlink" title="2.（面向对象的） 静态成员函数"></a><strong>2.（面向对象的） 静态成员函数</strong></h5><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>inline 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol>
<li>将 inline 函数体复制到 inline 函数调用点处； </li>
<li>为所用 inline 函数中的局部变量分配内存空间； </li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><blockquote>
<p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p>
</blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<p>虚函数内联使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">	Base b;</span><br><span class="line">	b.who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">	Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">	ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>

<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure>

<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern “C” 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h3><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p>
<h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>最本质的一个区别就是默认的访问控制<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>union 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h3><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<blockquote>
<p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p>
</blockquote>
<h3 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h3><ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li>
</ul>
<p>explicit 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	A a2 = <span class="number">1</span>;		<span class="comment">// OK：复制初始化</span></span><br><span class="line">	A a3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	A a4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">	A a5 = (A)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">	doA(<span class="number">1</span>);			<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (a1);		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a6（a1）;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a7 = a1;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">	B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">	B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	doB(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="keyword">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul>
<li>能访问私有成员  </li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<p>using 使用</p>
<p>尽量少使用 <code>using 指示</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>应该多使用 <code>using 声明</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<p>decltype 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h3 id="initializer-list-列表初始化"><a href="#initializer-list-列表初始化" class="headerlink" title="initializer_list 列表初始化"></a>initializer_list 列表初始化</h3><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<p>initializer_list 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> T*, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="面向对象特征"></p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li><code>public</code> 成员：可以被任意实体访问</li>
<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<blockquote>
<p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p>
</blockquote>
<h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h4><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li>
</ul>
<p>动态多态使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li>
<li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<blockquote>
<p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
</blockquote>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h3><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p>
<p>malloc、free 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>new、delete 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><blockquote>
<p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p>
</blockquote>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h3 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p>
</blockquote>
<h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br></pre></td></tr></table></figure>

<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><blockquote>
<p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p>
</blockquote>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p>向上转换是一种隐式转换。</p>
</blockquote>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul>
<li>用于多态类型的转换</li>
</ul>
<h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：<code>typeinfo</code></li>
</ul>
<p>typeid、type_info 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="⭐️-Effective"><a href="#⭐️-Effective" class="headerlink" title="⭐️ Effective"></a>⭐️ Effective</h2><h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><ol>
<li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li>
<li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li>
<li>尽可能使用 const</li>
<li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li>
<li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li>
<li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li>
<li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li>
<li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li>
<li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li>
<li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li>
<li>在 <code>operator=</code> 中处理 “自我赋值”</li>
<li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li>
<li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li>
<li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li>
<li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li>
<li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li>
<li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li>
<li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li>
<li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li>
<li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li>
<li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li>
<li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li>
<li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li>
<li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li>
<li>考虑写一个不抛异常的 swap 函数</li>
<li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li>
<li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li>
<li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li>
<li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li>
<li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li>
<li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li>
<li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li>
<li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li>
<li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li>
<li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li>
<li>绝不重新定义继承而来的 non-virtual 函数</li>
<li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li>
<li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li>
<li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li>
<li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li>
<li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li>
<li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li>
<li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li>
<li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li>
<li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li>
<li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li>
<li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li>
<li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li>
<li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li>
<li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li>
<li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li>
<li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li>
<li>不要轻忽编译器的警告</li>
<li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li>
<li>让自己熟悉 Boost（准标准库）</li>
</ol>
<h3 id="More-Effective-c"><a href="#More-Effective-c" class="headerlink" title="More Effective c++"></a>More Effective c++</h3><ol>
<li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li>
<li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li>
<li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li>
<li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li>
<li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li>
<li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li>
<li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li>
<li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li>
<li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li>
<li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li>
<li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li>
<li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li>
<li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li>
<li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li>
<li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li>
<li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li>
<li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li>
<li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li>
</ol>
<h3 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h3><ul>
<li>英文：<a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google C++ Style Guide</a></li>
<li>中文：<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">C++ 风格指南</a></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="http://www.stroustrup.com/bs_faq.html" target="_blank" rel="noopener">Bjarne Stroustrup 的常见问题</a></li>
<li><a href="http://www.stroustrup.com/bs_faq2.html" target="_blank" rel="noopener">Bjarne Stroustrup 的 C++ 风格和技巧常见问题</a></li>
</ul>
<h2 id="📦-STL"><a href="#📦-STL" class="headerlink" title="📦 STL"></a>📦 STL</h2><h3 id="STL-索引"><a href="#STL-索引" class="headerlink" title="STL 索引"></a>STL 索引</h3><p><a href="https://github.com/huihut/interview/tree/master/STL" target="_blank" rel="noopener">STL 方法含义索引</a></p>
<h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#array" target="_blank" rel="noopener">array</a></td>
<td>数组</td>
<td>随机读改 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#vector" target="_blank" rel="noopener">vector</a></td>
<td>数组</td>
<td>随机读改、尾部插入、尾部删除 O(1)<br>头部插入、头部删除 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#deque" target="_blank" rel="noopener">deque</a></td>
<td>双端队列</td>
<td>头尾插入、头尾删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list" target="_blank" rel="noopener">forward_list</a></td>
<td>单向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#list" target="_blank" rel="noopener">list</a></td>
<td>双向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#stack" target="_blank" rel="noopener">stack</a></td>
<td>deque / list</td>
<td>顶部插入、顶部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#queue" target="_blank" rel="noopener">queue</a></td>
<td>deque / list</td>
<td>尾部插入、头部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue" target="_blank" rel="noopener">priority_queue</a></td>
<td>vector + max-heap</td>
<td>插入、删除 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td>vector容器+heap处理规则</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#set" target="_blank" rel="noopener">set</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multiset" target="_blank" rel="noopener">multiset</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#map" target="_blank" rel="noopener">map</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multimap" target="_blank" rel="noopener">multimap</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set" target="_blank" rel="noopener">unordered_set</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset" target="_blank" rel="noopener">unordered_multiset</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map" target="_blank" rel="noopener">unordered_map</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap" target="_blank" rel="noopener">unordered_multimap</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
</tbody></table>
<h3 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h3><table>
<thead>
<tr>
<th>算法</th>
<th>底层算法</th>
<th>时间复杂度</th>
<th>可不可重复</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.cplusplus.com/reference/algorithm/find/" target="_blank" rel="noopener">find</a></td>
<td>顺序查找</td>
<td>O(n)</td>
<td>可重复</td>
</tr>
<tr>
<td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808" target="_blank" rel="noopener">sort</a></td>
<td><a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">内省排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>可重复</td>
</tr>
</tbody></table>
<h2 id="〽️-数据结构"><a href="#〽️-数据结构" class="headerlink" title="〽️ 数据结构"></a>〽️ 数据结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="顺序栈（Sequence-Stack）"><a href="#顺序栈（Sequence-Stack）" class="headerlink" title="顺序栈（Sequence Stack）"></a>顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p>
<p>顺序栈数据结构和图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/SqStack.png" alt></p>
<h4 id="队列（Sequence-Queue）"><a href="#队列（Sequence-Queue）" class="headerlink" title="队列（Sequence Queue）"></a>队列（Sequence Queue）</h4><p>队列数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType * elem;</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<h5 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h5><p>非循环队列图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/SqQueue.png" alt></p>
<p><code>SqQueue.rear++</code></p>
<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>循环队列图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/SqLoopStack.png" alt></p>
<p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p>
<h4 id="顺序表（Sequence-List）"><a href="#顺序表（Sequence-List）" class="headerlink" title="顺序表（Sequence List）"></a>顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p>
<p>顺序表数据结构和图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/SqList.png" alt></p>
<h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p>
<p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p>
<p>链式数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<h4 id="链队列（Link-Queue）"><a href="#链队列（Link-Queue）" class="headerlink" title="链队列（Link Queue）"></a>链队列（Link Queue）</h4><p>链队列图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/LinkQueue.png" alt></p>
<h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><h5 id="单链表（Link-List）"><a href="#单链表（Link-List）" class="headerlink" title="单链表（Link List）"></a>单链表（Link List）</h5><p>单链表图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/LinkList.png" alt></p>
<h5 id="双向链表（Du-Link-List）"><a href="#双向链表（Du-Link-List）" class="headerlink" title="双向链表（Du-Link-List）"></a>双向链表（Du-Link-List）</h5><p>双向链表图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/DuLinkList.png" alt></p>
<h5 id="循环链表（Cir-Link-List）"><a href="#循环链表（Cir-Link-List）" class="headerlink" title="循环链表（Cir-Link-List）"></a>循环链表（Cir-Link-List）</h5><p>循环链表图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/CirLinkList.png" alt></p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>直接定址法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ul>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ul>
<li>链地址法：key 相同的用单链表链接</li>
<li>开放定址法<ul>
<li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li>
<li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li>
<li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li>
</ul>
</li>
</ul>
<h4 id="线性探测的哈希表数据结构"><a href="#线性探测的哈希表数据结构" class="headerlink" title="线性探测的哈希表数据结构"></a>线性探测的哈希表数据结构</h4><p>线性探测的哈希表数据结构和图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	RcdType *rcd;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/HashTable.png" alt></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数直接或间接地调用自身</p>
<h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><ul>
<li>分治法<ul>
<li>问题的分解</li>
<li>问题规模的分解</li>
</ul>
</li>
<li>折半查找（递归）</li>
<li>归并查找（递归）</li>
<li>快速排序（递归）</li>
</ul>
<h4 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h4><ul>
<li>迭代：反复利用变量旧值推出新值</li>
<li>折半查找（迭代）</li>
<li>归并查找（迭代）</li>
</ul>
<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><p>广义表的头尾链表存储表示和图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList1.png" alt></p>
<h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><p>扩展线性链表存储表示和图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList2.png" alt></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li>
<li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li>
<li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li>
<li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 </li>
<li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点<ol>
<li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li>
<li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li>
<li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li>
</ol>
</li>
</ol>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>二叉树数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>二叉树顺序存储图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/SqBinaryTree.png" alt></p>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>二叉树链式存储图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/LinkBinaryTree.png" alt></p>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后续遍历</li>
<li>层次遍历</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li>满二叉树</li>
<li>完全二叉树（堆）<ul>
<li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li>
<li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li>
</ul>
</li>
<li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li>
<li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul>
<li>LL型：根的左孩子右旋</li>
<li>RR型：根的右孩子左旋</li>
<li>LR型：根的左孩子左旋，再右旋</li>
<li>RL型：右孩子的左子树，先右旋，再左旋</li>
</ul>
</li>
</ul>
<h3 id="其他树及森林"><a href="#其他树及森林" class="headerlink" title="其他树及森林"></a>其他树及森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul>
<li>双亲表示法</li>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}</p>
<h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul>
<li>| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>平衡二叉树必定是二叉搜索树，反之则不一定</li>
<li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li>
</ul>
<p>平衡二叉树图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/Self-balancingBinarySearchTree.png" alt></p>
<h5 id="最小失衡树"><a href="#最小失衡树" class="headerlink" title="最小失衡树"></a>最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p>
<p>调整：</p>
<ul>
<li>LL 型：根的左孩子右旋</li>
<li>RR 型：根的右孩子左旋</li>
<li>LR 型：根的左孩子左旋，再右旋</li>
<li>RL 型：右孩子的左子树，先右旋，再左旋</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><a href="DataStructure/RedBlackTree.cpp">RedBlackTree.cpp</a></p>
<h5 id="红黑树的特征是什么？"><a href="#红黑树的特征是什么？" class="headerlink" title="红黑树的特征是什么？"></a>红黑树的特征是什么？</h5><ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是 NIL 节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li>
</ol>
<h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><ol>
<li>变色</li>
<li>左旋</li>
<li>右旋</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>关联数组：如 STL 中的 map、set</li>
</ul>
<h5 id="红黑树、B-树、B-树的区别？"><a href="#红黑树、B-树、B-树的区别？" class="headerlink" title="红黑树、B 树、B+ 树的区别？"></a>红黑树、B 树、B+ 树的区别？</h5><ul>
<li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li>
<li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li>
</ul>
<h4 id="B-树（B-tree）、B-树（B-tree）"><a href="#B-树（B-tree）、B-树（B-tree）" class="headerlink" title="B 树（B-tree）、B+ 树（B+-tree）"></a>B 树（B-tree）、B+ 树（B+-tree）</h4><p>B 树、B+ 树图片</p>
<p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>一般化的二叉查找树（binary search tree）</li>
<li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li>
</ul>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul>
<li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li>
</ul>
<h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<h5 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul>
<li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
<blockquote>
<p>B 树、B+ 树区别来自：<a href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees" target="_blank" rel="noopener">differences-between-b-trees-and-b-trees</a>、<a href="https://www.cnblogs.com/ivictor/p/5849061.html" target="_blank" rel="noopener">B树和B+树的区别</a></p>
</blockquote>
<h4 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h4><p>八叉树图片</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt></p>
<p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul>
<li>三维计算机图形</li>
<li>最邻近搜索</li>
</ul>
<h2 id="⚡️-算法"><a href="#⚡️-算法" class="headerlink" title="⚡️ 算法"></a>⚡️ 算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/SelectionSort.h">选择排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td><a href="Algorithm/InsertSort.h">插入排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/QuickSort.h">快速排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/HeapSort.cpp">堆排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/MergeSort.h">归并排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/ShellSort.h">希尔排序</a></td>
<td>O(n*log<sup>2</sup>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/CountSort.cpp">计数排序</a></td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/BucketSort.cpp">桶排序</a></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/RadixSort.h">基数排序</a></td>
<td>O(k*n)</td>
<td>O(n<sup>2</sup>)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>均按从小到大排列</li>
<li>k：代表数值中的 “数位” 个数</li>
<li>n：代表数据规模</li>
<li>m：代表数据的最大值减最小值</li>
<li>来自：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">wikipedia . 排序算法</a></li>
</ul>
</blockquote>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table>
<thead>
<tr>
<th>查找算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>查找条件</th>
</tr>
</thead>
<tbody><tr>
<td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/InsertionSearch.h">插值查找</a></td>
<td>O(log<sub>2</sub>(log<sub>2</sub>n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="DataStructure/HashTable.cpp">哈希查找</a></td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><table>
<thead>
<tr>
<th>图搜索算法</th>
<th>数据结构</th>
<th>遍历时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">BFS广度优先搜索</a></td>
<td>邻接矩阵<br>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">DFS深度优先搜索</a></td>
<td>邻接矩阵<br>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td>
</tr>
</tbody></table>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="noopener">分治法</a></td>
<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem" target="_blank" rel="noopener">循环赛日程安排问题</a>、排序算法（快速排序、归并排序）</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">动态规划</a></td>
<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem" target="_blank" rel="noopener">背包问题</a>、斐波那契数列</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95" target="_blank" rel="noopener">贪心法</a></td>
<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td>
<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td>
</tr>
</tbody></table>
<h2 id="❓-Problems"><a href="#❓-Problems" class="headerlink" title="❓ Problems"></a>❓ Problems</h2><h3 id="Single-Problem"><a href="#Single-Problem" class="headerlink" title="Single Problem"></a>Single Problem</h3><ul>
<li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li>
<li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li>
<li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li>
<li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li>
<li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li>
</ul>
<h3 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h3><ul>
<li><a href="https://github.com/haoel/leetcode" target="_blank" rel="noopener">Github . haoel/leetcode</a></li>
<li><a href="https://github.com/pezy/LeetCode" target="_blank" rel="noopener">Github . pezy/LeetCode</a></li>
</ul>
<h3 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h3><ul>
<li><a href="https://github.com/zhedahht/CodingInterviewChinese2" target="_blank" rel="noopener">Github . zhedahht/CodingInterviewChinese2</a></li>
<li><a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">Github . gatieme/CodingInterviews</a></li>
</ul>
<h3 id="Cracking-the-Coding-Interview-程序员面试金典"><a href="#Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="Cracking the Coding Interview 程序员面试金典"></a>Cracking the Coding Interview 程序员面试金典</h3><ul>
<li><a href="https://github.com/careercup/ctci" target="_blank" rel="noopener">Github . careercup/ctci</a></li>
<li><a href="https://www.nowcoder.com/ta/cracking-the-coding-interview" target="_blank" rel="noopener">牛客网 . 程序员面试金典</a></li>
</ul>
<h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><ul>
<li><a href="https://www.nowcoder.com/activity/oj" target="_blank" rel="noopener">牛客网 . 在线编程专题</a></li>
</ul>
<h2 id="💻-操作系统"><a href="#💻-操作系统" class="headerlink" title="💻 操作系统"></a>💻 操作系统</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>对于有线程系统：</p>
<ul>
<li>进程是资源分配的独立单位</li>
<li>线程是资源调度的独立单位</li>
</ul>
<p>对于无线程系统：</p>
<ul>
<li>进程是资源调度、分配的独立单位</li>
</ul>
<h4 id="进程之间的通信方式以及优缺点"><a href="#进程之间的通信方式以及优缺点" class="headerlink" title="进程之间的通信方式以及优缺点"></a>进程之间的通信方式以及优缺点</h4><ul>
<li>管道（PIPE）<ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul>
<li>优点：简单方便</li>
<li>缺点：<ol>
<li>局限于单向通信 </li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
</li>
<li>套接字（Socket）：可用于不同及其间的进程通信<ul>
<li>优点：<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><ul>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p>
<blockquote>
<p>进程之间的通信方式以及优缺点来源于：<a href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977" target="_blank" rel="noopener">进程线程面试题总结</a></p>
</blockquote>
<h4 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h4><ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h4 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h4><ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h4 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<h5 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h5><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody></table>
<h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a href="https://blog.csdn.net/lishenglong666/article/details/8557215" target="_blank" rel="noopener">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h3 id="Linux-内核的同步方式"><a href="#Linux-内核的同步方式" class="headerlink" title="Linux 内核的同步方式"></a>Linux 内核的同步方式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p>
<h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
<blockquote>
<p>来自：<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/" target="_blank" rel="noopener">Linux 内核的同步机制，第 1 部分</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/" target="_blank" rel="noopener">Linux 内核的同步机制，第 2 部分</a></p>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li>环路</li>
</ul>
<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul>
<li>Windows：FCB 表 + FAT + 位图</li>
<li>Unix：inode + 混合索引 + 成组链接</li>
</ul>
<h3 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h3><h4 id="主机字节序（CPU-字节序）"><a href="#主机字节序（CPU-字节序）" class="headerlink" title="主机字节序（CPU 字节序）"></a>主机字节序（CPU 字节序）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p>
<ul>
<li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li>
<li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li>
</ul>
<h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x00</th>
<th>0x01</th>
<th>0x02</th>
<th>0x03</th>
</tr>
</thead>
<tbody><tr>
<td>大端</td>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
<tr>
<td>小端</td>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody></table>
<p>大端小端图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Big-Endian.svg.png" alt="大端序"><br><img src="https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Little-Endian.svg.png" alt="小端序"></p>
<h5 id="判断大端小端"><a href="#判断大端小端" class="headerlink" title="判断大端小端"></a>判断大端小端</h5><p>判断大端小端</p>
<p>可以这样判断自己 CPU 字节序是大端还是小端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"大端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"小端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="各架构处理器的字节序"><a href="#各架构处理器的字节序" class="headerlink" title="各架构处理器的字节序"></a>各架构处理器的字节序</h5><ul>
<li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li>
<li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li>
</ul>
<h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</p>
<p>网络字节顺序采用：大端（Big Endian）排列方式。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li>全局置换：在整个内存空间置换</li>
<li>局部置换：在本进程中进行置换</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>全局：</p>
<ul>
<li>工作集算法</li>
<li>缺页率置换算法</li>
</ul>
<p>局部：</p>
<ul>
<li>最佳置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用（LRU）算法</li>
<li>时钟（Clock）置换算法</li>
</ul>
<h2 id="☁️-计算机网络"><a href="#☁️-计算机网络" class="headerlink" title="☁️ 计算机网络"></a>☁️ 计算机网络</h2><blockquote>
<p>本节部分知识点来自《计算机网络（第 7 版）》</p>
</blockquote>
<p>计算机网络体系结构：</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p>
<h3 id="各层作用及协议"><a href="#各层作用及协议" class="headerlink" title="各层作用及协议"></a>各层作用及协议</h3><table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>将比特组装成帧和点到点的传递（帧 Frame）</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包从源到宿的传递和网际互连（包 Packet）</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话（会话协议数据单元 SPDU）</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>表示层</td>
<td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
</tbody></table>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li>传输数据的单位：比特</li>
<li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li>
</ul>
<p>通道：</p>
<ul>
<li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li>
<li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li>
<li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li>
</ul>
<p>通道复用技术：</p>
<ul>
<li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要信道：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul>
<li>数据单元：帧</li>
</ul>
<p>三个基本问题：</p>
<ul>
<li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li>
<li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li>
<li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li>
</ul>
<p>点对点协议（Point-to-Point Protocol）：</p>
<ul>
<li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li>
</ul>
<h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p>
<ul>
<li>硬件地址（物理地址、MAC 地址）</li>
<li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li>
<li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li>
<li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
</ul>
<h4 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h4><p>IP 地址分类：</p>
<ul>
<li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li>
</ul>
<table>
<thead>
<tr>
<th>IP 地址类别</th>
<th>网络号</th>
<th>网络范围</th>
<th>主机号</th>
<th>IP 地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A 类</td>
<td>8bit，第一位固定为 0</td>
<td>0 —— 127</td>
<td>24bit</td>
<td>1.0.0.0 —— 127.255.255.255</td>
</tr>
<tr>
<td>B 类</td>
<td>16bit，前两位固定为  10</td>
<td>128.0 —— 191.255</td>
<td>16bit</td>
<td>128.0.0.0 —— 191.255.255.255</td>
</tr>
<tr>
<td>C  类</td>
<td>24bit，前三位固定为  110</td>
<td>192.0.0 —— 223.255.255</td>
<td>8bit</td>
<td>192.0.0.0 —— 223.255.255.255</td>
</tr>
<tr>
<td>D  类</td>
<td>前四位固定为 1110，后面为多播地址</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E  类</td>
<td>前五位固定为 11110，后面保留为今后所用</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>IP 数据报格式：</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP 数据报格式"></p>
<h4 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP 报文格式"></p>
<p>应用：</p>
<ul>
<li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul>
<li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li>
</ul>
</li>
</ul>
<h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul>
<li>RIP（Routing Information Protocol，路由信息协议）</li>
<li>OSPF（Open Sortest Path First，开放最短路径优先）</li>
</ul>
<h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
</ul>
<h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
<li>多播路由选择协议</li>
</ul>
<h4 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h4><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="路由表包含什么？"><a href="#路由表包含什么？" class="headerlink" title="路由表包含什么？"></a>路由表包含什么？</h4><ol>
<li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li>
<li>子网掩码（subnet mask）：用来判断 IP 所属网络</li>
<li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li>
</ol>
<p>根据应用和执行的不同，路由表可能含有如下附加信息：</p>
<ol>
<li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li>
<li>路由的服务质量</li>
<li>路由中需要过滤的出/入连接列表</li>
</ol>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>协议：</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>UDP（User Datagram Protocol，用户数据报协议）</li>
</ul>
<p>端口：</p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>HTTPS</th>
<th>SNMP</th>
</tr>
</thead>
<tbody><tr>
<td>端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>443</td>
<td>161</td>
</tr>
</tbody></table>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li>
</ul>
<p>特征：</p>
<ul>
<li>面向连接</li>
<li>只能点对点（一对一）通信</li>
<li>可靠交互</li>
<li>全双工通信</li>
<li>面向字节流</li>
</ul>
<p>TCP 如何保证可靠传输：</p>
<ul>
<li>确认和超时重传</li>
<li>数据合理分片和排序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>数据校验</li>
</ul>
<p>TCP 报文结构</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E6%8A%A5%E6%96%87.png" alt="TCP 报文"></p>
<p>TCP 首部</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E9%A6%96%E9%83%A8.png" alt="TCP 首部"></p>
<p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p>
<ul>
<li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li>
<li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li>
<li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li>
<li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li>
<li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li>
</ul>
<p>特征：</p>
<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>没有拥塞控制</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
<li>首部开销小</li>
</ul>
<p>UDP 报文结构</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/UDP%E6%8A%A5%E6%96%87.png" alt="UDP 报文"></p>
<p>UDP 首部</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/UDP%E9%A6%96%E9%83%A8.png" alt="UDP 首部"></p>
<blockquote>
<p>TCP/UDP 图片来源于：<a href="https://github.com/JerryC8080/understand-tcp-udp" target="_blank" rel="noopener">https://github.com/JerryC8080/understand-tcp-udp</a></p>
</blockquote>
<h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol>
<li>TCP 面向连接，UDP 是无连接的；</li>
<li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li>
<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>
<li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li>
</ol>
<h4 id="TCP-黏包问题"><a href="#TCP-黏包问题" class="headerlink" title="TCP 黏包问题"></a>TCP 黏包问题</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li>
<li>使用更加复杂的应用层协议。</li>
</ul>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>利用可变窗口进行流量控制</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt></p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li>慢开始( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )</li>
</ul>
<p>TCP的拥塞控制图</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt><br><img src="https://raw.githubusercontent.com/huihut/interview/master/images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p>
<h4 id="TCP-传输连接管理"><a href="#TCP-传输连接管理" class="headerlink" title="TCP 传输连接管理"></a>TCP 传输连接管理</h4><blockquote>
<p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<a href="https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png</a></p>
</blockquote>
<h5 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h5><p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p>
<p>【TCP 建立连接全过程解释】</p>
<ol>
<li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li>
<li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li>
<li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li>
<li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li>
</ol>
<h5 id="TCP-为什么要进行三次握手？"><a href="#TCP-为什么要进行三次握手？" class="headerlink" title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p>
<blockquote>
<p><a href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ" target="_blank" rel="noopener">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}</a></p>
</blockquote>
<p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="noopener">知乎 . TCP 为什么是三次握手，而不是两次或四次？</a></p>
</blockquote>
<p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<blockquote>
<p><a href="https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png" target="_blank" rel="noopener">《计算机网络（第 7 版）-谢希仁》</a></p>
</blockquote>
<h5 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h5><p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p>
<p>【TCP 释放连接全过程解释】</p>
<ol>
<li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li>
<li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li>
<li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li>
<li>服务端继续发送之前没发完的数据给客户端；</li>
<li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li>
<li>客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；</li>
<li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li>
</ol>
<h5 id="TCP-为什么要进行四次挥手？"><a href="#TCP-为什么要进行四次挥手？" class="headerlink" title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p>
<p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p>
<p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p>
<p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p>
<p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p>
<p>【答案三】</p>
<ol>
<li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li>
<li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li>
</ol>
<h4 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h4><p>TCP 有限状态机图片</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP 的有限状态机"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul>
<li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li>
</ul>
<p>域名：</p>
<ul>
<li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li>
</ul>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><ul>
<li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li>
</ul>
<h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><ul>
<li><p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p>
</li>
<li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p>
</li>
<li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p>
</li>
<li><p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p>
</li>
</ul>
<h4 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h4><ul>
<li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li>
</ul>
<h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul>
<li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li>
</ul>
<p>标准格式：</p>
<ul>
<li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<p>完整格式：</p>
<ul>
<li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<blockquote>
<p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p>
</blockquote>
<h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>请求方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>OPTIONS</td>
<td>请求一些选项信息，允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody></table>
<p>状态码（Status-Code）</p>
<ul>
<li>1xx：表示通知信息，如请求收到了或正在进行处理<ul>
<li>100 Continue：继续，客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li>2xx：表示成功，如接收或知道了<ul>
<li>200 OK: 请求成功</li>
</ul>
</li>
<li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul>
<li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li>
</ul>
</li>
<li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized: 请求要求用户的身份认证</li>
<li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li>
<li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li>
<li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul>
<li>500 Internal Server Error: 服务器内部错误，无法完成请求</li>
<li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li>
<li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多状态码：<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟教程 . HTTP状态码</a></p>
</blockquote>
<h5 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h5><ul>
<li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul>
<li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段</li>
</ul>
</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li>
</ul>
<h2 id="🌩-网络编程"><a href="#🌩-网络编程" class="headerlink" title="🌩 网络编程"></a>🌩 网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote>
<p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">Linux Socket 编程（不限 Linux）</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p>
<h4 id="Socket-中的-read-、write-函数"><a href="#Socket-中的-read-、write-函数" class="headerlink" title="Socket 中的 read()、write() 函数"></a>Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>

<h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><ul>
<li>read 函数是负责从 fd 中读取内容。</li>
<li>当读成功时，read 返回实际所读的字节数。</li>
<li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li>
<li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li>
</ul>
<h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><ul>
<li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li>
<li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li>
<li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li>
<li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li>
<li>（2）返回的值小于 0，此时出现了错误。</li>
<li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li>
</ul>
<h4 id="Socket-中-TCP-的三次握手建立连接"><a href="#Socket-中-TCP-的三次握手建立连接" class="headerlink" title="Socket 中 TCP 的三次握手建立连接"></a>Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p>
<ol>
<li>客户端向服务器发送一个 SYN J</li>
<li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li>
<li>客户端再想服务器发一个确认 ACK K+1</li>
</ol>
<p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p>
<p>从图中可以看出：</p>
<ol>
<li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li>
<li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li>
<li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li>
<li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li>
</ol>
<h4 id="Socket-中-TCP-的四次握手释放连接"><a href="#Socket-中-TCP-的四次握手释放连接" class="headerlink" title="Socket 中 TCP 的四次握手释放连接"></a>Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p>
<p>图示过程如下：</p>
<ol>
<li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li>
<li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li>
<li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li>
</ol>
<p>这样每个方向上都有一个 FIN 和 ACK。</p>
<h2 id="💾-数据库"><a href="#💾-数据库" class="headerlink" title="💾 数据库"></a>💾 数据库</h2><blockquote>
<p>本节部分知识点来自《数据库系统概论（第 5 版）》</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>数据（data）：描述事物的符号记录称为数据。</li>
<li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li>
<li>数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li>
<li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li>
<li>实体（entity）：客观存在并可相互区别的事物称为实体。</li>
<li>属性（attribute）：实体所具有的某一特性称为属性。</li>
<li>码（key）：唯一标识实体的属性集称为码。</li>
<li>实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li>实体集（entity set）：同一实体型的集合称为实体集。</li>
<li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li>
<li>模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li>
<li>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li>
<li>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</li>
</ul>
<h3 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h3><ul>
<li>层次模型（hierarchical model）</li>
<li>网状模型（network model）</li>
<li>关系模型（relational model）<ul>
<li>关系（relation）：一个关系对应通常说的一张表</li>
<li>元组（tuple）：表中的一行即为一个元组</li>
<li>属性（attribute）：表中的一列即为一个属性</li>
<li>码（key）：表中可以唯一确定一个元组的某个属性组</li>
<li>域（domain）：一组具有相同数据类型的值的集合</li>
<li>分量：元组中的一个属性值</li>
<li>关系模式：对关系的描述，一般表示为 <code>关系名(属性1, 属性2, ..., 属性n)</code></li>
</ul>
</li>
<li>面向对象数据模型（object oriented data model）</li>
<li>对象关系数据模型（object relational data model）</li>
<li>半结构化数据模型（semistructure data model）</li>
</ul>
<h3 id="常用-SQL-操作"><a href="#常用-SQL-操作" class="headerlink" title="常用 SQL 操作"></a>常用 SQL 操作</h3><table>
  <tr>
    <th>对象类型</th>
    <th>对象</th>
    <th>操作类型</th>
  </tr>
  <tr>
    <td rowspan="4">数据库模式</td>
    <td>模式</td>
    <td><code>CREATE SCHEMA</code></td>
  </tr>
  <tr>
    <td>基本表</td>
    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>
  </tr>
    <tr>
    <td>视图</td>
    <td><code>CREATE VIEW</code></td>
  </tr>
    <tr>
    <td>索引</td>
    <td><code>CREATE INDEX</code></td>
  </tr>
    <tr>
    <td rowspan="2">数据</td>
    <td>基本表和视图</td>
    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>
  </tr>
    <tr>
    <td>属性列</td>
    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>
  </tr>
</table>

<blockquote>
<p>SQL 语法教程：<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">runoob . SQL 教程</a></p>
</blockquote>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul>
<li>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</li>
<li>关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>数据库索引：顺序索引、B+ 树索引、hash 索引</li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li>
</ul>
<h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><ul>
<li>数据库的完整性是指数据的正确性和相容性。<ul>
<li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li>
<li>安全性：为了保护数据库防止恶意破坏和非法存取。</li>
</ul>
</li>
<li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。</li>
</ul>
<h3 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h3><ul>
<li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li>
<li>最重要的数据依赖：函数依赖、多值依赖。</li>
</ul>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><ul>
<li>第一范式（1NF）：属性（字段）是最小单位不可再分。</li>
<li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。</li>
<li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。</li>
<li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li>
<li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。</li>
</ul>
<h3 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h3><ul>
<li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li>
<li>事物的 ACID 特性：原子性、一致性、隔离性、持续性。</li>
<li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li>
<li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul>
<li>事务是并发控制的基本单位。</li>
<li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li>
<li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li>
<li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li>
<li>活锁死锁：<ul>
<li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li>
<li>死锁：事物永远不能结束<ul>
<li>预防：一次封锁法、顺序封锁法；</li>
<li>诊断：超时法、等待图法；</li>
<li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li>
</ul>
</li>
</ul>
</li>
<li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。</li>
</ul>
<h2 id="📏-设计模式"><a href="#📏-设计模式" class="headerlink" title="📏 设计模式"></a>📏 设计模式</h2><blockquote>
<p>各大设计模式例子参考：<a href="https://blog.csdn.net/column/details/15392.html" target="_blank" rel="noopener">CSDN专栏 . C++ 设计模式</a> 系列博文</p>
</blockquote>
<p><a href="DesignPattern">设计模式工程目录</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul>
<li>单一职责原则（SRP，Single Responsibility Principle）</li>
<li>里氏替换原则（LSP，Liskov Substitution Principle）</li>
<li>依赖倒置原则（DIP，Dependence Inversion Principle）</li>
<li>接口隔离原则（ISP，Interface Segregation Principle）</li>
<li>迪米特法则（LoD，Law of Demeter）</li>
<li>开放封闭原则（OCP，Open Close Principle）</li>
</ul>
<h2 id="⚙️-链接装载库"><a href="#⚙️-链接装载库" class="headerlink" title="⚙️ 链接装载库"></a>⚙️ 链接装载库</h2><blockquote>
<p>本节部分知识点来自《程序员的自我修养——链接装载库》</p>
</blockquote>
<h3 id="内存、栈、堆"><a href="#内存、栈、堆" class="headerlink" title="内存、栈、堆"></a>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p>
<ul>
<li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li>
<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li>
<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存上下文：包括函数调用前后需要保持不变的寄存器</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆分配算法：</p>
<ul>
<li>空闲链表（Free List）</li>
<li>位图（Bitmap）</li>
<li>对象池</li>
</ul>
<h4 id="“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”"></a>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p>
<p>普遍原因：</p>
<ul>
<li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li>
<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li>
</ul>
<h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="各平台文件格式"><a href="#各平台文件格式" class="headerlink" title="各平台文件格式"></a>各平台文件格式</h4><table>
<thead>
<tr>
<th>平台</th>
<th>可执行文件</th>
<th>目标文件</th>
<th>动态库/共享对象</th>
<th>静态库</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>exe</td>
<td>obj</td>
<td>dll</td>
<td>lib</td>
</tr>
<tr>
<td>Unix/Linux</td>
<td>ELF、out</td>
<td>o</td>
<td>so</td>
<td>a</td>
</tr>
<tr>
<td>Mac</td>
<td>Mach-O</td>
<td>o</td>
<td>dylib、tbd、framework</td>
<td>a、framework</td>
</tr>
</tbody></table>
<h4 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h4><ol>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li>
<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li>
</ol>
<blockquote>
<p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p>
</blockquote>
<blockquote>
<p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p>
</blockquote>
<h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<blockquote>
<p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p>
</blockquote>
<h5 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h5><ul>
<li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li>
<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li>
<li>Intel/Microsoft 的 OMF（Object Module Format）</li>
<li>Unix 的 <code>a.out</code> 格式</li>
<li>MS-DOS 的 <code>.COM</code> 格式</li>
</ul>
<blockquote>
<p>PE 和 ELF 都是 COFF（Common File Format）的变种</p>
</blockquote>
<h5 id="目标文件存储结构"><a href="#目标文件存储结构" class="headerlink" title="目标文件存储结构"></a>目标文件存储结构</h5><table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody></table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h4 id="链接的接口————符号"><a href="#链接的接口————符号" class="headerlink" title="链接的接口————符号"></a>链接的接口————符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>如下符号表（Symbol Table）：</p>
<table>
<thead>
<tr>
<th>Symbol（符号名）</th>
<th>Symbol Value （地址）</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>0x100</td>
</tr>
<tr>
<td>Add</td>
<td>0x123</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="Linux-的共享库（Shared-Library）"><a href="#Linux-的共享库（Shared-Library）" class="headerlink" title="Linux 的共享库（Shared Library）"></a>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p>
<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><code>libname.so.x.y.z</code></p>
<ul>
<li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li>
<li>y：次版本号，高版本号向后兼容低版本号</li>
<li>z：发布版本号，不对接口进行更改，完全兼容</li>
</ul>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="so-共享库的编写"><a href="#so-共享库的编写" class="headerlink" title="so 共享库的编写"></a>so 共享库的编写</h4><p>使用 CLion 编写共享库</p>
<p>创建一个名为 MySharedLib 的共享库</p>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure>

<p>library.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>library.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="so-共享库的使用（被可执行项目调用）"><a href="#so-共享库的使用（被可执行项目调用）" class="headerlink" title="so 共享库的使用（被可执行项目调用）"></a>so 共享库的使用（被可执行项目调用）</h4><p>使用 CLion 调用共享库</p>
<p>创建一个名为 TestSharedLib 的可执行项目</p>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 + 3 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1 + 2 = 3</span><br><span class="line">1 + 2 + 3 = 6</span><br></pre></td></tr></table></figure>

<h3 id="Windows-应用程序入口函数"><a href="#Windows-应用程序入口函数" class="headerlink" title="Windows 应用程序入口函数"></a>Windows 应用程序入口函数</h3><ul>
<li>GUI（Graphical User Interface）应用，链接器选项：<code>/SUBSYSTEM:WINDOWS</code></li>
<li>CUI（Console User Interface）应用，链接器选项：<code>/SUBSYSTEM:CONSOLE</code></li>
</ul>
<p>_tWinMain 与 _tmain 函数声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Int WINAPI _tWinMain(</span><br><span class="line">    HINSTANCE hInstanceExe,</span><br><span class="line">    HINSTANCE,</span><br><span class="line">    PTSTR pszCmdLine,</span><br><span class="line">    <span class="keyword">int</span> nCmdShow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(</span><br><span class="line">    <span class="keyword">int</span> argc,</span><br><span class="line">    TCHAR *argv[],</span><br><span class="line">    TCHAR *envp[]);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>应用程序类型</th>
<th>入口点函数</th>
<th>嵌入可执行文件的启动函数</th>
</tr>
</thead>
<tbody><tr>
<td>处理ANSI字符（串）的GUI应用程序</td>
<td>_tWinMain(WinMain)</td>
<td>WinMainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的GUI应用程序</td>
<td>_tWinMain(wWinMain)</td>
<td>wWinMainCRTSartup</td>
</tr>
<tr>
<td>处理ANSI字符（串）的CUI应用程序</td>
<td>_tmain(Main)</td>
<td>mainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的CUI应用程序</td>
<td>_tmain(wMain)</td>
<td>wmainCRTSartup</td>
</tr>
<tr>
<td>动态链接库（Dynamic-Link Library）</td>
<td>DllMain</td>
<td>_DllMainCRTStartup</td>
</tr>
</tbody></table>
<h3 id="Windows-的动态链接库（Dynamic-Link-Library）"><a href="#Windows-的动态链接库（Dynamic-Link-Library）" class="headerlink" title="Windows 的动态链接库（Dynamic-Link Library）"></a>Windows 的动态链接库（Dynamic-Link Library）</h3><blockquote>
<p>部分知识点来自《Windows 核心编程（第五版）》</p>
</blockquote>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul>
<li>扩展了应用程序的特性</li>
<li>简化了项目管理</li>
<li>有助于节省内存</li>
<li>促进了资源的共享</li>
<li>促进了本地化</li>
<li>有助于解决平台间的差异</li>
<li>可以用于特殊目的</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>创建 DLL，事实上是在创建可供一个可执行模块调用的函数</li>
<li>当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）</li>
<li>在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符</li>
<li>一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）</li>
<li>DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前</li>
<li>调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI</li>
</ul>
<h4 id="加载-Windows-程序的搜索顺序"><a href="#加载-Windows-程序的搜索顺序" class="headerlink" title="加载 Windows 程序的搜索顺序"></a>加载 Windows 程序的搜索顺序</h4><ol>
<li>包含可执行文件的目录</li>
<li>Windows 的系统目录，可以通过 GetSystemDirectory 得到</li>
<li>16 位的系统目录，即 Windows 目录中的 System 子目录</li>
<li>Windows 目录，可以通过 GetWindowsDirectory 得到</li>
<li>进程的当前目录</li>
<li>PATH 环境变量中所列出的目录</li>
</ol>
<h4 id="DLL-入口函数"><a href="#DLL-入口函数" class="headerlink" title="DLL 入口函数"></a>DLL 入口函数</h4><p>DllMain 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// 第一次将一个DLL映射到进程地址空间时调用</span></span><br><span class="line">        <span class="comment">// The DLL is being mapped into the process' address space.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="comment">// 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）</span></span><br><span class="line">        <span class="comment">// A thread is bing created.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="comment">// 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理</span></span><br><span class="line">        <span class="comment">// A thread is exiting cleanly.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">// 将一个DLL从进程的地址空间时调用</span></span><br><span class="line">        <span class="comment">// The DLL is being unmapped from the process' address space.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (TRUE); <span class="comment">// Used only for DLL_PROCESS_ATTACH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="载入卸载库"><a href="#载入卸载库" class="headerlink" title="载入卸载库"></a>载入卸载库</h4><p>LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入库</span></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryExA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpLibFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx</span></span><br><span class="line"><span class="function">HMODULE <span class="title">LoadPackagedLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpwLibFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   Reserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载库</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">// 卸载库和退出线程</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">FreeLibraryAndExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD   dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="显示地链接到导出符号"><a href="#显示地链接到导出符号" class="headerlink" title="显示地链接到导出符号"></a>显示地链接到导出符号</h4><p>GetProcAddress 函数声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HMODULE hInstDll,</span></span></span><br><span class="line"><span class="function"><span class="params">  PCSTR pszSymbolName  <span class="comment">// 只能接受 ANSI 字符串，不能是 Unicode</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DumpBin-exe-查看-DLL-信息"><a href="#DumpBin-exe-查看-DLL-信息" class="headerlink" title="DumpBin.exe 查看 DLL 信息"></a>DumpBin.exe 查看 DLL 信息</h4><p>在 <code>VS 的开发人员命令提示符</code> 使用 <code>DumpBin.exe</code> 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DUMPBIN -exports D:\mydll.dll</span><br></pre></td></tr></table></figure>

<h4 id="LoadLibrary-与-FreeLibrary-流程图"><a href="#LoadLibrary-与-FreeLibrary-流程图" class="headerlink" title="LoadLibrary 与 FreeLibrary 流程图"></a>LoadLibrary 与 FreeLibrary 流程图</h4><p>LoadLibrary 与 FreeLibrary 流程图</p>
<h5 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary"></a>LoadLibrary</h5><p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/WindowsLoadLibrary.png" alt="WindowsLoadLibrary"></p>
<h5 id="FreeLibrary"><a href="#FreeLibrary" class="headerlink" title="FreeLibrary"></a>FreeLibrary</h5><p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/WindowsFreeLibrary.png" alt="WindowsFreeLibrary"></p>
<h4 id="DLL-库的编写（导出一个-DLL-模块）"><a href="#DLL-库的编写（导出一个-DLL-模块）" class="headerlink" title="DLL 库的编写（导出一个 DLL 模块）"></a>DLL 库的编写（导出一个 DLL 模块）</h4><p>DLL 库的编写（导出一个 DLL 模块）<br>DLL 头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLib.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYLIBAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MYLIBAPI 应该在全部 DLL 源文件的 include "Mylib.h" 之前被定义</span></span><br><span class="line"><span class="comment">// 全部函数/变量正在被导出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义任何的数据结构和符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义导出的变量（避免导出变量）</span></span><br><span class="line">MYLIBAPI <span class="keyword">int</span> g_nResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义导出函数原型</span></span><br><span class="line"><span class="function">MYLIBAPI <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span></span>;</span><br></pre></td></tr></table></figure>

<p>DLL 源文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLibFile1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含标准Windows和C运行时头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL源码文件导出的函数和变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含导出的数据结构、符号、函数、变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyLib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此DLL源代码文件的代码放在此处</span></span><br><span class="line"><span class="keyword">int</span> g_nResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_nResult = nLeft + nRight;</span><br><span class="line">    <span class="keyword">return</span> g_nResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DLL-库的使用（运行时动态链接-DLL）"><a href="#DLL-库的使用（运行时动态链接-DLL）" class="headerlink" title="DLL 库的使用（运行时动态链接 DLL）"></a>DLL 库的使用（运行时动态链接 DLL）</h4><p>DLL 库的使用（运行时动态链接 DLL）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple program that uses LoadLibrary and </span></span><br><span class="line"><span class="comment">// GetProcAddress to access myPuts from Myputs.dll. </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__cdecl *MYPROC)</span><span class="params">(LPWSTR)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    HINSTANCE hinstLib; </span><br><span class="line">    MYPROC ProcAdd; </span><br><span class="line">    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get a handle to the DLL module.</span></span><br><span class="line"> </span><br><span class="line">    hinstLib = LoadLibrary(TEXT(<span class="string">"MyPuts.dll"</span>)); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the handle is valid, try to get the function address.</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (hinstLib != <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        ProcAdd = (MYPROC) GetProcAddress(hinstLib, <span class="string">"myPuts"</span>); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If the function address is valid, call the function.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != ProcAdd) </span><br><span class="line">        &#123;</span><br><span class="line">            fRunTimeLinkSuccess = TRUE;</span><br><span class="line">            (ProcAdd) (<span class="string">L"Message sent to the DLL function\n"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Free the DLL module.</span></span><br><span class="line"> </span><br><span class="line">        fFreeResult = FreeLibrary(hinstLib); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If unable to call the DLL function, use an alternative.</span></span><br><span class="line">    <span class="keyword">if</span> (! fRunTimeLinkSuccess) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message printed from executable\n"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行库（Runtime-Library）"><a href="#运行库（Runtime-Library）" class="headerlink" title="运行库（Runtime Library）"></a>运行库（Runtime Library）</h3><h4 id="典型程序运行步骤"><a href="#典型程序运行步骤" class="headerlink" title="典型程序运行步骤"></a>典型程序运行步骤</h4><ol>
<li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li>
<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li>
<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li>
</ol>
<blockquote>
<p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p>
</blockquote>
<h4 id="glibc-入口"><a href="#glibc-入口" class="headerlink" title="glibc 入口"></a>glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p>
<p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p>
<h4 id="MSVC-CRT-入口"><a href="#MSVC-CRT-入口" class="headerlink" title="MSVC CRT 入口"></a>MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p>
<p>执行如下操作：</p>
<ol>
<li>初始化和 OS 版本有关的全局变量。</li>
<li>初始化堆。</li>
<li>初始化 I/O。</li>
<li>获取命令行参数和环境变量。</li>
<li>初始化 C 库的一些数据。</li>
<li>调用 main 并记录返回值。</li>
<li>检查错误并将 main 的返回值返回。</li>
</ol>
<h4 id="C-语言运行库（CRT）"><a href="#C-语言运行库（CRT）" class="headerlink" title="C 语言运行库（CRT）"></a>C 语言运行库（CRT）</h4><p>大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O 功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h4 id="C语言标准库（ANSI-C）"><a href="#C语言标准库（ANSI-C）" class="headerlink" title="C语言标准库（ANSI C）"></a>C语言标准库（ANSI C）</h4><p>包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转换（stdlib.h）</li>
<li>时间/日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h &amp; float.h）</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>
<h2 id="📚-书籍"><a href="#📚-书籍" class="headerlink" title="📚 书籍"></a>📚 书籍</h2><blockquote>
<p><a href="https://github.com/huihut/CS-Books" target="_blank" rel="noopener">huihut/CS-Books</a>：📚 Computer Science Books 计算机技术类书籍 PDF</p>
</blockquote>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul>
<li>《C++ Primer》</li>
<li>《Effective C++》</li>
<li>《More Effective C++》</li>
<li>《深度探索 C++ 对象模型》</li>
<li>《深入理解 C++11》</li>
<li>《STL 源码剖析》</li>
</ul>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul>
<li>《剑指 Offer》</li>
<li>《编程珠玑》</li>
<li>《程序员面试宝典》</li>
</ul>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul>
<li>《深入理解计算机系统》</li>
<li>《Windows 核心编程》</li>
<li>《Unix 环境高级编程》</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>《Unix 网络编程》</li>
<li>《TCP/IP 详解》</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul>
<li>《程序员的自我修养》</li>
</ul>
<h2 id="🔱-C-C-发展方向"><a href="#🔱-C-C-发展方向" class="headerlink" title="🔱 C/C++ 发展方向"></a>🔱 C/C++ 发展方向</h2><blockquote>
<p>C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。</p>
</blockquote>
<h3 id="后台-服务器"><a href="#后台-服务器" class="headerlink" title="后台/服务器"></a>后台/服务器</h3><p>【后台开发】</p>
<ul>
<li>编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构；</li>
<li>熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程；</li>
<li>了解 Python、Shell、Perl 等脚本语言；</li>
<li>了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理；</li>
<li>全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；</li>
<li>了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。</li>
</ul>
<h3 id="桌面客户端"><a href="#桌面客户端" class="headerlink" title="桌面客户端"></a>桌面客户端</h3><p>【PC 客户端开发】</p>
<ul>
<li>计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识；  </li>
<li>熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； </li>
<li>熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验；</li>
<li>熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先；</li>
<li>对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。</li>
</ul>
<h3 id="图形学-游戏-VR-AR"><a href="#图形学-游戏-VR-AR" class="headerlink" title="图形学/游戏/VR/AR"></a>图形学/游戏/VR/AR</h3><p>【游戏客户端开发】</p>
<ul>
<li>计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识；</li>
<li>至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先；</li>
<li>具游戏引擎（如 Unity、Unreal）使用经验者优先；</li>
<li>了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑；</li>
<li>对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识；</li>
<li>具阅读英文技术文档能力；</li>
<li>热爱游戏。</li>
</ul>
<h3 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h3><p>【测试开发】</p>
<ul>
<li>计算机或相关专业本科及以上学历；</li>
<li>一至两年的 C/C++/Python 或其他计算机语言的编程经验；</li>
<li>具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力；</li>
<li>具备实现自动化系统的能力；</li>
<li>具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力；</li>
<li>工作主动积极，有责任心，具有良好的团队合作精神。</li>
</ul>
<h3 id="网络安全-逆向"><a href="#网络安全-逆向" class="headerlink" title="网络安全/逆向"></a>网络安全/逆向</h3><p>【安全技术】</p>
<ul>
<li>热爱互联网，对操作系统和网络安全有狂热的追求，专业不限；</li>
<li>熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法；  </li>
<li>掌握基本开发能力，熟练使用 C/C++ 语言；</li>
<li>对数据库、操作系统、网络原理有较好掌握；  </li>
<li>具有软件逆向，网络安全攻防或安全系统开发经验者优先。</li>
</ul>
<h3 id="嵌入式-物联网"><a href="#嵌入式-物联网" class="headerlink" title="嵌入式/物联网"></a>嵌入式/物联网</h3><p>【嵌入式应用开发】</p>
<ul>
<li>有良好的编程基础，熟练掌握 C/C++ 语言；</li>
<li>掌握操作系统、数据结构等软件开发必备知识；</li>
<li>具备较强的沟通理解能力及良好的团队合作意识；</li>
<li>有 Linux/Android 系统平台的开发经验者优先。</li>
</ul>
<h3 id="音视频-流媒体-SDK"><a href="#音视频-流媒体-SDK" class="headerlink" title="音视频/流媒体/SDK"></a>音视频/流媒体/SDK</h3><p>【音视频编解码】</p>
<ol>
<li>硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； </li>
<li>视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； </li>
<li>掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； </li>
<li>较强的英文文献阅读能力； </li>
<li>学习能力强，具有团队协作精神，有较强的抗压能力。</li>
</ol>
<h3 id="计算机视觉-机器学习"><a href="#计算机视觉-机器学习" class="headerlink" title="计算机视觉/机器学习"></a>计算机视觉/机器学习</h3><p>【计算机视觉研究】</p>
<ul>
<li>计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先；</li>
<li>熟练掌握计算机视觉和图像处理相关的基本算法及应用；</li>
<li>较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言；</li>
<li>在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。</li>
</ul>
<h2 id="💯-复习刷题网站"><a href="#💯-复习刷题网站" class="headerlink" title="💯 复习刷题网站"></a>💯 复习刷题网站</h2><ul>
<li><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">cplusplus</a></li>
<li><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">cppreference</a></li>
<li><a href="http://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">runoob</a></li>
<li><a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a> | <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode-cn</a></li>
<li><a href="https://www.lintcode.com/" target="_blank" rel="noopener">lintcode</a></li>
<li><a href="https://www.nowcoder.net/" target="_blank" rel="noopener">nowcoder</a></li>
</ul>
<h2 id="📝-面试题目经验"><a href="#📝-面试题目经验" class="headerlink" title="📝 面试题目经验"></a>📝 面试题目经验</h2><ul>
<li><a href="https://www.nowcoder.com/discuss/205497" target="_blank" rel="noopener">牛客网 . 2020秋招面经大汇总！（岗位划分）</a></li>
<li><a href="https://www.nowcoder.com/discuss/197116" target="_blank" rel="noopener">牛客网 . 【备战秋招】2020届秋招备战攻略</a></li>
<li><a href="https://www.nowcoder.com/discuss/90907" target="_blank" rel="noopener">牛客网 . 2019校招面经大汇总！【每日更新中】</a></li>
<li><a href="https://www.nowcoder.com/discuss/146655" target="_blank" rel="noopener">牛客网 . 2019校招技术类岗位面经汇总【技术类】</a></li>
<li><a href="https://www.nowcoder.com/discuss/68802" target="_blank" rel="noopener">牛客网 . 2018校招笔试真题汇总</a></li>
<li><a href="https://www.nowcoder.com/discuss/12805" target="_blank" rel="noopener">牛客网 . 2017秋季校园招聘笔经面经专题汇总</a></li>
<li><a href="https://www.nowcoder.com/discuss/25268" target="_blank" rel="noopener">牛客网 . 史上最全2017春招面经大合集！！</a></li>
<li><a href="https://www.nowcoder.com/discuss/57978" target="_blank" rel="noopener">牛客网 . 面试题干货在此</a></li>
<li><a href="https://www.zhihu.com/question/29693016" target="_blank" rel="noopener">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。</a></li>
<li><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">知乎 . 互联网公司最常见的面试算法题有哪些？</a></li>
<li><a href="http://blog.csdn.net/ljzcome/article/details/574158" target="_blank" rel="noopener">CSDN . 全面整理的C++面试题</a></li>
<li><a href="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1" target="_blank" rel="noopener">CSDN . 百度研发类面试题（C++方向）</a></li>
<li><a href="http://blog.csdn.net/fakine/article/details/51321544" target="_blank" rel="noopener">CSDN . c++常见面试题30道</a></li>
<li><a href="http://blog.csdn.net/onever_say_love/article/details/51223886" target="_blank" rel="noopener">CSDN . 腾讯2016实习生面试经验（已经拿到offer)</a></li>
<li><a href="https://www.cnblogs.com/Y1Focus/p/6707121.html" target="_blank" rel="noopener">cnblogs . C++面试集锦( 面试被问到的问题 )</a></li>
<li><a href="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html" target="_blank" rel="noopener">cnblogs . C/C++ 笔试、面试题目大汇总</a></li>
<li><a href="https://www.cnblogs.com/LUO77/p/5771237.html" target="_blank" rel="noopener">cnblogs . 常见C++面试题及基本知识点总结（一）</a></li>
<li><a href="https://segmentfault.com/a/1190000003745529" target="_blank" rel="noopener">segmentfault . C++常见面试问题总结</a></li>
</ul>
<h2 id="2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。"><a href="#2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。" class="headerlink" title="2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。"></a>2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。</h2><ul>
<li><a href="#1">阿里篇</a></li>
<li><a href="#2">华为篇</a></li>
<li><a href="#3">百度篇</a></li>
<li><a href="#4">腾讯篇</a></li>
<li><a href="#5">美团篇</a></li>
<li><a href="#6">头条篇</a></li>
<li><a href="#7">滴滴篇</a></li>
<li><a href="#8">京东篇</a></li>
<li><a href="#9">MySQL篇</a></li>
<li><a href="#10">Redis篇</a></li>
<li><a href="#11">MongoDB篇</a></li>
<li><a href="#12">Zookeeper篇</a></li>
<li><a href="#13">Nginx篇</a></li>
<li><a href="#14">算法篇</a></li>
<li><a href="#15">内存篇</a></li>
<li><a href="#16">cpu篇</a></li>
<li><a href="#17">磁盘篇</a></li>
<li><a href="#18">网络通信篇</a></li>
<li><a href="#19">安全篇</a></li>
<li><a href="#20">并发篇</a></li>
</ul>
<h3 id="1">阿里篇</h3> 
---

<h5 id="1-1-1-如何实现一个高效的单向链表逆序输出？"><a href="#1-1-1-如何实现一个高效的单向链表逆序输出？" class="headerlink" title="1.1.1 如何实现一个高效的单向链表逆序输出？"></a><a href="01.阿里篇/1.1.1%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%EF%BC%9F.md">1.1.1 如何实现一个高效的单向链表逆序输出？</a></h5><h5 id="1-1-2-已知sqrt-2-约等于1-414，要求不用数学库，求sqrt-2-精确到小数点后10位"><a href="#1-1-2-已知sqrt-2-约等于1-414，要求不用数学库，求sqrt-2-精确到小数点后10位" class="headerlink" title="1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位"></a><a href="01.阿里篇/1.1.2%20%E5%B7%B2%E7%9F%A5sqrt%282%29%E7%BA%A6%E7%AD%89%E4%BA%8E1.414%EF%BC%8C%E8%A6%81%E6%B1%82%E4%B8%8D%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BA%93%EF%BC%8C%E6%B1%82sqrt%282%29%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E10%E4%BD%8D.md">1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位</a></h5><h5 id="1-1-3-给定一个二叉搜索树-BST-，找到树中第-K-小的节点"><a href="#1-1-3-给定一个二叉搜索树-BST-，找到树中第-K-小的节点" class="headerlink" title="1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点"></a><a href="01.阿里篇/1.1.3%20%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%28BST%29%EF%BC%8C%E6%89%BE%E5%88%B0%E6%A0%91%E4%B8%AD%E7%AC%AC%20K%20%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9.md">1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点</a></h5><h5 id="1-1-4-LRU缓存机制"><a href="#1-1-4-LRU缓存机制" class="headerlink" title="1.1.4 LRU缓存机制"></a><a href="01.阿里篇/1.1.4%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.md">1.1.4 LRU缓存机制</a></h5><h5 id="1-1-5-关于epoll和select的区别，以下哪些说法是正确的"><a href="#1-1-5-关于epoll和select的区别，以下哪些说法是正确的" class="headerlink" title="1.1.5 关于epoll和select的区别，以下哪些说法是正确的"></a><a href="01.阿里篇/1.1.5%20%E5%85%B3%E4%BA%8Eepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E8%AF%B4%E6%B3%95%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.md">1.1.5 关于epoll和select的区别，以下哪些说法是正确的</a></h5><h5 id="1-1-6-从innodb的索引结构分析，为什么索引的-key-长度不能太长"><a href="#1-1-6-从innodb的索引结构分析，为什么索引的-key-长度不能太长" class="headerlink" title="1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长"></a><a href="01.阿里篇/1.1.6%20%E4%BB%8Einnodb%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%9A%84%20key%20%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E5%A4%AA%E9%95%BF.md">1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长</a></h5><h5 id="1-1-7-MySQL的数据如何恢复到任意时间点？"><a href="#1-1-7-MySQL的数据如何恢复到任意时间点？" class="headerlink" title="1.1.7 MySQL的数据如何恢复到任意时间点？"></a><a href="01.阿里篇/1.1.7%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%9F.md">1.1.7 MySQL的数据如何恢复到任意时间点？</a></h5><h5 id="1-1-8-NFS-和-SMB-是最常见的两种-NAS（Network-Attached-Storage）协议，当把一个文件系统同时通过-NFS-和-SMB-协议共享给多个主机访问时，以下哪些说法是错误的"><a href="#1-1-8-NFS-和-SMB-是最常见的两种-NAS（Network-Attached-Storage）协议，当把一个文件系统同时通过-NFS-和-SMB-协议共享给多个主机访问时，以下哪些说法是错误的" class="headerlink" title="1.1.8 NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的"></a>1.1.8 NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的</h5><h5 id="1-1-9-输入-ping-IP-后敲回车，发包前会发生什么？"><a href="#1-1-9-输入-ping-IP-后敲回车，发包前会发生什么？" class="headerlink" title="1.1.9 输入 ping IP 后敲回车，发包前会发生什么？"></a><a href="01.阿里篇/1.1.9%20%E8%BE%93%E5%85%A5%20ping%20IP%20%E5%90%8E%E6%95%B2%E5%9B%9E%E8%BD%A6%EF%BC%8C%E5%8F%91%E5%8C%85%E5%89%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F.md">1.1.9 输入 ping IP 后敲回车，发包前会发生什么？</a></h5><h5 id="1-2-0-请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"><a href="#1-2-0-请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？" class="headerlink" title="1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"></a><a href="01.阿里篇/1.2.0%20%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%B9%BF%E6%99%97%E5%8F%91%E5%B8%83%E6%81%8B%E6%83%85%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BE%AE%E5%8D%9A%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F.md">1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？</a></h5><h5 id="1-2-1-现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？"><a href="#1-2-1-现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？" class="headerlink" title="1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？"></a><a href="01.阿里篇/1.2.1%20%E7%8E%B0%E6%9C%89%E4%B8%80%E6%89%B9%E9%82%AE%E4%BB%B6%E9%9C%80%E8%A6%81%E5%8F%91%E9%80%81%E7%BB%99%E8%AE%A2%E9%98%85%E9%A1%BE%E5%AE%A2%EF%BC%8C%E4%B8%94%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%EF%BC%88%E9%9B%86%E7%BE%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E4%B8%8D%E5%AE%9A%EF%BC%8C%E4%BC%9A%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%EF%BC%89%E6%9D%A5%E8%B4%9F%E8%B4%A3%E5%85%B7%E4%BD%93%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%B0%BD%E5%BF%AB%E5%9C%B0%E5%AE%8C%E6%88%90%E5%8F%91%E9%80%81%EF%BC%9F.md">1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？</a></h5><h5 id="1-2-2-有一批气象观测站，现需要获取这些站点的观测数据，并存储到-Hive-中。但是气象局只提供了-api-查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"><a href="#1-2-2-有一批气象观测站，现需要获取这些站点的观测数据，并存储到-Hive-中。但是气象局只提供了-api-查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？" class="headerlink" title="1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"></a><a href="01.阿里篇/1.2.2%20%E6%9C%89%E4%B8%80%E6%89%B9%E6%B0%94%E8%B1%A1%E8%A7%82%E6%B5%8B%E7%AB%99%EF%BC%8C%E7%8E%B0%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96%E8%BF%99%E4%BA%9B%E7%AB%99%E7%82%B9%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0%20Hive%20%E4%B8%AD%E3%80%82%E4%BD%86%E6%98%AF%E6%B0%94%E8%B1%A1%E5%B1%80%E5%8F%AA%E6%8F%90%E4%BE%9B%E4%BA%86%20api%20%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%8F%AA%E8%83%BD%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E8%A7%82%E6%B5%8B%E7%82%B9%E3%80%82%E9%82%A3%E4%B9%88%E5%A6%82%E6%9E%9C%E8%83%BD%E5%A4%9F%E6%96%B9%E4%BE%BF%E5%BF%AB%E9%80%9F%E5%9C%B0%E8%8E%B7%E5%8F%96%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E8%A7%82%E6%B5%8B%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F.md">1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？</a></h5><h5 id="1-2-3-如何实现两金额数据相加（最多小数点两位）"><a href="#1-2-3-如何实现两金额数据相加（最多小数点两位）" class="headerlink" title="1.2.3 如何实现两金额数据相加（最多小数点两位）"></a><a href="01.阿里篇/1.2.3%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%87%91%E9%A2%9D%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0%EF%BC%88%E6%9C%80%E5%A4%9A%E5%B0%8F%E6%95%B0%E7%82%B9%E4%B8%A4%E4%BD%8D%EF%BC%89.md">1.2.3 如何实现两金额数据相加（最多小数点两位）</a></h5><h5 id="1-2-4-关于并行计算的一些基础开放问题"><a href="#1-2-4-关于并行计算的一些基础开放问题" class="headerlink" title="1.2.4 关于并行计算的一些基础开放问题"></a><a href="01.阿里篇/1.2.4%20%E5%85%B3%E4%BA%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%BC%80%E6%94%BE%E9%97%AE%E9%A2%98.md">1.2.4 关于并行计算的一些基础开放问题</a></h5><h5 id="1-2-5-请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式"><a href="#1-2-5-请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式" class="headerlink" title="1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式"></a><a href="01.阿里篇/1.2.5%20%E8%AF%B7%E8%AE%A1%E7%AE%97XILINX%E5%85%AC%E5%8F%B8VU9P%E8%8A%AF%E7%89%87%E7%9A%84%E7%AE%97%E5%8A%9B%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%A4%9A%E5%B0%91TOPS%EF%BC%8C%E7%BB%99%E5%87%BA%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%85%AC%E5%BC%8F.md">1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式</a></h5><h5 id="1-2-6-一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素"><a href="#1-2-6-一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素" class="headerlink" title="1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素"></a><a href="01.阿里篇/1.2.6%20%E4%B8%80%E9%A2%97%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%8C%E6%AF%8F%E7%A7%92%E5%A4%A7%E6%A6%82%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%A4%9A%E5%B0%91%E6%9D%A1%E7%AE%80%E5%8D%95%E7%9A%84MOV%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0.md">1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素</a></h5><h5 id="1-2-7-请分析-MaxCompute-产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势"><a href="#1-2-7-请分析-MaxCompute-产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势" class="headerlink" title="1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势"></a><a href="01.阿里篇/1.2.7%20%E8%AF%B7%E5%88%86%E6%9E%90%20MaxCompute%20%E4%BA%A7%E5%93%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%81%E5%BD%93%E5%89%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%B1%BB%E4%BA%A7%E5%93%81%E7%9A%84%E5%B8%82%E5%9C%BA%E7%8E%B0%E7%8A%B6%E5%92%8C%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF.md">1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势</a></h5><h5 id="1-2-8-对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响"><a href="#1-2-8-对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响" class="headerlink" title="1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响"></a><a href="01.阿里篇/1.2.8%20%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E4%B8%AD%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%8C%E5%85%83%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E4%BC%9A%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%BD%B1%E5%93%8D.md">1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响</a></h5><h5 id="1-2-9-你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述"><a href="#1-2-9-你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述" class="headerlink" title="1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述"></a><a href="01.阿里篇/1.2.9%20%E4%BD%A0%E7%90%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E5%A6%82%E9%98%BF%E9%87%8C%EF%BC%8C%E5%92%8C%E5%8F%8B%E5%95%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B7%AE%E5%BC%82%E4%BB%A5%E5%8F%8A%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%92%8C%E6%8A%80%E6%9C%AF%E7%93%B6%E9%A2%88%EF%BC%8C%E5%9C%A8%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%A6%82%E8%BF%B0.md">1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述</a></h5><h5 id="1-3-0-在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行-IO-读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时-如何保证优先级和公平性"><a href="#1-3-0-在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行-IO-读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时-如何保证优先级和公平性" class="headerlink" title="1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时,如何保证优先级和公平性"></a>1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时,如何保证优先级和公平性</h5><h5 id="1-3-1-最大频率栈"><a href="#1-3-1-最大频率栈" class="headerlink" title="1.3.1 最大频率栈"></a><a href="01.阿里篇/1.3.1%20%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88.md">1.3.1 最大频率栈</a></h5><h5 id="1-3-2-给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点"><a href="#1-3-2-给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点" class="headerlink" title="1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点"></a><a href="01.阿里篇/1.3.2%20%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9.md">1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点</a></h5><h5 id="1-3-3-如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计"><a href="#1-3-3-如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计" class="headerlink" title="1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计"></a><a href="01.阿里篇/1.3.3%20%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%81%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%92%E7%BA%A7%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.md">1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计</a></h5><h5 id="1-3-4-如果让你来设计一个支持数据库、NOSQL-和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？"><a href="#1-3-4-如果让你来设计一个支持数据库、NOSQL-和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？" class="headerlink" title="1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？"></a><a href="01.阿里篇/1.3.4%20%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81NOSQL%20%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%B5%81%E5%8A%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%8A%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F.md">1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？</a></h5><h5 id="1-3-5-给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度"><a href="#1-3-5-给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度" class="headerlink" title="1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度"></a><a href="01.阿里篇/1.3.5%20%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%84%E5%8A%A0%E5%92%8C%E7%AD%89%E4%BA%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0%E3%80%82%E9%9C%80%E8%A6%81%E6%9C%80%E4%BC%98%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.md">1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度</a></h5><h5 id="1-3-6-假如给你一个新产品，你将从哪些方面来保障它的质量？"><a href="#1-3-6-假如给你一个新产品，你将从哪些方面来保障它的质量？" class="headerlink" title="1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？"></a><a href="01.阿里篇/1.3.6%20%E5%81%87%E5%A6%82%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%A7%E5%93%81%EF%BC%8C%E4%BD%A0%E5%B0%86%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%9D%A5%E4%BF%9D%E9%9A%9C%E5%AE%83%E7%9A%84%E8%B4%A8%E9%87%8F%EF%BC%9F.md">1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？</a></h5><h5 id="1-3-7-请评估一下程序的执行结果？"><a href="#1-3-7-请评估一下程序的执行结果？" class="headerlink" title="1.3.7 请评估一下程序的执行结果？"></a><a href="01.阿里篇/1.3.7%20%E8%AF%B7%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9F.md">1.3.7 请评估一下程序的执行结果？</a></h5><br>

<h3 id="2">华为篇</h3> 
---
##### 2.1.0 static有什么用途？（请至少说明两种）

<h6 id="2-1-1-引用与指针有什么区别？"><a href="#2-1-1-引用与指针有什么区别？" class="headerlink" title="2.1.1 引用与指针有什么区别？"></a>2.1.1 引用与指针有什么区别？</h6><h5 id="2-1-2-描述实时系统的基本特性"><a href="#2-1-2-描述实时系统的基本特性" class="headerlink" title="2.1.2 描述实时系统的基本特性"></a>2.1.2 描述实时系统的基本特性</h5><h5 id="2-1-3-全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#2-1-3-全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="2.1.3 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>2.1.3 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h5><h5 id="2-1-4-什么是平衡二叉树？"><a href="#2-1-4-什么是平衡二叉树？" class="headerlink" title="2.1.4 什么是平衡二叉树？"></a>2.1.4 什么是平衡二叉树？</h5><h5 id="2-1-5-堆栈溢出一般是由什么原因导致的？"><a href="#2-1-5-堆栈溢出一般是由什么原因导致的？" class="headerlink" title="2.1.5 堆栈溢出一般是由什么原因导致的？"></a>2.1.5 堆栈溢出一般是由什么原因导致的？</h5><h5 id="2-1-6-什么函数不能声明为虚函数？"><a href="#2-1-6-什么函数不能声明为虚函数？" class="headerlink" title="2.1.6 什么函数不能声明为虚函数？"></a>2.1.6 什么函数不能声明为虚函数？</h5><h5 id="2-1-7-冒泡排序算法的时间复杂度是什么？"><a href="#2-1-7-冒泡排序算法的时间复杂度是什么？" class="headerlink" title="2.1.7 冒泡排序算法的时间复杂度是什么？"></a>2.1.7 冒泡排序算法的时间复杂度是什么？</h5><h5 id="2-1-8-写出float-x-与“零值”比较的if语句"><a href="#2-1-8-写出float-x-与“零值”比较的if语句" class="headerlink" title="2.1.8 写出float x 与“零值”比较的if语句"></a>2.1.8 写出float x 与“零值”比较的if语句</h5><h5 id="2-1-9-Internet采用哪种网络协议？该协议的主要层次结构？"><a href="#2-1-9-Internet采用哪种网络协议？该协议的主要层次结构？" class="headerlink" title="2.1.9 Internet采用哪种网络协议？该协议的主要层次结构？"></a>2.1.9 Internet采用哪种网络协议？该协议的主要层次结构？</h5><h5 id="2-2-0-Internet物理地址和IP地址转换采用什么协议？"><a href="#2-2-0-Internet物理地址和IP地址转换采用什么协议？" class="headerlink" title="2.2.0 Internet物理地址和IP地址转换采用什么协议？"></a>2.2.0 Internet物理地址和IP地址转换采用什么协议？</h5><h5 id="2-2-1-IP地址的编码分为哪俩部分？"><a href="#2-2-1-IP地址的编码分为哪俩部分？" class="headerlink" title="2.2.1 IP地址的编码分为哪俩部分？"></a>2.2.1 IP地址的编码分为哪俩部分？</h5><h5 id="2-2-2-用户输入M-N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"><a href="#2-2-2-用户输入M-N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。" class="headerlink" title="2.2.2 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"></a>2.2.2 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。</h5><h5 id="2-2-3-不能做switch-的参数类型是"><a href="#2-2-3-不能做switch-的参数类型是" class="headerlink" title="2.2.3 不能做switch()的参数类型是"></a>2.2.3 不能做switch()的参数类型是</h5><h5 id="2-2-4-int-A-nSize-，其中隐藏着若干0，其余非0整数，写一个函数int-Func-int-A-int-nSize-，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。"><a href="#2-2-4-int-A-nSize-，其中隐藏着若干0，其余非0整数，写一个函数int-Func-int-A-int-nSize-，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。" class="headerlink" title="2.2.4 int A[nSize]，其中隐藏着若干0，其余非0整数，写一个函数int Func(int* A, int nSize)，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。"></a>2.2.4 int A[nSize]，其中隐藏着若干0，其余非0整数，写一个函数int Func(int* A, int nSize)，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。</h5><h5 id="2-2-5-写一个程序-要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数"><a href="#2-2-5-写一个程序-要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数" class="headerlink" title="2.2.5 写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数"></a>2.2.5 写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数</h5><h5 id="2-2-6-实现一个函数，把一个字符串中的字符从小写转为大写"><a href="#2-2-6-实现一个函数，把一个字符串中的字符从小写转为大写" class="headerlink" title="2.2.6 实现一个函数，把一个字符串中的字符从小写转为大写"></a>2.2.6 实现一个函数，把一个字符串中的字符从小写转为大写</h5><h5 id="2-2-7-随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数"><a href="#2-2-7-随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数" class="headerlink" title="2.2.7 随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数"></a>2.2.7 随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数</h5><h5 id="2-2-8-求2-2000的所有素数-有足够的内存-要求尽量快"><a href="#2-2-8-求2-2000的所有素数-有足够的内存-要求尽量快" class="headerlink" title="2.2.8 求2~2000的所有素数.有足够的内存,要求尽量快"></a>2.2.8 求2~2000的所有素数.有足够的内存,要求尽量快</h5><h5 id="2-2-9-A-B-C-D四个进程，A向buf里面写数据，B-C-D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。"><a href="#2-2-9-A-B-C-D四个进程，A向buf里面写数据，B-C-D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。" class="headerlink" title="2.2.9 A,B,C,D四个进程，A向buf里面写数据，B,C,D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。"></a>2.2.9 A,B,C,D四个进程，A向buf里面写数据，B,C,D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。</h5><h5 id="2-3-0-将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。"><a href="#2-3-0-将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。" class="headerlink" title="2.3.0 将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。"></a>2.3.0 将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。</h5><h5 id="2-3-1-将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。"><a href="#2-3-1-将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。" class="headerlink" title="2.3.1 将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。"></a>2.3.1 将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。</h5><h5 id="2-3-2-以下属于物理层的设备是？"><a href="#2-3-2-以下属于物理层的设备是？" class="headerlink" title="2.3.2 以下属于物理层的设备是？"></a>2.3.2 以下属于物理层的设备是？</h5><h5 id="2-3-3-在以太网中，是根据（）地址来区分不同的设备的？"><a href="#2-3-3-在以太网中，是根据（）地址来区分不同的设备的？" class="headerlink" title="2.3.3 在以太网中，是根据（）地址来区分不同的设备的？"></a>2.3.3 在以太网中，是根据（）地址来区分不同的设备的？</h5><h5 id="2-3-4-以下为传输层协议的是？"><a href="#2-3-4-以下为传输层协议的是？" class="headerlink" title="2.3.4 以下为传输层协议的是？"></a>2.3.4 以下为传输层协议的是？</h5><h5 id="2-3-5-以下对MAC地址描述正确的是？"><a href="#2-3-5-以下对MAC地址描述正确的是？" class="headerlink" title="2.3.5 以下对MAC地址描述正确的是？"></a>2.3.5 以下对MAC地址描述正确的是？</h5><h5 id="2-3-6-以下属于数据链路层功能的是？"><a href="#2-3-6-以下属于数据链路层功能的是？" class="headerlink" title="2.3.6 以下属于数据链路层功能的是？"></a>2.3.6 以下属于数据链路层功能的是？</h5><h5 id="2-3-7-IEEE802-3u标准是指？"><a href="#2-3-7-IEEE802-3u标准是指？" class="headerlink" title="2.3.7 IEEE802.3u标准是指？"></a>2.3.7 IEEE802.3u标准是指？</h5><h5 id="2-3-8-如果要将两计算机通过双绞线直接连接，正确的线序是？"><a href="#2-3-8-如果要将两计算机通过双绞线直接连接，正确的线序是？" class="headerlink" title="2.3.8 如果要将两计算机通过双绞线直接连接，正确的线序是？"></a>2.3.8 如果要将两计算机通过双绞线直接连接，正确的线序是？</h5><h5 id="2-3-9-在V-35和V-24规程中，控制信号RTS表示？"><a href="#2-3-9-在V-35和V-24规程中，控制信号RTS表示？" class="headerlink" title="2.3.9 在V.35和V.24规程中，控制信号RTS表示？"></a>2.3.9 在V.35和V.24规程中，控制信号RTS表示？</h5><h5 id="2-4-0-路由器作为网络互连设备，必须具备以下哪些特点？"><a href="#2-4-0-路由器作为网络互连设备，必须具备以下哪些特点？" class="headerlink" title="2.4.0 路由器作为网络互连设备，必须具备以下哪些特点？"></a>2.4.0 路由器作为网络互连设备，必须具备以下哪些特点？</h5><h5 id="2-4-1-路由器的作用有？"><a href="#2-4-1-路由器的作用有？" class="headerlink" title="2.4.1 路由器的作用有？"></a>2.4.1 路由器的作用有？</h5><h5 id="2-4-2-调用上一条历史命令的快捷键是？"><a href="#2-4-2-调用上一条历史命令的快捷键是？" class="headerlink" title="2.4.2 调用上一条历史命令的快捷键是？"></a>2.4.2 调用上一条历史命令的快捷键是？</h5><h5 id="2-4-3-交换机工作在OSI七层的哪一层？"><a href="#2-4-3-交换机工作在OSI七层的哪一层？" class="headerlink" title="2.4.3 交换机工作在OSI七层的哪一层？"></a>2.4.3 交换机工作在OSI七层的哪一层？</h5><h5 id="2-4-4-以下对CSMA-CD描述正确的是？"><a href="#2-4-4-以下对CSMA-CD描述正确的是？" class="headerlink" title="2.4.4 以下对CSMA/CD描述正确的是？"></a>2.4.4 以下对CSMA/CD描述正确的是？</h5><h5 id="2-4-5-以下对STORE-ANDFORWARD描述正确的是？"><a href="#2-4-5-以下对STORE-ANDFORWARD描述正确的是？" class="headerlink" title="2.4.5 以下对STORE ANDFORWARD描述正确的是？"></a>2.4.5 以下对STORE ANDFORWARD描述正确的是？</h5><h5 id="2-4-6-以下对交换机工作方式描述正确的是？"><a href="#2-4-6-以下对交换机工作方式描述正确的是？" class="headerlink" title="2.4.6 以下对交换机工作方式描述正确的是？"></a>2.4.6 以下对交换机工作方式描述正确的是？</h5><h5 id="2-4-7-VLAN的主要作用有？"><a href="#2-4-7-VLAN的主要作用有？" class="headerlink" title="2.4.7 VLAN的主要作用有？"></a>2.4.7 VLAN的主要作用有？</h5><h5 id="2-4-8-在交换机中用户权限分为几个级别？"><a href="#2-4-8-在交换机中用户权限分为几个级别？" class="headerlink" title="2.4.8 在交换机中用户权限分为几个级别？"></a>2.4.8 在交换机中用户权限分为几个级别？</h5><h5 id="2-4-9-在路由器的配置过程中查询以S开头所有命令的方法是？"><a href="#2-4-9-在路由器的配置过程中查询以S开头所有命令的方法是？" class="headerlink" title="2.4.9 在路由器的配置过程中查询以S开头所有命令的方法是？"></a>2.4.9 在路由器的配置过程中查询以S开头所有命令的方法是？</h5><h5 id="2-5-0-第一次配置路由器时可以使用的方法为？"><a href="#2-5-0-第一次配置路由器时可以使用的方法为？" class="headerlink" title="2.5.0 第一次配置路由器时可以使用的方法为？"></a>2.5.0 第一次配置路由器时可以使用的方法为？</h5><h5 id="2-5-1-在何种状态下可以为路由器改名？"><a href="#2-5-1-在何种状态下可以为路由器改名？" class="headerlink" title="2.5.1 在何种状态下可以为路由器改名？"></a>2.5.1 在何种状态下可以为路由器改名？</h5><h5 id="2-5-2-某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有-26台计算机，每个子公司在一个网段中，则子网掩码应设为？"><a href="#2-5-2-某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有-26台计算机，每个子公司在一个网段中，则子网掩码应设为？" class="headerlink" title="2.5.2 某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？"></a>2.5.2 某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？</h5><h5 id="2-5-3-与10-110-12-29mask-255-255-255-224属于同一网段的主机IP地址是？"><a href="#2-5-3-与10-110-12-29mask-255-255-255-224属于同一网段的主机IP地址是？" class="headerlink" title="2.5.3 与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址是？"></a>2.5.3 与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址是？</h5><h5 id="2-5-4-ARP协议的作用是？"><a href="#2-5-4-ARP协议的作用是？" class="headerlink" title="2.5.4 ARP协议的作用是？"></a>2.5.4 ARP协议的作用是？</h5><h5 id="2-5-5-当路由器接收的IP报文的TTL值等于1时，采取的策略是？"><a href="#2-5-5-当路由器接收的IP报文的TTL值等于1时，采取的策略是？" class="headerlink" title="2.5.5 当路由器接收的IP报文的TTL值等于1时，采取的策略是？"></a>2.5.5 当路由器接收的IP报文的TTL值等于1时，采取的策略是？</h5><h5 id="2-5-6-在NetWare-网络中，客户需要访问某个类型的服务器时，首先要发送一个-（）广播报文来寻找服务器？"><a href="#2-5-6-在NetWare-网络中，客户需要访问某个类型的服务器时，首先要发送一个-（）广播报文来寻找服务器？" class="headerlink" title="2.5.6 在NetWare 网络中，客户需要访问某个类型的服务器时，首先要发送一个 （）广播报文来寻找服务器？"></a>2.5.6 在NetWare 网络中，客户需要访问某个类型的服务器时，首先要发送一个 （）广播报文来寻找服务器？</h5><h5 id="2-5-7-IPX地址网络地址有（-）个字节？"><a href="#2-5-7-IPX地址网络地址有（-）个字节？" class="headerlink" title="2.5.7 IPX地址网络地址有（ ）个字节？"></a>2.5.7 IPX地址网络地址有（ ）个字节？</h5><h5 id="2-5-8-对于帧中继描述正确的是？"><a href="#2-5-8-对于帧中继描述正确的是？" class="headerlink" title="2.5.8 对于帧中继描述正确的是？"></a>2.5.8 对于帧中继描述正确的是？</h5><h5 id="2-5-9-对于INVERSE-ARP的描述正确的是？"><a href="#2-5-9-对于INVERSE-ARP的描述正确的是？" class="headerlink" title="2.5.9 对于INVERSE ARP的描述正确的是？"></a>2.5.9 对于INVERSE ARP的描述正确的是？</h5><br>

<h3 id="3">百度篇</h3> 
---

<h5 id="3-1-0-在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？"><a href="#3-1-0-在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？" class="headerlink" title="3.1.0 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？"></a>3.1.0 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？</h5><h5 id="3-1-1-C-中引用与指针的区别"><a href="#3-1-1-C-中引用与指针的区别" class="headerlink" title="3.1.1 C++中引用与指针的区别"></a>3.1.1 C++中引用与指针的区别</h5><h5 id="3-1-2-C-C-程序的内存分区"><a href="#3-1-2-C-C-程序的内存分区" class="headerlink" title="3.1.2 C/C++程序的内存分区"></a>3.1.2 C/C++程序的内存分区</h5><h5 id="3-1-3-快速排序的思想、时间复杂度、实现以及优化方法"><a href="#3-1-3-快速排序的思想、时间复杂度、实现以及优化方法" class="headerlink" title="3.1.3 快速排序的思想、时间复杂度、实现以及优化方法"></a>3.1.3 快速排序的思想、时间复杂度、实现以及优化方法</h5><h5 id="3-1-4-IO模型——IO多路复用机制"><a href="#3-1-4-IO模型——IO多路复用机制" class="headerlink" title="3.1.4 IO模型——IO多路复用机制?"></a>3.1.4 IO模型——IO多路复用机制?</h5><h5 id="3-1-5-常用的Linux命令"><a href="#3-1-5-常用的Linux命令" class="headerlink" title="3.1.5 常用的Linux命令"></a>3.1.5 常用的Linux命令</h5><h5 id="3-1-6-C中变量的存储类型有哪些？"><a href="#3-1-6-C中变量的存储类型有哪些？" class="headerlink" title="3.1.6 C中变量的存储类型有哪些？"></a>3.1.6 C中变量的存储类型有哪些？</h5><h5 id="3-1-7-动态规划的本质"><a href="#3-1-7-动态规划的本质" class="headerlink" title="3.1.7 动态规划的本质"></a>3.1.7 动态规划的本质</h5><h5 id="3-1-8-实践中如何优化MySQL"><a href="#3-1-8-实践中如何优化MySQL" class="headerlink" title="3.1.8 实践中如何优化MySQL?"></a>3.1.8 实践中如何优化MySQL?</h5><h5 id="3-1-9-什么情况下设置了索引但无法使用"><a href="#3-1-9-什么情况下设置了索引但无法使用" class="headerlink" title="3.1.9 什么情况下设置了索引但无法使用?"></a>3.1.9 什么情况下设置了索引但无法使用?</h5><h5 id="3-2-0-SQL语句的优化"><a href="#3-2-0-SQL语句的优化" class="headerlink" title="3.2.0 SQL语句的优化"></a>3.2.0 SQL语句的优化</h5><h5 id="3-2-1-数据库索引的底层实现原理和优化"><a href="#3-2-1-数据库索引的底层实现原理和优化" class="headerlink" title="3.2.1 数据库索引的底层实现原理和优化"></a>3.2.1 数据库索引的底层实现原理和优化</h5><h5 id="3-2-2-HTTP和HTTPS的主要区别"><a href="#3-2-2-HTTP和HTTPS的主要区别" class="headerlink" title="3.2.2 HTTP和HTTPS的主要区别?"></a>3.2.2 HTTP和HTTPS的主要区别?</h5><h5 id="3-2-3-如何设计一个高并发的系统"><a href="#3-2-3-如何设计一个高并发的系统" class="headerlink" title="3.2.3 如何设计一个高并发的系统?"></a>3.2.3 如何设计一个高并发的系统?</h5><h5 id="3-2-4-两条相交的单向链表，如何求他们的第一个公共节点"><a href="#3-2-4-两条相交的单向链表，如何求他们的第一个公共节点" class="headerlink" title="3.2.4 两条相交的单向链表，如何求他们的第一个公共节点?"></a>3.2.4 两条相交的单向链表，如何求他们的第一个公共节点?</h5><h5 id="3-2-5-求单向局部循环链表的环入口"><a href="#3-2-5-求单向局部循环链表的环入口" class="headerlink" title="3.2.5 求单向局部循环链表的环入口?"></a>3.2.5 求单向局部循环链表的环入口?</h5><h5 id="3-2-6-IP地址如何在数据库中存储"><a href="#3-2-6-IP地址如何在数据库中存储" class="headerlink" title="3.2.6 IP地址如何在数据库中存储?"></a>3.2.6 IP地址如何在数据库中存储?</h5><h5 id="3-2-7-new-delete和malloc-free的底层实现"><a href="#3-2-7-new-delete和malloc-free的底层实现" class="headerlink" title="3.2.7 new/delete和malloc/free的底层实现?"></a>3.2.7 new/delete和malloc/free的底层实现?</h5><h5 id="3-2-8-overload、override、overwrite的介绍"><a href="#3-2-8-overload、override、overwrite的介绍" class="headerlink" title="3.2.8 overload、override、overwrite的介绍?"></a>3.2.8 overload、override、overwrite的介绍?</h5><h5 id="3-2-9-小端-大端机器"><a href="#3-2-9-小端-大端机器" class="headerlink" title="3.2.9 小端/大端机器?"></a>3.2.9 小端/大端机器?</h5><h5 id="3-3-0-守护进程"><a href="#3-3-0-守护进程" class="headerlink" title="3.3.0 守护进程"></a>3.3.0 守护进程</h5><h5 id="3-3-1-多线程的优缺点"><a href="#3-3-1-多线程的优缺点" class="headerlink" title="3.3.1 多线程的优缺点"></a>3.3.1 多线程的优缺点</h5><h5 id="3-3-2-长连接与短连接"><a href="#3-3-2-长连接与短连接" class="headerlink" title="3.3.2 长连接与短连接"></a>3.3.2 长连接与短连接</h5><h5 id="3-3-3-二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）"><a href="#3-3-3-二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）" class="headerlink" title="3.3.3 二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）"></a>3.3.3 二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）</h5><h5 id="3-3-4-class与struct的区别？"><a href="#3-3-4-class与struct的区别？" class="headerlink" title="3.3.4 class与struct的区别？"></a>3.3.4 class与struct的区别？</h5><h5 id="3-3-5-虚函数和纯虚函数"><a href="#3-3-5-虚函数和纯虚函数" class="headerlink" title="3.3.5 虚函数和纯虚函数"></a>3.3.5 虚函数和纯虚函数</h5><h5 id="3-3-6-menset-函数"><a href="#3-3-6-menset-函数" class="headerlink" title="3.3.6 menset()函数"></a>3.3.6 menset()函数</h5><h5 id="3-3-7-实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。"><a href="#3-3-7-实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。" class="headerlink" title="3.3.7 实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。"></a>3.3.7 实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。</h5><h5 id="3-3-8-找到满足条件的数组"><a href="#3-3-8-找到满足条件的数组" class="headerlink" title="3.3.8 找到满足条件的数组"></a>3.3.8 找到满足条件的数组</h5><h5 id="3-3-9-一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL"><a href="#3-3-9-一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL" class="headerlink" title="3.3.9 一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL"></a>3.3.9 一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL</h5><h5 id="3-4-0-海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#3-4-0-海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="3.4.0 海量日志数据，提取出某日访问百度次数最多的那个IP"></a>3.4.0 海量日志数据，提取出某日访问百度次数最多的那个IP</h5><h5 id="3-4-1-有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？"><a href="#3-4-1-有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？" class="headerlink" title="3.4.1 有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？"></a>3.4.1 有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？</h5><h5 id="3-4-2-蚂蚁爬杆问题"><a href="#3-4-2-蚂蚁爬杆问题" class="headerlink" title="3.4.2 蚂蚁爬杆问题"></a>3.4.2 蚂蚁爬杆问题</h5><h5 id="3-4-3-当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？"><a href="#3-4-3-当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？" class="headerlink" title="3.4.3 当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？"></a>3.4.3 当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？</h5><h5 id="3-4-4-判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度"><a href="#3-4-4-判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度" class="headerlink" title="3.4.4 判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度"></a>3.4.4 判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度</h5><h5 id="3-4-5-三个警察和三个囚徒的过河问题"><a href="#3-4-5-三个警察和三个囚徒的过河问题" class="headerlink" title="3.4.5 三个警察和三个囚徒的过河问题"></a>3.4.5 三个警察和三个囚徒的过河问题</h5><h5 id="3-4-6-从300万字符串中找到最热门的10条"><a href="#3-4-6-从300万字符串中找到最热门的10条" class="headerlink" title="3.4.6 从300万字符串中找到最热门的10条"></a>3.4.6 从300万字符串中找到最热门的10条</h5><h5 id="3-4-7-如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？"><a href="#3-4-7-如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？" class="headerlink" title="3.4.7 如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？"></a>3.4.7 如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？</h5><h5 id="3-4-8-找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O-n-的复杂度的算法找出这个数。"><a href="#3-4-8-找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O-n-的复杂度的算法找出这个数。" class="headerlink" title="3.4.8 找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"></a>3.4.8 找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。</h5><h5 id="3-4-9-找出被修改过的数字"><a href="#3-4-9-找出被修改过的数字" class="headerlink" title="3.4.9 找出被修改过的数字"></a>3.4.9 找出被修改过的数字</h5><h5 id="3-5-0-设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）"><a href="#3-5-0-设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）" class="headerlink" title="3.5.0 设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）"></a>3.5.0 设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）</h5><h5 id="3-5-1-找出给定字符串对应的序号"><a href="#3-5-1-找出给定字符串对应的序号" class="headerlink" title="3.5.1 找出给定字符串对应的序号"></a>3.5.1 找出给定字符串对应的序号</h5><h5 id="3-5-2-找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如-2，4，3，4，7-中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。"><a href="#3-5-2-找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如-2，4，3，4，7-中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。" class="headerlink" title="3.5.2 找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。"></a>3.5.2 找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。</h5><h5 id="3-5-3-给40亿个不重复的unsigned-int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中"><a href="#3-5-3-给40亿个不重复的unsigned-int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中" class="headerlink" title="3.5.3 给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?"></a>3.5.3 给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?</h5><h5 id="3-5-4-在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。"><a href="#3-5-4-在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。" class="headerlink" title="3.5.4 在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。"></a>3.5.4 在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。</h5><h5 id="3-5-5-时分秒针在一天之类重合多少次？（24小时）"><a href="#3-5-5-时分秒针在一天之类重合多少次？（24小时）" class="headerlink" title="3.5.5 时分秒针在一天之类重合多少次？（24小时）"></a>3.5.5 时分秒针在一天之类重合多少次？（24小时）</h5><h5 id="3-5-6-将多个集合合并成没有交集的集合。"><a href="#3-5-6-将多个集合合并成没有交集的集合。" class="headerlink" title="3.5.6 将多个集合合并成没有交集的集合。"></a>3.5.6 将多个集合合并成没有交集的集合。</h5><h5 id="3-5-7-平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？"><a href="#3-5-7-平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？" class="headerlink" title="3.5.7 平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？"></a>3.5.7 平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？</h5><br>

<h3 id="4">腾讯篇</h3>
---

<h4 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h4><h5 id="4-1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。"><a href="#4-1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。" class="headerlink" title="4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。"></a>4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。</h5><h5 id="4-1-1-String类能被继承吗，为什么。"><a href="#4-1-1-String类能被继承吗，为什么。" class="headerlink" title="4.1.1 String类能被继承吗，为什么。"></a>4.1.1 String类能被继承吗，为什么。</h5><h5 id="4-1-2-String，Stringbuffer，StringBuilder的区别。"><a href="#4-1-2-String，Stringbuffer，StringBuilder的区别。" class="headerlink" title="4.1.2 String，Stringbuffer，StringBuilder的区别。"></a>4.1.2 String，Stringbuffer，StringBuilder的区别。</h5><h5 id="4-1-3-ArrayList和LinkedList有什么区别。"><a href="#4-1-3-ArrayList和LinkedList有什么区别。" class="headerlink" title="4.1.3 ArrayList和LinkedList有什么区别。"></a>4.1.3 ArrayList和LinkedList有什么区别。</h5><h5 id="4-1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#4-1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h5><h5 id="4-1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><a href="#4-1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。" class="headerlink" title="4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"></a>4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h5><h5 id="4-1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#4-1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h5><h5 id="4-1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><a href="#4-1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"></a>4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</h5><h5 id="4-1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#4-1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h5><h5 id="4-1-9-继承和聚合的区别在哪。"><a href="#4-1-9-继承和聚合的区别在哪。" class="headerlink" title="4.1.9 继承和聚合的区别在哪。"></a>4.1.9 继承和聚合的区别在哪。</h5><h5 id="4-2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。"><a href="#4-2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。" class="headerlink" title="4.2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。"></a>4.2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</h5><h5 id="4-2-1-反射的原理，反射创建类实例的三种方式是什么。"><a href="#4-2-1-反射的原理，反射创建类实例的三种方式是什么。" class="headerlink" title="4.2.1 反射的原理，反射创建类实例的三种方式是什么。"></a>4.2.1 反射的原理，反射创建类实例的三种方式是什么。</h5><h5 id="4-2-2-反射中，Class-forName和ClassLoader区别-。"><a href="#4-2-2-反射中，Class-forName和ClassLoader区别-。" class="headerlink" title="4.2.2 反射中，Class.forName和ClassLoader区别 。"></a>4.2.2 反射中，Class.forName和ClassLoader区别 。</h5><h5 id="4-2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#4-2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。</h5><h5 id="4-2-4-动态代理与cglib实现的区别。"><a href="#4-2-4-动态代理与cglib实现的区别。" class="headerlink" title="4.2.4 动态代理与cglib实现的区别。"></a>4.2.4 动态代理与cglib实现的区别。</h5><h5 id="4-2-5-为什么CGlib方式可以对接口实现代理。"><a href="#4-2-5-为什么CGlib方式可以对接口实现代理。" class="headerlink" title="4.2.5 为什么CGlib方式可以对接口实现代理。"></a>4.2.5 为什么CGlib方式可以对接口实现代理。</h5><h5 id="4-2-6-final的用途。"><a href="#4-2-6-final的用途。" class="headerlink" title="4.2.6 final的用途。"></a>4.2.6 final的用途。</h5><h5 id="4-2-7-写出三种单例模式实现-。"><a href="#4-2-7-写出三种单例模式实现-。" class="headerlink" title="4.2.7 写出三种单例模式实现 。"></a>4.2.7 写出三种单例模式实现 。</h5><h5 id="4-2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><a href="#4-2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。" class="headerlink" title="4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"></a>4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h5><h5 id="4-2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><a href="#4-2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。" class="headerlink" title="4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"></a>4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h5><h5 id="4-3-0-深拷贝和浅拷贝区别。"><a href="#4-3-0-深拷贝和浅拷贝区别。" class="headerlink" title="4.3.0 深拷贝和浅拷贝区别。"></a>4.3.0 深拷贝和浅拷贝区别。</h5><h5 id="4-3-1-数组和链表数据结构描述，各自的时间复杂度。"><a href="#4-3-1-数组和链表数据结构描述，各自的时间复杂度。" class="headerlink" title="4.3.1 数组和链表数据结构描述，各自的时间复杂度。"></a>4.3.1 数组和链表数据结构描述，各自的时间复杂度。</h5><h5 id="4-3-2-error和exception的区别，CheckedException，RuntimeException的区别。"><a href="#4-3-2-error和exception的区别，CheckedException，RuntimeException的区别。" class="headerlink" title="4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。"></a>4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。</h5><h5 id="4-3-3-请列出5个运行时异常。"><a href="#4-3-3-请列出5个运行时异常。" class="headerlink" title="4.3.3 请列出5个运行时异常。"></a>4.3.3 请列出5个运行时异常。</h5><h5 id="4-3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#4-3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h5><h5 id="4-3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#4-3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"></a>4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</h5><h5 id="4-3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#4-3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h5><h5 id="4-3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。"><a href="#4-3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。" class="headerlink" title="4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。"></a>4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</h5><h5 id="4-3-8-有没有可能2个不相等的对象有相同的hashcode。"><a href="#4-3-8-有没有可能2个不相等的对象有相同的hashcode。" class="headerlink" title="4.3.8 有没有可能2个不相等的对象有相同的hashcode。"></a>4.3.8 有没有可能2个不相等的对象有相同的hashcode。</h5><h5 id="4-3-9-Java中的HashSet内部是如何工作的。"><a href="#4-3-9-Java中的HashSet内部是如何工作的。" class="headerlink" title="4.3.9 Java中的HashSet内部是如何工作的。"></a>4.3.9 Java中的HashSet内部是如何工作的。</h5><h5 id="4-4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><a href="#4-4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。" class="headerlink" title="4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"></a>4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h5><h5 id="4-4-1-java8的新特性。"><a href="#4-4-1-java8的新特性。" class="headerlink" title="4.4.1 java8的新特性。"></a>4.4.1 java8的新特性。</h5><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h5 id="4-4-2-什么情况下会发生栈内存溢出。"><a href="#4-4-2-什么情况下会发生栈内存溢出。" class="headerlink" title="4.4.2 什么情况下会发生栈内存溢出。"></a>4.4.2 什么情况下会发生栈内存溢出。</h5><h5 id="4-4-3-JVM的内存结构，Eden和Survivor比例。"><a href="#4-4-3-JVM的内存结构，Eden和Survivor比例。" class="headerlink" title="4.4.3 JVM的内存结构，Eden和Survivor比例。"></a>4.4.3 JVM的内存结构，Eden和Survivor比例。</h5><h5 id="4-4-4-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#4-4-4-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h5><h5 id="4-4-5-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><a href="#4-4-5-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。" class="headerlink" title="4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"></a>4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</h5><h5 id="4-4-6-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#4-4-6-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h5><h5 id="4-4-7-垃圾回收算法的实现原理。"><a href="#4-4-7-垃圾回收算法的实现原理。" class="headerlink" title="4.4.7 垃圾回收算法的实现原理。"></a>4.4.7 垃圾回收算法的实现原理。</h5><h5 id="4-4-8-当出现了内存溢出，你怎么排错。"><a href="#4-4-8-当出现了内存溢出，你怎么排错。" class="headerlink" title="4.4.8 当出现了内存溢出，你怎么排错。"></a>4.4.8 当出现了内存溢出，你怎么排错。</h5><h5 id="4-4-9-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><a href="#4-4-9-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。" class="headerlink" title="4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"></a>4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h5><h5 id="4-5-0-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#4-5-0-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h5><h5 id="4-5-1-讲讲JAVA的反射机制。"><a href="#4-5-1-讲讲JAVA的反射机制。" class="headerlink" title="4.5.1 讲讲JAVA的反射机制。"></a>4.5.1 讲讲JAVA的反射机制。</h5><h5 id="4-5-2-你们线上应用的JVM参数有哪些。"><a href="#4-5-2-你们线上应用的JVM参数有哪些。" class="headerlink" title="4.5.2 你们线上应用的JVM参数有哪些。"></a>4.5.2 你们线上应用的JVM参数有哪些。</h5><h5 id="4-5-3-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。"><a href="#4-5-3-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。" class="headerlink" title="4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。"></a>4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</h5><h5 id="4-5-4-怎么打出线程栈信息。"><a href="#4-5-4-怎么打出线程栈信息。" class="headerlink" title="4.5.4 怎么打出线程栈信息。"></a>4.5.4 怎么打出线程栈信息。</h5><h4 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h4><h5 id="4-5-5-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"><a href="#4-5-5-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。" class="headerlink" title="4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"></a>4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。</h5><h5 id="4-5-6-tomcat如何调优，涉及哪些参数-。"><a href="#4-5-6-tomcat如何调优，涉及哪些参数-。" class="headerlink" title="4.5.6 tomcat如何调优，涉及哪些参数 。"></a>4.5.6 tomcat如何调优，涉及哪些参数 。</h5><h5 id="4-5-7-讲讲Spring加载流程。"><a href="#4-5-7-讲讲Spring加载流程。" class="headerlink" title="4.5.7 讲讲Spring加载流程。"></a>4.5.7 讲讲Spring加载流程。</h5><h5 id="4-5-8-Spring-AOP的实现原理。"><a href="#4-5-8-Spring-AOP的实现原理。" class="headerlink" title="4.5.8 Spring AOP的实现原理。"></a>4.5.8 Spring AOP的实现原理。</h5><h5 id="4-5-9-讲讲Spring事务的传播属性。"><a href="#4-5-9-讲讲Spring事务的传播属性。" class="headerlink" title="4.5.9 讲讲Spring事务的传播属性。"></a>4.5.9 讲讲Spring事务的传播属性。</h5><h5 id="4-6-0-Spring如何管理事务的。"><a href="#4-6-0-Spring如何管理事务的。" class="headerlink" title="4.6.0 Spring如何管理事务的。"></a>4.6.0 Spring如何管理事务的。</h5><h5 id="4-6-1-Spring怎么配置事务（具体说出一些关键的xml-元素）。"><a href="#4-6-1-Spring怎么配置事务（具体说出一些关键的xml-元素）。" class="headerlink" title="4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。"></a>4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。</h5><h5 id="4-6-2-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。"><a href="#4-6-2-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。" class="headerlink" title="4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。"></a>4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。</h5><h5 id="4-6-3-Springmvc-中DispatcherServlet初始化过程。"><a href="#4-6-3-Springmvc-中DispatcherServlet初始化过程。" class="headerlink" title="4.6.3 Springmvc 中DispatcherServlet初始化过程。"></a>4.6.3 Springmvc 中DispatcherServlet初始化过程。</h5><h5 id="4-6-4-netty的线程模型，netty如何基于reactor模型上实现的。"><a href="#4-6-4-netty的线程模型，netty如何基于reactor模型上实现的。" class="headerlink" title="4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。"></a>4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。</h5><h5 id="4-6-5-为什么选择netty。"><a href="#4-6-5-为什么选择netty。" class="headerlink" title="4.6.5 为什么选择netty。"></a>4.6.5 为什么选择netty。</h5><h5 id="4-6-6-什么是TCP粘包，拆包。解决方式是什么。"><a href="#4-6-6-什么是TCP粘包，拆包。解决方式是什么。" class="headerlink" title="4.6.6 什么是TCP粘包，拆包。解决方式是什么。"></a>4.6.6 什么是TCP粘包，拆包。解决方式是什么。</h5><h5 id="4-6-7-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"><a href="#4-6-7-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。" class="headerlink" title="4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"></a>4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。</h5><h5 id="4-6-8-netty的心跳处理在弱网下怎么办。"><a href="#4-6-8-netty的心跳处理在弱网下怎么办。" class="headerlink" title="4.6.8 netty的心跳处理在弱网下怎么办。"></a>4.6.8 netty的心跳处理在弱网下怎么办。</h5><h5 id="4-6-9-netty的通讯协议是什么样的。"><a href="#4-6-9-netty的通讯协议是什么样的。" class="headerlink" title="4.6.9 netty的通讯协议是什么样的。"></a>4.6.9 netty的通讯协议是什么样的。</h5><h5 id="4-7-0-springmvc用到的注解，作用是什么，原理。"><a href="#4-7-0-springmvc用到的注解，作用是什么，原理。" class="headerlink" title="4.7.0 springmvc用到的注解，作用是什么，原理。"></a>4.7.0 springmvc用到的注解，作用是什么，原理。</h5><h5 id="4-7-1-springboot启动机制。"><a href="#4-7-1-springboot启动机制。" class="headerlink" title="4.7.1 springboot启动机制。"></a>4.7.1 springboot启动机制。</h5><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="4-7-2-Linux系统下你关注过哪些内核参数，说说你知道的。"><a href="#4-7-2-Linux系统下你关注过哪些内核参数，说说你知道的。" class="headerlink" title="4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。"></a>4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。</h5><h5 id="4-7-3-Linux下IO模型有几种，各自的含义是什么。"><a href="#4-7-3-Linux下IO模型有几种，各自的含义是什么。" class="headerlink" title="4.7.3 Linux下IO模型有几种，各自的含义是什么。"></a>4.7.3 Linux下IO模型有几种，各自的含义是什么。</h5><h5 id="4-7-4-epoll和poll有什么区别。"><a href="#4-7-4-epoll和poll有什么区别。" class="headerlink" title="4.7.4 epoll和poll有什么区别。"></a>4.7.4 epoll和poll有什么区别。</h5><h5 id="4-7-5-平时用到哪些Linux命令。"><a href="#4-7-5-平时用到哪些Linux命令。" class="headerlink" title="4.7.5 平时用到哪些Linux命令。"></a>4.7.5 平时用到哪些Linux命令。</h5><h5 id="4-7-6-用一行命令查看文件的最后五行。"><a href="#4-7-6-用一行命令查看文件的最后五行。" class="headerlink" title="4.7.6 用一行命令查看文件的最后五行。"></a>4.7.6 用一行命令查看文件的最后五行。</h5><h5 id="4-7-7-用一行命令输出正在运行的java进程。"><a href="#4-7-7-用一行命令输出正在运行的java进程。" class="headerlink" title="4.7.7 用一行命令输出正在运行的java进程。"></a>4.7.7 用一行命令输出正在运行的java进程。</h5><h5 id="4-7-8-介绍下你理解的操作系统中线程切换过程。"><a href="#4-7-8-介绍下你理解的操作系统中线程切换过程。" class="headerlink" title="4.7.8 介绍下你理解的操作系统中线程切换过程。"></a>4.7.8 介绍下你理解的操作系统中线程切换过程。</h5><h5 id="4-7-9-进程和线程的区别。"><a href="#4-7-9-进程和线程的区别。" class="headerlink" title="4.7.9 进程和线程的区别。"></a>4.7.9 进程和线程的区别。</h5><h5 id="4-8-0-top-命令之后有哪些内容，有什么作用。"><a href="#4-8-0-top-命令之后有哪些内容，有什么作用。" class="headerlink" title="4.8.0 top 命令之后有哪些内容，有什么作用。"></a>4.8.0 top 命令之后有哪些内容，有什么作用。</h5><h5 id="4-8-1-线上CPU爆高，请问你如何找到问题所在。"><a href="#4-8-1-线上CPU爆高，请问你如何找到问题所在。" class="headerlink" title="4.8.1 线上CPU爆高，请问你如何找到问题所在。"></a>4.8.1 线上CPU爆高，请问你如何找到问题所在。</h5><br>

<h3 id="5">美团篇</h3>
---

<h5 id="5-1-0-java虚拟机内存模型"><a href="#5-1-0-java虚拟机内存模型" class="headerlink" title="5.1.0 java虚拟机内存模型"></a>5.1.0 java虚拟机内存模型</h5><h5 id="5-1-1-内存溢出一般发生在哪个区？永久代会不会导致内存溢出？"><a href="#5-1-1-内存溢出一般发生在哪个区？永久代会不会导致内存溢出？" class="headerlink" title="5.1.1 内存溢出一般发生在哪个区？永久代会不会导致内存溢出？"></a>5.1.1 内存溢出一般发生在哪个区？永久代会不会导致内存溢出？</h5><h5 id="5-1-2-动态加载类的框架了解哪些？"><a href="#5-1-2-动态加载类的框架了解哪些？" class="headerlink" title="5.1.2 动态加载类的框架了解哪些？"></a>5.1.2 动态加载类的框架了解哪些？</h5><h5 id="5-1-3-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？"><a href="#5-1-3-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？" class="headerlink" title="5.1.3 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？"></a>5.1.3 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？</h5><h5 id="5-1-4-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？"><a href="#5-1-4-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？" class="headerlink" title="5.1.4 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？"></a>5.1.4 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？</h5><h5 id="5-1-5-用过哪些命令查看jvm的状态、堆栈信息？"><a href="#5-1-5-用过哪些命令查看jvm的状态、堆栈信息？" class="headerlink" title="5.1.5 用过哪些命令查看jvm的状态、堆栈信息？"></a>5.1.5 用过哪些命令查看jvm的状态、堆栈信息？</h5><h5 id="5-1-6-jvm的垃圾回收机制？"><a href="#5-1-6-jvm的垃圾回收机制？" class="headerlink" title="5.1.6 jvm的垃圾回收机制？"></a>5.1.6 jvm的垃圾回收机制？</h5><h5 id="5-1-7-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？"><a href="#5-1-7-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？" class="headerlink" title="5.1.7 java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？"></a>5.1.7 java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？</h5><h5 id="5-1-8-String、StringBuffer、StringBuilder的区别？对应的使用场景？"><a href="#5-1-8-String、StringBuffer、StringBuilder的区别？对应的使用场景？" class="headerlink" title="5.1.8 String、StringBuffer、StringBuilder的区别？对应的使用场景？"></a>5.1.8 String、StringBuffer、StringBuilder的区别？对应的使用场景？</h5><h5 id="5-1-9-如何实现不可变的类？"><a href="#5-1-9-如何实现不可变的类？" class="headerlink" title="5.1.9 如何实现不可变的类？"></a>5.1.9 如何实现不可变的类？</h5><h5 id="5-2-0-浅复制和深复制？怎样实现深复制？"><a href="#5-2-0-浅复制和深复制？怎样实现深复制？" class="headerlink" title="5.2.0 浅复制和深复制？怎样实现深复制？"></a>5.2.0 浅复制和深复制？怎样实现深复制？</h5><h5 id="5-2-1-HashMap、HashTable、ConcurrentHashMap的区别？"><a href="#5-2-1-HashMap、HashTable、ConcurrentHashMap的区别？" class="headerlink" title="5.2.1 HashMap、HashTable、ConcurrentHashMap的区别？"></a>5.2.1 HashMap、HashTable、ConcurrentHashMap的区别？</h5><h5 id="5-2-2-CAS是一种什么样的同步机制？"><a href="#5-2-2-CAS是一种什么样的同步机制？" class="headerlink" title="5.2.2 CAS是一种什么样的同步机制？"></a>5.2.2 CAS是一种什么样的同步机制？</h5><h5 id="5-2-3-NIO的原理，包括哪几个组件？"><a href="#5-2-3-NIO的原理，包括哪几个组件？" class="headerlink" title="5.2.3 NIO的原理，包括哪几个组件？"></a>5.2.3 NIO的原理，包括哪几个组件？</h5><h5 id="5-2-4-简单介绍一下java的反射机制？反射在哪些地方有应用场景？"><a href="#5-2-4-简单介绍一下java的反射机制？反射在哪些地方有应用场景？" class="headerlink" title="5.2.4 简单介绍一下java的反射机制？反射在哪些地方有应用场景？"></a>5.2.4 简单介绍一下java的反射机制？反射在哪些地方有应用场景？</h5><h5 id="5-2-5-spring加载bean的流程？"><a href="#5-2-5-spring加载bean的流程？" class="headerlink" title="5.2.5 spring加载bean的流程？"></a>5.2.5 spring加载bean的流程？</h5><h5 id="5-2-6-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？"><a href="#5-2-6-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？" class="headerlink" title="5.2.6 java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？"></a>5.2.6 java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？</h5><h5 id="5-2-7-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？"><a href="#5-2-7-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？" class="headerlink" title="5.2.7 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？"></a>5.2.7 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？</h5><h5 id="5-2-8-CountDownLatch和CyclicBarrier的区别？"><a href="#5-2-8-CountDownLatch和CyclicBarrier的区别？" class="headerlink" title="5.2.8 CountDownLatch和CyclicBarrier的区别？"></a>5.2.8 CountDownLatch和CyclicBarrier的区别？</h5><h5 id="5-2-9-线程加锁有哪些方式？synchronized和lock的区别？"><a href="#5-2-9-线程加锁有哪些方式？synchronized和lock的区别？" class="headerlink" title="5.2.9 线程加锁有哪些方式？synchronized和lock的区别？"></a>5.2.9 线程加锁有哪些方式？synchronized和lock的区别？</h5><h5 id="5-3-0-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？"><a href="#5-3-0-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？" class="headerlink" title="5.3.0 volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？"></a>5.3.0 volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？</h5><h5 id="5-3-1-mysql的存储引擎有哪几种？"><a href="#5-3-1-mysql的存储引擎有哪几种？" class="headerlink" title="5.3.1 mysql的存储引擎有哪几种？"></a>5.3.1 mysql的存储引擎有哪几种？</h5><h5 id="5-3-2-sql优化有哪些着手点？组合索引的最左前缀原则的含义？"><a href="#5-3-2-sql优化有哪些着手点？组合索引的最左前缀原则的含义？" class="headerlink" title="5.3.2 sql优化有哪些着手点？组合索引的最左前缀原则的含义？"></a>5.3.2 sql优化有哪些着手点？组合索引的最左前缀原则的含义？</h5><h5 id="5-3-3-springmvc处理请求的流程？"><a href="#5-3-3-springmvc处理请求的流程？" class="headerlink" title="5.3.3 springmvc处理请求的流程？"></a>5.3.3 springmvc处理请求的流程？</h5><h5 id="5-3-4-spring的事务怎么使用？事务回滚？自定义异常？"><a href="#5-3-4-spring的事务怎么使用？事务回滚？自定义异常？" class="headerlink" title="5.3.4 spring的事务怎么使用？事务回滚？自定义异常？"></a>5.3.4 spring的事务怎么使用？事务回滚？自定义异常？</h5><h5 id="5-3-5-脏读？幻读？"><a href="#5-3-5-脏读？幻读？" class="headerlink" title="5.3.5 脏读？幻读？"></a>5.3.5 脏读？幻读？</h5><h5 id="5-3-6-tcp四次挥手的过程？TIME-WAIT为什么至少设置两倍的MSL时间？"><a href="#5-3-6-tcp四次挥手的过程？TIME-WAIT为什么至少设置两倍的MSL时间？" class="headerlink" title="5.3.6 tcp四次挥手的过程？TIME_WAIT为什么至少设置两倍的MSL时间？"></a>5.3.6 tcp四次挥手的过程？TIME_WAIT为什么至少设置两倍的MSL时间？</h5><h5 id="5-3-7-get和post请求的区别？"><a href="#5-3-7-get和post请求的区别？" class="headerlink" title="5.3.7 get和post请求的区别？"></a>5.3.7 get和post请求的区别？</h5><h5 id="5-3-8-cookie和session的请求？"><a href="#5-3-8-cookie和session的请求？" class="headerlink" title="5.3.8 cookie和session的请求？"></a>5.3.8 cookie和session的请求？</h5><h5 id="5-3-9-了解哪些开源的中间件？缓存？消息？分布式框架？"><a href="#5-3-9-了解哪些开源的中间件？缓存？消息？分布式框架？" class="headerlink" title="5.3.9 了解哪些开源的中间件？缓存？消息？分布式框架？"></a>5.3.9 了解哪些开源的中间件？缓存？消息？分布式框架？</h5><h5 id="5-4-0-用到过哪些设计模式？单例模式的实现？"><a href="#5-4-0-用到过哪些设计模式？单例模式的实现？" class="headerlink" title="5.4.0 用到过哪些设计模式？单例模式的实现？"></a>5.4.0 用到过哪些设计模式？单例模式的实现？</h5><h5 id="5-4-1-数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题"><a href="#5-4-1-数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题" class="headerlink" title="5.4.1 数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题"></a>5.4.1 数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题</h5><h5 id="5-4-2-数据库的脏读，幻读，不可重复读出现的原因原理，解决办法"><a href="#5-4-2-数据库的脏读，幻读，不可重复读出现的原因原理，解决办法" class="headerlink" title="5.4.2 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法"></a>5.4.2 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法</h5><h5 id="5-4-3-数据库的隔离级别、MVCC"><a href="#5-4-3-数据库的隔离级别、MVCC" class="headerlink" title="5.4.3 数据库的隔离级别、MVCC"></a>5.4.3 数据库的隔离级别、MVCC</h5><h5 id="5-4-4-乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别"><a href="#5-4-4-乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别" class="headerlink" title="5.4.4 乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别"></a>5.4.4 乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别</h5><h5 id="5-4-5-线程的生命周期"><a href="#5-4-5-线程的生命周期" class="headerlink" title="5.4.5 线程的生命周期"></a>5.4.5 线程的生命周期</h5><h5 id="5-4-6-一致性hash算法原理与应用"><a href="#5-4-6-一致性hash算法原理与应用" class="headerlink" title="5.4.6 一致性hash算法原理与应用"></a>5.4.6 一致性hash算法原理与应用</h5><h5 id="5-4-7-CAP原则"><a href="#5-4-7-CAP原则" class="headerlink" title="5.4.7 CAP原则"></a>5.4.7 CAP原则</h5><h5 id="5-4-8-CAS操作"><a href="#5-4-8-CAS操作" class="headerlink" title="5.4.8 CAS操作"></a>5.4.8 CAS操作</h5><h5 id="5-4-9-分布式raft算法"><a href="#5-4-9-分布式raft算法" class="headerlink" title="5.4.9 分布式raft算法"></a>5.4.9 分布式raft算法</h5><br>

<h3 id="6">头条篇</h3>
---

<h5 id="6-1-0-5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。"><a href="#6-1-0-5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。" class="headerlink" title="6.1.0 5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。"></a>6.1.0 5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。</h5><h5 id="6-1-1-给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。"><a href="#6-1-1-给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。" class="headerlink" title="6.1.1 给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。"></a>6.1.1 给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。</h5><h5 id="6-1-2-一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？"><a href="#6-1-2-一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？" class="headerlink" title="6.1.2 一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？"></a>6.1.2 一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？</h5><h5 id="6-1-3-一个乱序数组，求第K大的数。排序方式使用字典序。"><a href="#6-1-3-一个乱序数组，求第K大的数。排序方式使用字典序。" class="headerlink" title="6.1.3 一个乱序数组，求第K大的数。排序方式使用字典序。"></a>6.1.3 一个乱序数组，求第K大的数。排序方式使用字典序。</h5><h5 id="6-1-4-一棵二叉树，求最大通路长度。（即最大左右子树高度之和）"><a href="#6-1-4-一棵二叉树，求最大通路长度。（即最大左右子树高度之和）" class="headerlink" title="6.1.4 一棵二叉树，求最大通路长度。（即最大左右子树高度之和）"></a>6.1.4 一棵二叉树，求最大通路长度。（即最大左右子树高度之和）</h5><h5 id="6-1-5-进程和线程的区别，使用线程真的能节省时间？"><a href="#6-1-5-进程和线程的区别，使用线程真的能节省时间？" class="headerlink" title="6.1.5 进程和线程的区别，使用线程真的能节省时间？"></a>6.1.5 进程和线程的区别，使用线程真的能节省时间？</h5><h5 id="6-1-6-go协程的调度方式，使用协程真的能节省时间？"><a href="#6-1-6-go协程的调度方式，使用协程真的能节省时间？" class="headerlink" title="6.1.6 go协程的调度方式，使用协程真的能节省时间？"></a>6.1.6 go协程的调度方式，使用协程真的能节省时间？</h5><h5 id="6-1-7-水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？"><a href="#6-1-7-水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？" class="headerlink" title="6.1.7 水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？"></a>6.1.7 水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？</h5><h5 id="6-1-8-有函数如下，输入1，返回什么？"><a href="#6-1-8-有函数如下，输入1，返回什么？" class="headerlink" title="6.1.8 有函数如下，输入1，返回什么？"></a>6.1.8 有函数如下，输入1，返回什么？</h5><h5 id="6-1-9-设计http协议，A端发送-AAAA，至少让B端知道AAAA已发送完成。"><a href="#6-1-9-设计http协议，A端发送-AAAA，至少让B端知道AAAA已发送完成。" class="headerlink" title="6.1.9 设计http协议，A端发送 AAAA，至少让B端知道AAAA已发送完成。"></a>6.1.9 设计http协议，A端发送 AAAA，至少让B端知道AAAA已发送完成。</h5><h5 id="6-2-0-流量总入口为api-gateway，api-gateway挂了会导致全部挂挂，用什么机制增大可用性？"><a href="#6-2-0-流量总入口为api-gateway，api-gateway挂了会导致全部挂挂，用什么机制增大可用性？" class="headerlink" title="6.2.0 流量总入口为api_gateway，api_gateway挂了会导致全部挂挂，用什么机制增大可用性？"></a>6.2.0 流量总入口为api_gateway，api_gateway挂了会导致全部挂挂，用什么机制增大可用性？</h5><h5 id="6-2-1-mysql为什么要用b-树，不用平衡二叉树做索引结构？"><a href="#6-2-1-mysql为什么要用b-树，不用平衡二叉树做索引结构？" class="headerlink" title="6.2.1 mysql为什么要用b+树，不用平衡二叉树做索引结构？"></a>6.2.1 mysql为什么要用b+树，不用平衡二叉树做索引结构？</h5><h5 id="6-2-2-创建数据库索引应该怎么考虑？"><a href="#6-2-2-创建数据库索引应该怎么考虑？" class="headerlink" title="6.2.2 创建数据库索引应该怎么考虑？"></a>6.2.2 创建数据库索引应该怎么考虑？</h5><h5 id="6-2-3-使用int-做primary-key和使用string-有什么优劣？"><a href="#6-2-3-使用int-做primary-key和使用string-有什么优劣？" class="headerlink" title="6.2.3 使用int 做primary key和使用string 有什么优劣？"></a>6.2.3 使用int 做primary key和使用string 有什么优劣？</h5><h5 id="6-2-4-数据库分表的方法？"><a href="#6-2-4-数据库分表的方法？" class="headerlink" title="6.2.4 数据库分表的方法？"></a>6.2.4 数据库分表的方法？</h5><h5 id="6-2-5-表结构，订单纪录如下，写一个语句，求卖的最好的-top-10-product-id。"><a href="#6-2-5-表结构，订单纪录如下，写一个语句，求卖的最好的-top-10-product-id。" class="headerlink" title="6.2.5 表结构，订单纪录如下，写一个语句，求卖的最好的 top 10 product_id。"></a>6.2.5 表结构，订单纪录如下，写一个语句，求卖的最好的 top 10 product_id。</h5><h5 id="6-2-6-微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？"><a href="#6-2-6-微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？" class="headerlink" title="6.2.6 微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？"></a>6.2.6 微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？</h5><h5 id="6-2-7-不使用高级工具，只使用Linux自带的工具，你会如何debug"><a href="#6-2-7-不使用高级工具，只使用Linux自带的工具，你会如何debug" class="headerlink" title="6.2.7 不使用高级工具，只使用Linux自带的工具，你会如何debug?"></a>6.2.7 不使用高级工具，只使用Linux自带的工具，你会如何debug?</h5><h5 id="6-2-8-如何预估一个mysql语句的性能？"><a href="#6-2-8-如何预估一个mysql语句的性能？" class="headerlink" title="6.2.8 如何预估一个mysql语句的性能？"></a>6.2.8 如何预估一个mysql语句的性能？</h5><h5 id="6-2-9-go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？"><a href="#6-2-9-go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？" class="headerlink" title="6.2.9 go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？"></a>6.2.9 go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？</h5><h5 id="6-3-0-socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据-还是9-10次的数据会先到达？"><a href="#6-3-0-socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据-还是9-10次的数据会先到达？" class="headerlink" title="6.3.0 socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据?还是9-10次的数据会先到达？"></a>6.3.0 socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据?还是9-10次的数据会先到达？</h5><h5 id="6-3-1-free-h，buffers-和cached有什么不同"><a href="#6-3-1-free-h，buffers-和cached有什么不同" class="headerlink" title="6.3.1 free -h，buffers 和cached有什么不同"></a>6.3.1 free -h，buffers 和cached有什么不同</h5><h5 id="6-3-2-后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么"><a href="#6-3-2-后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么" class="headerlink" title="6.3.2 后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么"></a>6.3.2 后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么</h5><h5 id="6-3-3-僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程"><a href="#6-3-3-僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程" class="headerlink" title="6.3.3 僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程"></a>6.3.3 僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程</h5><h5 id="6-3-4-孤儿进程是什么"><a href="#6-3-4-孤儿进程是什么" class="headerlink" title="6.3.4 孤儿进程是什么"></a>6.3.4 孤儿进程是什么</h5><h5 id="6-3-5-一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？"><a href="#6-3-5-一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？" class="headerlink" title="6.3.5 一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？"></a>6.3.5 一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？</h5><h5 id="6-3-6-tcp-ip-流量控制和拥塞控制"><a href="#6-3-6-tcp-ip-流量控制和拥塞控制" class="headerlink" title="6.3.6 tcp/ip 流量控制和拥塞控制"></a>6.3.6 tcp/ip 流量控制和拥塞控制</h5><h5 id="6-3-7-301-302有什么区别？应用上有什么异同。"><a href="#6-3-7-301-302有什么区别？应用上有什么异同。" class="headerlink" title="6.3.7 301/302有什么区别？应用上有什么异同。"></a>6.3.7 301/302有什么区别？应用上有什么异同。</h5><h5 id="6-3-8-50X相关错误码的内涵是什么？"><a href="#6-3-8-50X相关错误码的内涵是什么？" class="headerlink" title="6.3.8 50X相关错误码的内涵是什么？"></a>6.3.8 50X相关错误码的内涵是什么？</h5><h5 id="6-3-9-close-wait和time-wait是什么？如何排查？有什么意义？"><a href="#6-3-9-close-wait和time-wait是什么？如何排查？有什么意义？" class="headerlink" title="6.3.9 close wait和time wait是什么？如何排查？有什么意义？"></a>6.3.9 close wait和time wait是什么？如何排查？有什么意义？</h5><h5 id="6-4-0-http-req和resp的中数据有哪些"><a href="#6-4-0-http-req和resp的中数据有哪些" class="headerlink" title="6.4.0 http req和resp的中数据有哪些"></a>6.4.0 http req和resp的中数据有哪些</h5><h5 id="6-4-1-什么是连接的半打开，半关闭状态"><a href="#6-4-1-什么是连接的半打开，半关闭状态" class="headerlink" title="6.4.1 什么是连接的半打开，半关闭状态"></a>6.4.1 什么是连接的半打开，半关闭状态</h5><h5 id="6-4-2-假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进"><a href="#6-4-2-假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进" class="headerlink" title="6.4.2 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进"></a>6.4.2 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进</h5><h5 id="6-4-3-redis-sharding有哪些做法"><a href="#6-4-3-redis-sharding有哪些做法" class="headerlink" title="6.4.3 redis sharding有哪些做法"></a>6.4.3 redis sharding有哪些做法</h5><h5 id="6-4-4-当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案"><a href="#6-4-4-当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案" class="headerlink" title="6.4.4 当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案"></a>6.4.4 当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案</h5><h5 id="6-4-5-当redis-采用hash做sharding，现在有8个节点，负载方案是-pos-hash-key-8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash-presharding）"><a href="#6-4-5-当redis-采用hash做sharding，现在有8个节点，负载方案是-pos-hash-key-8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash-presharding）" class="headerlink" title="6.4.5 当redis 采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash, presharding）"></a>6.4.5 当redis 采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash, presharding）</h5><h5 id="6-4-6-如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作-update-db-username-update-redis-username-。但是执行update-db后故障，update-redis没有执行。有什么简单办法解决这个问题。"><a href="#6-4-6-如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作-update-db-username-update-redis-username-。但是执行update-db后故障，update-redis没有执行。有什么简单办法解决这个问题。" class="headerlink" title="6.4.6 如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username); update_redis(username)。但是执行update_db后故障，update_redis没有执行。有什么简单办法解决这个问题。"></a>6.4.6 如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username); update_redis(username)。但是执行update_db后故障，update_redis没有执行。有什么简单办法解决这个问题。</h5><h3 id="7">滴滴篇</h3>
---

<h5 id="7-1-0-B-树、B-树的区别"><a href="#7-1-0-B-树、B-树的区别" class="headerlink" title="7.1.0 B+树、B-树的区别?"></a>7.1.0 B+树、B-树的区别?</h5><h5 id="7-1-1-数据库隔离级别，幻读和不可重复读的区别？"><a href="#7-1-1-数据库隔离级别，幻读和不可重复读的区别？" class="headerlink" title="7.1.1 数据库隔离级别，幻读和不可重复读的区别？"></a>7.1.1 数据库隔离级别，幻读和不可重复读的区别？</h5><h5 id="7-1-2-有hell-well-hello-world等字符串组，现在问能否拼接成helloworld，代码实现。"><a href="#7-1-2-有hell-well-hello-world等字符串组，现在问能否拼接成helloworld，代码实现。" class="headerlink" title="7.1.2 有hell, well, hello, world等字符串组，现在问能否拼接成helloworld，代码实现。"></a>7.1.2 有hell, well, hello, world等字符串组，现在问能否拼接成helloworld，代码实现。</h5><h5 id="7-1-3-快排算法实现"><a href="#7-1-3-快排算法实现" class="headerlink" title="7.1.3 快排算法实现"></a>7.1.3 快排算法实现</h5><h5 id="7-1-4-线程安全的单例模式"><a href="#7-1-4-线程安全的单例模式" class="headerlink" title="7.1.4 线程安全的单例模式"></a>7.1.4 线程安全的单例模式</h5><h5 id="7-1-5-25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？"><a href="#7-1-5-25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？" class="headerlink" title="7.1.5 25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？"></a>7.1.5 25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？</h5><h5 id="7-1-6-kmp算法next数组的求解思路"><a href="#7-1-6-kmp算法next数组的求解思路" class="headerlink" title="7.1.6 kmp算法next数组的求解思路"></a>7.1.6 kmp算法next数组的求解思路</h5><h5 id="7-1-7-数组中有三个数字出现超过3-4，求这三个数字？"><a href="#7-1-7-数组中有三个数字出现超过3-4，求这三个数字？" class="headerlink" title="7.1.7 数组中有三个数字出现超过3/4，求这三个数字？"></a>7.1.7 数组中有三个数字出现超过3/4，求这三个数字？</h5><h5 id="7-1-8-1到n-2个数组中缺了两个数，如何用O-n-时间，O-1-空间找到这两个数字。"><a href="#7-1-8-1到n-2个数组中缺了两个数，如何用O-n-时间，O-1-空间找到这两个数字。" class="headerlink" title="7.1.8 1到n+2个数组中缺了两个数，如何用O(n)时间，O(1)空间找到这两个数字。"></a>7.1.8 1到n+2个数组中缺了两个数，如何用O(n)时间，O(1)空间找到这两个数字。</h5><h5 id="7-1-9-一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？"><a href="#7-1-9-一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？" class="headerlink" title="7.1.9 一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？"></a>7.1.9 一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？</h5><h5 id="7-2-0-有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？"><a href="#7-2-0-有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？" class="headerlink" title="7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？"></a>7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？</h5><h5 id="7-2-1-B-树做索引时，B-树通常高度为多少层？要参考哪些条件？"><a href="#7-2-1-B-树做索引时，B-树通常高度为多少层？要参考哪些条件？" class="headerlink" title="7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？"></a>7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？</h5><br>

<h3 id="8">京东篇</h3>
---

<h5 id="8-1-0-一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。"><a href="#8-1-0-一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。" class="headerlink" title="8.1.0 一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。"></a>8.1.0 一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。</h5><h5 id="8-1-1-masscan扫描端口时靠什么检测，为什么这么快-请详述"><a href="#8-1-1-masscan扫描端口时靠什么检测，为什么这么快-请详述" class="headerlink" title="8.1.1 masscan扫描端口时靠什么检测，为什么这么快? 请详述."></a>8.1.1 masscan扫描端口时靠什么检测，为什么这么快? 请详述.</h5><h5 id="8-1-2-你写过哪些小工具，你为你使用过的工具做过什么修改"><a href="#8-1-2-你写过哪些小工具，你为你使用过的工具做过什么修改" class="headerlink" title="8.1.2 你写过哪些小工具，你为你使用过的工具做过什么修改."></a>8.1.2 你写过哪些小工具，你为你使用过的工具做过什么修改.</h5><h5 id="8-1-3-如何提高采用python编写的扫描速度，谈谈对GIL锁的了解"><a href="#8-1-3-如何提高采用python编写的扫描速度，谈谈对GIL锁的了解" class="headerlink" title="8.1.3 如何提高采用python编写的扫描速度，谈谈对GIL锁的了解."></a>8.1.3 如何提高采用python编写的扫描速度，谈谈对GIL锁的了解.</h5><h5 id="8-1-4-你觉得你发现的那个漏洞影响比较大"><a href="#8-1-4-你觉得你发现的那个漏洞影响比较大" class="headerlink" title="8.1.4 你觉得你发现的那个漏洞影响比较大."></a>8.1.4 你觉得你发现的那个漏洞影响比较大.</h5><h5 id="8-1-5-常见的web漏洞有哪些"><a href="#8-1-5-常见的web漏洞有哪些" class="headerlink" title="8.1.5 常见的web漏洞有哪些."></a>8.1.5 常见的web漏洞有哪些.</h5><h5 id="8-1-6-有没有玩过硬件安全，研究程度如何"><a href="#8-1-6-有没有玩过硬件安全，研究程度如何" class="headerlink" title="8.1.6 有没有玩过硬件安全，研究程度如何."></a>8.1.6 有没有玩过硬件安全，研究程度如何.</h5><h5 id="8-1-7-反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。-使用无头浏览器被检测到了，如何绕过"><a href="#8-1-7-反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。-使用无头浏览器被检测到了，如何绕过" class="headerlink" title="8.1.7 反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。 使用无头浏览器被检测到了，如何绕过"></a>8.1.7 反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。 使用无头浏览器被检测到了，如何绕过</h5><h5 id="8-1-8-nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手-如何不直接接触目标服务器探测对方端口是否开放"><a href="#8-1-8-nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手-如何不直接接触目标服务器探测对方端口是否开放" class="headerlink" title="8.1.8 nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手. 如何不直接接触目标服务器探测对方端口是否开放"></a>8.1.8 nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手. 如何不直接接触目标服务器探测对方端口是否开放</h5><h5 id="8-1-9-有没有自己编写过yara扫描模块，如果要解决扫描-k1-v1-k2-v2-k3-v3-，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3-v3。怎么实现"><a href="#8-1-9-有没有自己编写过yara扫描模块，如果要解决扫描-k1-v1-k2-v2-k3-v3-，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3-v3。怎么实现" class="headerlink" title="8.1.9 有没有自己编写过yara扫描模块，如果要解决扫描{k1:v1, k2:v2, k3:v3} ，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3,v3。怎么实现"></a>8.1.9 有没有自己编写过yara扫描模块，如果要解决扫描{k1:v1, k2:v2, k3:v3} ，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3,v3。怎么实现</h5><h5 id="8-2-0-xss什么原理，如何自己实现一个beef类似的xss平台-既然这样实现，面临的跨域如何解决"><a href="#8-2-0-xss什么原理，如何自己实现一个beef类似的xss平台-既然这样实现，面临的跨域如何解决" class="headerlink" title="8.2.0 xss什么原理，如何自己实现一个beef类似的xss平台. 既然这样实现，面临的跨域如何解决?"></a>8.2.0 xss什么原理，如何自己实现一个beef类似的xss平台. 既然这样实现，面临的跨域如何解决?</h5><h5 id="8-2-1-ip-频率限制-ip信誉度模型？"><a href="#8-2-1-ip-频率限制-ip信誉度模型？" class="headerlink" title="8.2.1 ip 频率限制, ip信誉度模型？"></a>8.2.1 ip 频率限制, ip信誉度模型？</h5><h5 id="8-2-2-SCTP协议是什么？如何使用-SCTP-优化网络？"><a href="#8-2-2-SCTP协议是什么？如何使用-SCTP-优化网络？" class="headerlink" title="8.2.2 SCTP协议是什么？如何使用 SCTP 优化网络？"></a>8.2.2 SCTP协议是什么？如何使用 SCTP 优化网络？</h5><br>

<h3 id="9">mysql篇</h3> 
---

<h5 id="9-1-0-主键-超键-候选键-外键"><a href="#9-1-0-主键-超键-候选键-外键" class="headerlink" title="9.1.0 主键 超键 候选键 外键"></a><a href="09.MySQL篇/9.1.0%20%E4%B8%BB%E9%94%AE%20%E8%B6%85%E9%94%AE%20%E5%80%99%E9%80%89%E9%94%AE%20%E5%A4%96%E9%94%AE.md">9.1.0 主键 超键 候选键 外键</a></h5><h5 id="9-1-1-数据库事务的四个特性及含义"><a href="#9-1-1-数据库事务的四个特性及含义" class="headerlink" title="9.1.1 数据库事务的四个特性及含义"></a><a href="09.MySQL篇/9.1.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E5%8F%8A%E5%90%AB%E4%B9%89.md">9.1.1 数据库事务的四个特性及含义</a></h5><h5 id="9-1-2-视图的作用，视图可以更改么？"><a href="#9-1-2-视图的作用，视图可以更改么？" class="headerlink" title="9.1.2 视图的作用，视图可以更改么？"></a><a href="09.MySQL篇/9.1.2%20%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88%EF%BC%9F.md">9.1.2 视图的作用，视图可以更改么？</a></h5><h5 id="9-1-3-drop-delete与truncate的区别"><a href="#9-1-3-drop-delete与truncate的区别" class="headerlink" title="9.1.3 drop,delete与truncate的区别"></a><a href="09.MySQL篇/9.1.3%20drop%2Cdelete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB.md">9.1.3 drop,delete与truncate的区别</a></h5><h5 id="9-1-4-索引的工作原理及其种类"><a href="#9-1-4-索引的工作原理及其种类" class="headerlink" title="9.1.4 索引的工作原理及其种类"></a><a href="09.MySQL篇/9.1.4%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB.md">9.1.4 索引的工作原理及其种类</a></h5><h5 id="9-1-5-连接的种类"><a href="#9-1-5-连接的种类" class="headerlink" title="9.1.5 连接的种类"></a><a href="09.MySQL篇/9.1.5%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A7%8D%E7%B1%BB.md">9.1.5 连接的种类</a></h5><h5 id="9-1-6-数据库范式"><a href="#9-1-6-数据库范式" class="headerlink" title="9.1.6 数据库范式"></a><a href="09.MySQL篇/9.1.6%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F.md">9.1.6 数据库范式</a></h5><h5 id="9-1-7-数据库优化的思路"><a href="#9-1-7-数据库优化的思路" class="headerlink" title="9.1.7 数据库优化的思路"></a><a href="09.MySQL篇/9.1.7%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF.md">9.1.7 数据库优化的思路</a></h5><h5 id="9-1-8-存储过程与触发器的区别"><a href="#9-1-8-存储过程与触发器的区别" class="headerlink" title="9.1.8 存储过程与触发器的区别"></a><a href="09.MySQL篇/9.1.8%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.md">9.1.8 存储过程与触发器的区别</a></h5><br>


<h3 id="10">redis篇</h3> 
---
##### [10.1.0 使用Redis有哪些好处？](10.Redis篇/10.1.0%20%E4%BD%BF%E7%94%A8Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F.md)

<h5 id="10-1-1-redis相比memcached有哪些优势？"><a href="#10-1-1-redis相比memcached有哪些优势？" class="headerlink" title="10.1.1 redis相比memcached有哪些优势？"></a><a href="10.Redis篇/10.1.1%20redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F.md">10.1.1 redis相比memcached有哪些优势？</a></h5><h5 id="10-1-2-redis常见性能问题和解决方案"><a href="#10-1-2-redis常见性能问题和解决方案" class="headerlink" title="10.1.2 redis常见性能问题和解决方案"></a><a href="10.Redis篇/10.1.2%20redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md">10.1.2 redis常见性能问题和解决方案</a></h5><h5 id="10-1-3-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#10-1-3-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="10.1.3 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a><a href="10.Redis篇/10.1.3%20MySQL%E9%87%8C%E6%9C%892000w%E6%95%B0%E6%8D%AE%EF%BC%8Credis%E4%B8%AD%E5%8F%AA%E5%AD%9820w%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE.md">10.1.3 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</a></h5><h5 id="10-1-4-Memcache与Redis的区别都有哪些？"><a href="#10-1-4-Memcache与Redis的区别都有哪些？" class="headerlink" title="10.1.4 Memcache与Redis的区别都有哪些？"></a><a href="10.Redis篇/10.1.4%20Memcache%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.md">10.1.4 Memcache与Redis的区别都有哪些？</a></h5><h5 id="10-1-5-Redis-常见的性能问题都有哪些？如何解决？"><a href="#10-1-5-Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="10.1.5 Redis 常见的性能问题都有哪些？如何解决？"></a><a href="10.Redis篇/10.1.5%20Redis%20%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F.md">10.1.5 Redis 常见的性能问题都有哪些？如何解决？</a></h5><h5 id="10-1-6-redis-最适合的场景"><a href="#10-1-6-redis-最适合的场景" class="headerlink" title="10.1.6 redis 最适合的场景"></a>10.1.6 redis 最适合的场景</h5><h5 id="10-1-7-Redis的同步机制了解么？"><a href="#10-1-7-Redis的同步机制了解么？" class="headerlink" title="10.1.7 Redis的同步机制了解么？"></a><a href="10.Redis篇/10.1.7%20Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F.md">10.1.7 Redis的同步机制了解么？</a></h5><h5 id="10-1-8-是否使用过Redis集群，集群的原理是什么？"><a href="#10-1-8-是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="10.1.8 是否使用过Redis集群，集群的原理是什么？"></a><a href="10.Redis篇/10.1.8%20%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%87Redis%E9%9B%86%E7%BE%A4%EF%BC%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md">10.1.8 是否使用过Redis集群，集群的原理是什么？</a></h5><h5 id="10-1-9-redis集群如何保证一致性？"><a href="#10-1-9-redis集群如何保证一致性？" class="headerlink" title="10.1.9 redis集群如何保证一致性？"></a>10.1.9 redis集群如何保证一致性？</h5><br>

<h3 id="11">MongoDB篇</h3> 
---
##### [11.1.0 什么是MongoDB？](11.MongoDB篇/11.1.0%20%E4%BB%80%E4%B9%88%E6%98%AFMongoDB%EF%BC%9F.md)

<h5 id="11-1-1-MongoDB是由哪种语言写的？"><a href="#11-1-1-MongoDB是由哪种语言写的？" class="headerlink" title="11.1.1 MongoDB是由哪种语言写的？"></a><a href="11.MongoDB篇/11.1.1%20MongoDB%E6%98%AF%E7%94%B1%E5%93%AA%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84%EF%BC%9F.md">11.1.1 MongoDB是由哪种语言写的？</a></h5><h5 id="11-1-2-MongoDB的优势有哪些？"><a href="#11-1-2-MongoDB的优势有哪些？" class="headerlink" title="11.1.2 MongoDB的优势有哪些？"></a><a href="11.MongoDB篇/11.1.2%20MongoDB%E7%9A%84%E4%BC%98%E5%8A%BF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.md">11.1.2 MongoDB的优势有哪些？</a></h5><h5 id="11-1-3-什么是数据库？"><a href="#11-1-3-什么是数据库？" class="headerlink" title="11.1.3 什么是数据库？"></a><a href="11.MongoDB篇/11.1.3%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F.md">11.1.3 什么是数据库？</a></h5><h5 id="11-1-4-什么是集合？"><a href="#11-1-4-什么是集合？" class="headerlink" title="11.1.4 什么是集合？"></a><a href="11.MongoDB篇/11.1.4%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%EF%BC%9F.md">11.1.4 什么是集合？</a></h5><h5 id="11-1-5-什么是文档？"><a href="#11-1-5-什么是文档？" class="headerlink" title="11.1.5 什么是文档？"></a><a href="11.MongoDB篇/11.1.5%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%EF%BC%9F.md">11.1.5 什么是文档？</a></h5><h5 id="11-1-6-MongoDB和关系型数据库术语对比图"><a href="#11-1-6-MongoDB和关系型数据库术语对比图" class="headerlink" title="11.1.6 MongoDB和关系型数据库术语对比图"></a><a href="11.MongoDB篇/11.1.6%20MongoDB%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD%E5%AF%B9%E6%AF%94%E5%9B%BE.md">11.1.6 MongoDB和关系型数据库术语对比图</a></h5><h5 id="11-1-7-什么是“mongod”？"><a href="#11-1-7-什么是“mongod”？" class="headerlink" title="11.1.7 什么是“mongod”？"></a><a href="11.MongoDB篇/11.1.7%20%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9Cmongod%E2%80%9D%EF%BC%9F.md">11.1.7 什么是“mongod”？</a></h5><h5 id="11-1-8-“mongod”参数有什么？"><a href="#11-1-8-“mongod”参数有什么？" class="headerlink" title="11.1.8 “mongod”参数有什么？"></a><a href="11.MongoDB篇/11.1.8%20%E2%80%9Cmongod%E2%80%9D%E5%8F%82%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F.md">11.1.8 “mongod”参数有什么？</a></h5><h5 id="11-1-9-什么是“mongo”？"><a href="#11-1-9-什么是“mongo”？" class="headerlink" title="11.1.9 什么是“mongo”？"></a><a href="11.MongoDB篇/11.1.9%20%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9Cmongo%E2%80%9D%EF%BC%9F.md">11.1.9 什么是“mongo”？</a></h5><h5 id="11-2-0-MongoDB哪个命令可以切换数据库？"><a href="#11-2-0-MongoDB哪个命令可以切换数据库？" class="headerlink" title="11.2.0 MongoDB哪个命令可以切换数据库？"></a><a href="11.MongoDB篇/11.2.0%20MongoDB%E5%93%AA%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F.md">11.2.0 MongoDB哪个命令可以切换数据库？</a></h5><h5 id="11-2-1-什么是非关系型数据库？"><a href="#11-2-1-什么是非关系型数据库？" class="headerlink" title="11.2.1 什么是非关系型数据库？"></a><a href="11.MongoDB篇/11.2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F.md">11.2.1 什么是非关系型数据库？</a></h5><h5 id="11-2-2-非关系型数据库有哪些类型？"><a href="#11-2-2-非关系型数据库有哪些类型？" class="headerlink" title="11.2.2 非关系型数据库有哪些类型？"></a><a href="11.MongoDB篇/11.2.2%20%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F.md">11.2.2 非关系型数据库有哪些类型？</a></h5><h5 id="11-2-3-为什么用MOngoDB？"><a href="#11-2-3-为什么用MOngoDB？" class="headerlink" title="11.2.3 为什么用MOngoDB？"></a><a href="11.MongoDB篇/11.2.3%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8MOngoDB%EF%BC%9F.md">11.2.3 为什么用MOngoDB？</a></h5><h5 id="11-2-4-在哪些场景使用MongoDB？"><a href="#11-2-4-在哪些场景使用MongoDB？" class="headerlink" title="11.2.4 在哪些场景使用MongoDB？"></a><a href="11.MongoDB篇/11.2.4%20%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8MongoDB%EF%BC%9F.md">11.2.4 在哪些场景使用MongoDB？</a></h5><h5 id="11-2-5-MongoDB中的命名空间是什么意思"><a href="#11-2-5-MongoDB中的命名空间是什么意思" class="headerlink" title="11.2.5 MongoDB中的命名空间是什么意思?"></a>11.2.5 MongoDB中的命名空间是什么意思?</h5><h5 id="11-2-6-哪些语言支持MongoDB"><a href="#11-2-6-哪些语言支持MongoDB" class="headerlink" title="11.2.6 哪些语言支持MongoDB?"></a>11.2.6 哪些语言支持MongoDB?</h5><h5 id="11-2-7-在MongoDB中如何创建一个新的数据库？"><a href="#11-2-7-在MongoDB中如何创建一个新的数据库？" class="headerlink" title="11.2.7 在MongoDB中如何创建一个新的数据库？"></a><a href="11.MongoDB篇/11.2.7%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F.md">11.2.7 在MongoDB中如何创建一个新的数据库？</a></h5><h5 id="11-2-8-在MongoDB中如何查看数据库列表？"><a href="#11-2-8-在MongoDB中如何查看数据库列表？" class="headerlink" title="11.2.8 在MongoDB中如何查看数据库列表？"></a><a href="11.MongoDB篇/11.2.8%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%97%E8%A1%A8%EF%BC%9F.md">11.2.8 在MongoDB中如何查看数据库列表？</a></h5><h5 id="11-2-9-MongoDB中的分片是什么意思？"><a href="#11-2-9-MongoDB中的分片是什么意思？" class="headerlink" title="11.2.9 MongoDB中的分片是什么意思？"></a><a href="11.MongoDB篇/11.2.9%20MongoDB%E4%B8%AD%E7%9A%84%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F.md">11.2.9 MongoDB中的分片是什么意思？</a></h5><h5 id="11-3-0-如何查看使用MongoDB的连接？"><a href="#11-3-0-如何查看使用MongoDB的连接？" class="headerlink" title="11.3.0 如何查看使用MongoDB的连接？"></a><a href="11.MongoDB篇/11.3.0%20%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8MongoDB%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%9F.md">11.3.0 如何查看使用MongoDB的连接？</a></h5><h5 id="11-3-1-什么是复制？"><a href="#11-3-1-什么是复制？" class="headerlink" title="11.3.1 什么是复制？"></a><a href="11.MongoDB篇/11.3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%EF%BC%9F.md">11.3.1 什么是复制？</a></h5><h5 id="11-3-2-在MongoDB中如何在集合中插入一个文档？"><a href="#11-3-2-在MongoDB中如何在集合中插入一个文档？" class="headerlink" title="11.3.2 在MongoDB中如何在集合中插入一个文档？"></a><a href="11.MongoDB篇/11.3.2%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%EF%BC%9F.md">11.3.2 在MongoDB中如何在集合中插入一个文档？</a></h5><h5 id="11-3-3-在MongoDB中如何除去一个数据库？"><a href="#11-3-3-在MongoDB中如何除去一个数据库？" class="headerlink" title="11.3.3 在MongoDB中如何除去一个数据库？"></a><a href="11.MongoDB篇/11.3.3%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E9%99%A4%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F.md">11.3.3 在MongoDB中如何除去一个数据库？</a></h5><h5 id="11-3-4-在MongoDB中如何创建一个集合？"><a href="#11-3-4-在MongoDB中如何创建一个集合？" class="headerlink" title="11.3.4 在MongoDB中如何创建一个集合？"></a><a href="11.MongoDB篇/11.3.4%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%EF%BC%9F.md">11.3.4 在MongoDB中如何创建一个集合？</a></h5><h5 id="11-3-5-在MongoDB中如何查看一个已经创建的集合？"><a href="#11-3-5-在MongoDB中如何查看一个已经创建的集合？" class="headerlink" title="11.3.5 在MongoDB中如何查看一个已经创建的集合？"></a><a href="11.MongoDB篇/11.3.5%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9F.md">11.3.5 在MongoDB中如何查看一个已经创建的集合？</a></h5><h5 id="11-3-6-在MongoDB中如何删除一个集合？"><a href="#11-3-6-在MongoDB中如何删除一个集合？" class="headerlink" title="11.3.6 在MongoDB中如何删除一个集合？"></a><a href="11.MongoDB篇/11.3.6%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%EF%BC%9F.md">11.3.6 在MongoDB中如何删除一个集合？</a></h5><h5 id="11-3-7-为什么要在MongoDB中使用分析器？"><a href="#11-3-7-为什么要在MongoDB中使用分析器？" class="headerlink" title="11.3.7 为什么要在MongoDB中使用分析器？"></a><a href="11.MongoDB篇/11.3.7%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%9F.md">11.3.7 为什么要在MongoDB中使用分析器？</a></h5><h5 id="11-3-8-MongoDB支持主键外键关系吗？"><a href="#11-3-8-MongoDB支持主键外键关系吗？" class="headerlink" title="11.3.8 MongoDB支持主键外键关系吗？"></a><a href="11.MongoDB篇/11.3.8%20MongoDB%E6%94%AF%E6%8C%81%E4%B8%BB%E9%94%AE%E5%A4%96%E9%94%AE%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F.md">11.3.8 MongoDB支持主键外键关系吗？</a></h5><h5 id="11-3-9-MongoDB支持哪些数据类型？"><a href="#11-3-9-MongoDB支持哪些数据类型？" class="headerlink" title="11.3.9 MongoDB支持哪些数据类型？"></a><a href="11.MongoDB篇/11.3.9%20MongoDB%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F.md">11.3.9 MongoDB支持哪些数据类型？</a></h5><h5 id="11-4-0-为什么要在MongoDB中用”Code”数据类型？"><a href="#11-4-0-为什么要在MongoDB中用”Code”数据类型？" class="headerlink" title="11.4.0 为什么要在MongoDB中用”Code”数据类型？"></a>11.4.0 为什么要在MongoDB中用”Code”数据类型？</h5><h5 id="11-4-1-为什么要在MongoDB中用”Regular-Expression”数据类型？"><a href="#11-4-1-为什么要在MongoDB中用”Regular-Expression”数据类型？" class="headerlink" title="11.4.1 为什么要在MongoDB中用”Regular Expression”数据类型？"></a>11.4.1 为什么要在MongoDB中用”Regular Expression”数据类型？</h5><h5 id="11-4-2-为什么在MongoDB中使用”Object-ID”数据类型？"><a href="#11-4-2-为什么在MongoDB中使用”Object-ID”数据类型？" class="headerlink" title="11.4.2 为什么在MongoDB中使用”Object ID”数据类型？"></a>11.4.2 为什么在MongoDB中使用”Object ID”数据类型？</h5><h5 id="11-4-3-如何在集合中插入一个文档？"><a href="#11-4-3-如何在集合中插入一个文档？" class="headerlink" title="11.4.3 如何在集合中插入一个文档？"></a><a href="11.MongoDB篇/11.4.3%20%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%EF%BC%9F.md">11.4.3 如何在集合中插入一个文档？</a></h5><h5 id="11-4-4-“ObjectID”有哪些部分组成？"><a href="#11-4-4-“ObjectID”有哪些部分组成？" class="headerlink" title="11.4.4 “ObjectID”有哪些部分组成？"></a><a href="11.MongoDB篇/11.4.4%20%E2%80%9CObjectID%E2%80%9D%E6%9C%89%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F.md">11.4.4 “ObjectID”有哪些部分组成？</a></h5><h5 id="11-4-5-在MongoDb中什么是索引？"><a href="#11-4-5-在MongoDb中什么是索引？" class="headerlink" title="11.4.5 在MongoDb中什么是索引？"></a><a href="11.MongoDB篇/11.4.5%20%E5%9C%A8MongoDb%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F.md">11.4.5 在MongoDb中什么是索引？</a></h5><h5 id="11-4-6-如何添加索引？"><a href="#11-4-6-如何添加索引？" class="headerlink" title="11.4.6 如何添加索引？"></a><a href="11.MongoDB篇/11.4.6%20%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F.md">11.4.6 如何添加索引？</a></h5><h5 id="11-4-7-MongoDB有哪些可替代产品？"><a href="#11-4-7-MongoDB有哪些可替代产品？" class="headerlink" title="11.4.7 MongoDB有哪些可替代产品？"></a><a href="11.MongoDB篇/11.4.7%20MongoDB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E6%9B%BF%E4%BB%A3%E4%BA%A7%E5%93%81%EF%BC%9F.md">11.4.7 MongoDB有哪些可替代产品？</a></h5><h5 id="11-4-8-如何查询集合中的文档？"><a href="#11-4-8-如何查询集合中的文档？" class="headerlink" title="11.4.8 如何查询集合中的文档？"></a><a href="11.MongoDB篇/11.4.8%20%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%9F.md">11.4.8 如何查询集合中的文档？</a></h5><h5 id="11-4-9-用什么方法可以格式化输出结果？"><a href="#11-4-9-用什么方法可以格式化输出结果？" class="headerlink" title="11.4.9 用什么方法可以格式化输出结果？"></a><a href="11.MongoDB篇/11.4.9%20%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9F.md">11.4.9 用什么方法可以格式化输出结果？</a></h5><h5 id="11-5-0-如何使用”AND”或”OR”条件循环查询集合中的文档？"><a href="#11-5-0-如何使用”AND”或”OR”条件循环查询集合中的文档？" class="headerlink" title="11.5.0 如何使用”AND”或”OR”条件循环查询集合中的文档？"></a>11.5.0 如何使用”AND”或”OR”条件循环查询集合中的文档？</h5><h5 id="11-5-1-在MongoDB中如何更新数据？"><a href="#11-5-1-在MongoDB中如何更新数据？" class="headerlink" title="11.5.1 在MongoDB中如何更新数据？"></a><a href="11.MongoDB篇/11.5.1%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%9F.md">11.5.1 在MongoDB中如何更新数据？</a></h5><h5 id="11-5-2-如何删除文档？"><a href="#11-5-2-如何删除文档？" class="headerlink" title="11.5.2 如何删除文档？"></a><a href="11.MongoDB篇/11.5.2%20%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3%EF%BC%9F.md">11.5.2 如何删除文档？</a></h5><h5 id="11-5-3-在MongoDB中如何排序？"><a href="#11-5-3-在MongoDB中如何排序？" class="headerlink" title="11.5.3 在MongoDB中如何排序？"></a><a href="11.MongoDB篇/11.5.3%20%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F%EF%BC%9F.md">11.5.3 在MongoDB中如何排序？</a></h5><h5 id="11-5-4-什么是聚合？"><a href="#11-5-4-什么是聚合？" class="headerlink" title="11.5.4 什么是聚合？"></a><a href="11.MongoDB篇/11.5.4%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E5%90%88%EF%BC%9F.md">11.5.4 什么是聚合？</a></h5><h5 id="11-5-5-在MongoDB中什么是副本集？"><a href="#11-5-5-在MongoDB中什么是副本集？" class="headerlink" title="11.5.5 在MongoDB中什么是副本集？"></a><a href="11.MongoDB篇/11.5.5%20%E5%9C%A8MongoDB%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%AF%E6%9C%AC%E9%9B%86%EF%BC%9F.md">11.5.5 在MongoDB中什么是副本集？</a></h5><h5 id="11-5-6-Mongodb存储特性与内部原理"><a href="#11-5-6-Mongodb存储特性与内部原理" class="headerlink" title="11.5.6 Mongodb存储特性与内部原理?"></a>11.5.6 Mongodb存储特性与内部原理?</h5><br>

<h3 id="12">Zookeeper篇</h3> 
---
##### [12.1.0 zookeeper是什么？](12.1.0%20zookeeper%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md)

<h5 id="12-1-1-zookeeper提供了什么？"><a href="#12-1-1-zookeeper提供了什么？" class="headerlink" title="12.1.1 zookeeper提供了什么？"></a><a href="12.1.1%20zookeeper%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.md">12.1.1 zookeeper提供了什么？</a></h5><h5 id="12-1-2-zookeeper文件系统"><a href="#12-1-2-zookeeper文件系统" class="headerlink" title="12.1.2 zookeeper文件系统"></a><a href="12.1.2%20zookeeper%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.md">12.1.2 zookeeper文件系统</a></h5><h5 id="12-1-3-zookeeper的四种类型的znode"><a href="#12-1-3-zookeeper的四种类型的znode" class="headerlink" title="12.1.3 zookeeper的四种类型的znode"></a><a href="https://github.com/0voice/interview_internal_reference/blob/master/12.1.3%20zookeeper%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84znode.md" target="_blank" rel="noopener">12.1.3 zookeeper的四种类型的znode</a></h5><h5 id="12-1-4-zookeeper通知机制"><a href="#12-1-4-zookeeper通知机制" class="headerlink" title="12.1.4 zookeeper通知机制"></a><a href="12.1.4%20zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6.md">12.1.4 zookeeper通知机制</a></h5><h5 id="12-1-5-zookeeper有哪些应用场景？"><a href="#12-1-5-zookeeper有哪些应用场景？" class="headerlink" title="12.1.5 zookeeper有哪些应用场景？"></a><a href="12.1.5%20zookeeper%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F.md">12.1.5 zookeeper有哪些应用场景？</a></h5><h5 id="12-1-6-zk的命名服务"><a href="#12-1-6-zk的命名服务" class="headerlink" title="12.1.6 zk的命名服务"></a><a href="12.1.6%20zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1.md">12.1.6 zk的命名服务</a></h5><h5 id="12-1-7-zk的配置管理服务"><a href="#12-1-7-zk的配置管理服务" class="headerlink" title="12.1.7 zk的配置管理服务"></a><a href="12.1.7%20zk%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.md">12.1.7 zk的配置管理服务</a></h5><h5 id="12-1-8-zk的集群管理"><a href="#12-1-8-zk的集群管理" class="headerlink" title="12.1.8 zk的集群管理"></a><a href="12.1.8%20zk%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86.md">12.1.8 zk的集群管理</a></h5><h5 id="12-1-9-zk的分布式锁"><a href="#12-1-9-zk的分布式锁" class="headerlink" title="12.1.9 zk的分布式锁"></a><a href="12.1.9%20zk%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">12.1.9 zk的分布式锁</a></h5><h5 id="12-2-0-zk队列管理"><a href="#12-2-0-zk队列管理" class="headerlink" title="12.2.0 zk队列管理"></a><a href="12.2.0%20zk%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86.md">12.2.0 zk队列管理</a></h5><h5 id="12-2-1-zk数据复制"><a href="#12-2-1-zk数据复制" class="headerlink" title="12.2.1 zk数据复制"></a><a href="12.2.1%20zk%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6.md">12.2.1 zk数据复制</a></h5><h5 id="12-2-2-zk的工作原理"><a href="#12-2-2-zk的工作原理" class="headerlink" title="12.2.2 zk的工作原理"></a><a href="12.2.2%20zk%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md">12.2.2 zk的工作原理</a></h5><h5 id="12-2-3-zk是如何保证事物的顺序一致性"><a href="#12-2-3-zk是如何保证事物的顺序一致性" class="headerlink" title="12.2.3 zk是如何保证事物的顺序一致性"></a><a href="12.2.3%20zk%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E7%89%A9%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7.md">12.2.3 zk是如何保证事物的顺序一致性</a></h5><h5 id="12-2-4-zk集群下server工作状态"><a href="#12-2-4-zk集群下server工作状态" class="headerlink" title="12.2.4 zk集群下server工作状态"></a><a href="12.2.4%20zk%E9%9B%86%E7%BE%A4%E4%B8%8Bserver%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.md">12.2.4 zk集群下server工作状态</a></h5><h5 id="12-2-5-zk是如何选举Leader的？"><a href="#12-2-5-zk是如何选举Leader的？" class="headerlink" title="12.2.5 zk是如何选举Leader的？"></a><a href="12.2.5%20zk%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BELeader%E7%9A%84%EF%BC%9F.md">12.2.5 zk是如何选举Leader的？</a></h5><h5 id="12-2-6-zk同步流程"><a href="#12-2-6-zk同步流程" class="headerlink" title="12.2.6 zk同步流程"></a><a href="12.2.6%20zk%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B.md">12.2.6 zk同步流程</a></h5><h5 id="12-2-7-分布式通知和协调"><a href="#12-2-7-分布式通知和协调" class="headerlink" title="12.2.7 分布式通知和协调"></a><a href="12.2.7%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5%E5%92%8C%E5%8D%8F%E8%B0%83.md">12.2.7 分布式通知和协调</a></h5><h5 id="12-2-8-zk的session机制"><a href="#12-2-8-zk的session机制" class="headerlink" title="12.2.8 zk的session机制"></a>12.2.8 zk的session机制</h5><br>

<h3 id="13">nginx篇</h3> 
---
##### 13.1.0 请解释一下什么是Nginx?

<h5 id="13-1-1-请列举Nginx的一些特性"><a href="#13-1-1-请列举Nginx的一些特性" class="headerlink" title="13.1.1 请列举Nginx的一些特性?"></a>13.1.1 请列举Nginx的一些特性?</h5><h5 id="13-1-2-请列举Nginx和Apache-之间的不同点"><a href="#13-1-2-请列举Nginx和Apache-之间的不同点" class="headerlink" title="13.1.2 请列举Nginx和Apache 之间的不同点?"></a>13.1.2 请列举Nginx和Apache 之间的不同点?</h5><h5 id="13-1-3-请解释Nginx如何处理HTTP请求。"><a href="#13-1-3-请解释Nginx如何处理HTTP请求。" class="headerlink" title="13.1.3 请解释Nginx如何处理HTTP请求。"></a>13.1.3 请解释Nginx如何处理HTTP请求。</h5><h5 id="13-1-4-在Nginx中，如何使用未定义的服务器名称来阻止处理请求"><a href="#13-1-4-在Nginx中，如何使用未定义的服务器名称来阻止处理请求" class="headerlink" title="13.1.4 在Nginx中，如何使用未定义的服务器名称来阻止处理请求?"></a>13.1.4 在Nginx中，如何使用未定义的服务器名称来阻止处理请求?</h5><h5 id="13-1-5-使用“反向代理服务器”的优点是什么"><a href="#13-1-5-使用“反向代理服务器”的优点是什么" class="headerlink" title="13.1.5 使用“反向代理服务器”的优点是什么?"></a>13.1.5 使用“反向代理服务器”的优点是什么?</h5><h5 id="13-1-6-请列举Nginx服务器的最佳用途。"><a href="#13-1-6-请列举Nginx服务器的最佳用途。" class="headerlink" title="13.1.6 请列举Nginx服务器的最佳用途。"></a>13.1.6 请列举Nginx服务器的最佳用途。</h5><h5 id="13-1-7-请解释Nginx服务器上的Master和Worker进程分别是什么"><a href="#13-1-7-请解释Nginx服务器上的Master和Worker进程分别是什么" class="headerlink" title="13.1.7 请解释Nginx服务器上的Master和Worker进程分别是什么?"></a>13.1.7 请解释Nginx服务器上的Master和Worker进程分别是什么?</h5><h5 id="13-1-8-请解释你如何通过不同于80的端口开启Nginx"><a href="#13-1-8-请解释你如何通过不同于80的端口开启Nginx" class="headerlink" title="13.1.8 请解释你如何通过不同于80的端口开启Nginx?"></a>13.1.8 请解释你如何通过不同于80的端口开启Nginx?</h5><h5 id="13-1-9-请解释是否有可能将Nginx的错误替换为502错误、503"><a href="#13-1-9-请解释是否有可能将Nginx的错误替换为502错误、503" class="headerlink" title="13.1.9  请解释是否有可能将Nginx的错误替换为502错误、503?"></a>13.1.9  请解释是否有可能将Nginx的错误替换为502错误、503?</h5><h5 id="13-2-0-在Nginx中，解释如何在URL中保留双斜线"><a href="#13-2-0-在Nginx中，解释如何在URL中保留双斜线" class="headerlink" title="13.2.0 在Nginx中，解释如何在URL中保留双斜线?"></a>13.2.0 在Nginx中，解释如何在URL中保留双斜线?</h5><h5 id="13-2-1-请解释ngx-http-upstream-module的作用是什么"><a href="#13-2-1-请解释ngx-http-upstream-module的作用是什么" class="headerlink" title="13.2.1 请解释ngx_http_upstream_module的作用是什么?"></a>13.2.1 请解释ngx_http_upstream_module的作用是什么?</h5><h5 id="13-2-2-请解释什么是C10K问题，后来是怎么解决的？"><a href="#13-2-2-请解释什么是C10K问题，后来是怎么解决的？" class="headerlink" title="13.2.2 请解释什么是C10K问题，后来是怎么解决的？"></a>13.2.2 请解释什么是C10K问题，后来是怎么解决的？</h5><h5 id="13-2-3-请陈述stub-status和sub-filter指令的作用是什么"><a href="#13-2-3-请陈述stub-status和sub-filter指令的作用是什么" class="headerlink" title="13.2.3 请陈述stub_status和sub_filter指令的作用是什么?"></a>13.2.3 请陈述stub_status和sub_filter指令的作用是什么?</h5><h5 id="13-2-4-解释Nginx是否支持将请求压缩到上游"><a href="#13-2-4-解释Nginx是否支持将请求压缩到上游" class="headerlink" title="13.2.4 解释Nginx是否支持将请求压缩到上游?"></a>13.2.4 解释Nginx是否支持将请求压缩到上游?</h5><h5 id="13-2-5-解释如何在Nginx中获得当前的时间"><a href="#13-2-5-解释如何在Nginx中获得当前的时间" class="headerlink" title="13.2.5 解释如何在Nginx中获得当前的时间?"></a>13.2.5 解释如何在Nginx中获得当前的时间?</h5><h5 id="13-2-6-用Nginx服务器解释-s的目的是什么"><a href="#13-2-6-用Nginx服务器解释-s的目的是什么" class="headerlink" title="13.2.6 用Nginx服务器解释-s的目的是什么?"></a>13.2.6 用Nginx服务器解释-s的目的是什么?</h5><h5 id="13-2-7-解释如何在Nginx服务器上添加模块"><a href="#13-2-7-解释如何在Nginx服务器上添加模块" class="headerlink" title="13.2.7 解释如何在Nginx服务器上添加模块?"></a>13.2.7 解释如何在Nginx服务器上添加模块?</h5><h5 id="13-2-8-nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？"><a href="#13-2-8-nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？" class="headerlink" title="13.2.8 nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？"></a>13.2.8 nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？</h5><h5 id="13-2-9-nginx程序的热更新是如何做的？"><a href="#13-2-9-nginx程序的热更新是如何做的？" class="headerlink" title="13.2.9 nginx程序的热更新是如何做的？"></a>13.2.9 nginx程序的热更新是如何做的？</h5><h4 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h4><p>为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？</p>
<p><strong><em>答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚至是数组都是很困难的。而结构体（类似Pascal中的“记录”），则可以有效的解决这个问题。<br>结构体本质上还是一种数据类型，但它可以包括若干个“成员”，每个成员的类型可以相同也可以不同，也可以是基本数据类型或者又是一个构造类型。</em></strong></p>
<p><strong><em>优点：</em></strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/bolgzxy.github.io/2019/08/16/二叉树的遍历方式/" rel="next" title="二叉树的遍历方式">
                <i class="fa fa-chevron-left"></i> 二叉树的遍历方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#📑-目录"><span class="nav-number">1.</span> <span class="nav-text">📑 目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#➕-C-C"><span class="nav-number">2.</span> <span class="nav-text">➕ C/C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">2.1.</span> <span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">2.1.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">2.2.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-（面向对象的）静态成员变量"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">1. （面向对象的）静态成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-（面向对象的）-静态成员函数"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">2.（面向对象的） 静态成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-指针"><span class="nav-number">2.3.</span> <span class="nav-text">this 指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline-内联函数"><span class="nav-number">2.4.</span> <span class="nav-text">inline 内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特征"><span class="nav-number">2.4.1.</span> <span class="nav-text">特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译器对-inline-函数的处理步骤"><span class="nav-number">2.4.3.</span> <span class="nav-text">编译器对 inline 函数的处理步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">2.4.4.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数（virtual）可以是内联函数（inline）吗？"><span class="nav-number">2.4.5.</span> <span class="nav-text">虚函数（virtual）可以是内联函数（inline）吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">2.5.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert"><span class="nav-number">2.6.</span> <span class="nav-text">assert()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof"><span class="nav-number">2.7.</span> <span class="nav-text">sizeof()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pragma-pack-n"><span class="nav-number">2.8.</span> <span class="nav-text">#pragma pack(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位域"><span class="nav-number">2.9.</span> <span class="nav-text">位域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern-“C”"><span class="nav-number">2.10.</span> <span class="nav-text">extern “C”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-和-typedef-struct"><span class="nav-number">2.11.</span> <span class="nav-text">struct 和 typedef struct</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-中"><span class="nav-number">2.11.1.</span> <span class="nav-text">C 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-中-1"><span class="nav-number">2.11.2.</span> <span class="nav-text">C++ 中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中-struct-和-class"><span class="nav-number">2.12.</span> <span class="nav-text">C++ 中 struct 和 class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-number">2.12.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union-联合"><span class="nav-number">2.13.</span> <span class="nav-text">union 联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现-C-类"><span class="nav-number">2.14.</span> <span class="nav-text">C 实现 C++ 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit（显式）关键字"><span class="nav-number">2.15.</span> <span class="nav-text">explicit（显式）关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#friend-友元类和友元函数"><span class="nav-number">2.16.</span> <span class="nav-text">friend 友元类和友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using"><span class="nav-number">2.17.</span> <span class="nav-text">using</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#using-声明"><span class="nav-number">2.17.1.</span> <span class="nav-text">using 声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的-using-声明"><span class="nav-number">2.17.2.</span> <span class="nav-text">构造函数的 using 声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#using-指示"><span class="nav-number">2.17.3.</span> <span class="nav-text">using 指示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尽量少使用-using-指示-污染命名空间"><span class="nav-number">2.17.4.</span> <span class="nav-text">尽量少使用 using 指示 污染命名空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范围解析运算符"><span class="nav-number">2.18.</span> <span class="nav-text">:: 范围解析运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-number">2.18.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enum-枚举类型"><span class="nav-number">2.19.</span> <span class="nav-text">enum 枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#限定作用域的枚举类型"><span class="nav-number">2.19.1.</span> <span class="nav-text">限定作用域的枚举类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不限定作用域的枚举类型"><span class="nav-number">2.19.2.</span> <span class="nav-text">不限定作用域的枚举类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-number">2.20.</span> <span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">2.21.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#左值引用"><span class="nav-number">2.21.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#右值引用"><span class="nav-number">2.21.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用折叠"><span class="nav-number">2.21.3.</span> <span class="nav-text">引用折叠</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏"><span class="nav-number">2.22.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员初始化列表"><span class="nav-number">2.23.</span> <span class="nav-text">成员初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initializer-list-列表初始化"><span class="nav-number">2.24.</span> <span class="nav-text">initializer_list 列表初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">2.25.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">2.26.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.27.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">2.28.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态多态（编译期-早绑定）"><span class="nav-number">2.28.1.</span> <span class="nav-text">静态多态（编译期/早绑定）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态多态（运行期期-晚绑定）"><span class="nav-number">2.28.2.</span> <span class="nav-text">动态多态（运行期期/晚绑定）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚析构函数"><span class="nav-number">2.29.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数"><span class="nav-number">2.30.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数、纯虚函数"><span class="nav-number">2.31.</span> <span class="nav-text">虚函数、纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数指针、虚函数表"><span class="nav-number">2.32.</span> <span class="nav-text">虚函数指针、虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚继承"><span class="nav-number">2.33.</span> <span class="nav-text">虚继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚继承、虚函数"><span class="nav-number">2.34.</span> <span class="nav-text">虚继承、虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板类、成员模板、虚函数"><span class="nav-number">2.35.</span> <span class="nav-text">模板类、成员模板、虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类、接口类、聚合类"><span class="nav-number">2.36.</span> <span class="nav-text">抽象类、接口类、聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配和管理"><span class="nav-number">2.37.</span> <span class="nav-text">内存分配和管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc、calloc、realloc、alloca"><span class="nav-number">2.37.1.</span> <span class="nav-text">malloc、calloc、realloc、alloca</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc、free"><span class="nav-number">2.37.2.</span> <span class="nav-text">malloc、free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new、delete"><span class="nav-number">2.37.3.</span> <span class="nav-text">new、delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定位-new"><span class="nav-number">2.37.4.</span> <span class="nav-text">定位 new</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-this-合法吗？"><span class="nav-number">2.38.</span> <span class="nav-text">delete this 合法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何定义一个只能在堆上（栈上）生成对象的类？"><span class="nav-number">2.39.</span> <span class="nav-text">如何定义一个只能在堆上（栈上）生成对象的类？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#只能在堆上"><span class="nav-number">2.39.1.</span> <span class="nav-text">只能在堆上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#只能在栈上"><span class="nav-number">2.39.2.</span> <span class="nav-text">只能在栈上</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">2.40.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-标准库（STL）中"><span class="nav-number">2.40.1.</span> <span class="nav-text">C++ 标准库（STL）中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-98"><span class="nav-number">2.40.2.</span> <span class="nav-text">C++ 98</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11"><span class="nav-number">2.40.3.</span> <span class="nav-text">C++ 11</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shared-ptr"><span class="nav-number">2.40.3.1.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-ptr"><span class="nav-number">2.40.3.2.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unique-ptr"><span class="nav-number">2.40.3.3.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#auto-ptr"><span class="nav-number">2.40.3.4.</span> <span class="nav-text">auto_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#auto-ptr-与-unique-ptr-比较"><span class="nav-number">2.40.3.5.</span> <span class="nav-text">auto_ptr 与 unique_ptr 比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换运算符"><span class="nav-number">2.41.</span> <span class="nav-text">强制类型转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static-cast"><span class="nav-number">2.41.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">2.41.2.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-cast"><span class="nav-number">2.41.3.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">2.41.4.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bad-cast"><span class="nav-number">2.41.5.</span> <span class="nav-text">bad_cast</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时类型信息-RTTI"><span class="nav-number">2.42.</span> <span class="nav-text">运行时类型信息 (RTTI)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-cast-1"><span class="nav-number">2.42.1.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeid"><span class="nav-number">2.42.2.</span> <span class="nav-text">typeid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type-info"><span class="nav-number">2.42.3.</span> <span class="nav-text">type_info</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#⭐️-Effective"><span class="nav-number">3.</span> <span class="nav-text">⭐️ Effective</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Effective-C"><span class="nav-number">3.1.</span> <span class="nav-text">Effective C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#More-Effective-c"><span class="nav-number">3.2.</span> <span class="nav-text">More Effective c++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Google-C-Style-Guide"><span class="nav-number">3.3.</span> <span class="nav-text">Google C++ Style Guide</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">3.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#📦-STL"><span class="nav-number">4.</span> <span class="nav-text">📦 STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-索引"><span class="nav-number">4.1.</span> <span class="nav-text">STL 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-容器"><span class="nav-number">4.2.</span> <span class="nav-text">STL 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-算法"><span class="nav-number">4.3.</span> <span class="nav-text">STL 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#〽️-数据结构"><span class="nav-number">5.</span> <span class="nav-text">〽️ 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序结构"><span class="nav-number">5.1.</span> <span class="nav-text">顺序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序栈（Sequence-Stack）"><span class="nav-number">5.1.1.</span> <span class="nav-text">顺序栈（Sequence Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列（Sequence-Queue）"><span class="nav-number">5.1.2.</span> <span class="nav-text">队列（Sequence Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#非循环队列"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">非循环队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环队列"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">循环队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序表（Sequence-List）"><span class="nav-number">5.1.3.</span> <span class="nav-text">顺序表（Sequence List）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式结构"><span class="nav-number">5.2.</span> <span class="nav-text">链式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链队列（Link-Queue）"><span class="nav-number">5.2.1.</span> <span class="nav-text">链队列（Link Queue）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表的链式表示"><span class="nav-number">5.2.2.</span> <span class="nav-text">线性表的链式表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单链表（Link-List）"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">单链表（Link List）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向链表（Du-Link-List）"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">双向链表（Du-Link-List）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环链表（Cir-Link-List）"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">循环链表（Cir-Link-List）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">5.3.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">5.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">5.3.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冲突处理方法"><span class="nav-number">5.3.3.</span> <span class="nav-text">冲突处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性探测的哈希表数据结构"><span class="nav-number">5.3.4.</span> <span class="nav-text">线性探测的哈希表数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">5.4.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-1"><span class="nav-number">5.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归与分治"><span class="nav-number">5.4.2.</span> <span class="nav-text">递归与分治</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归与迭代"><span class="nav-number">5.4.3.</span> <span class="nav-text">递归与迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广义表"><span class="nav-number">5.4.4.</span> <span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#头尾链表存储表示"><span class="nav-number">5.4.4.1.</span> <span class="nav-text">头尾链表存储表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扩展线性链表存储表示"><span class="nav-number">5.4.4.2.</span> <span class="nav-text">扩展线性链表存储表示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">5.5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#性质"><span class="nav-number">5.5.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储结构"><span class="nav-number">5.5.2.</span> <span class="nav-text">存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序存储"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链式存储"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">链式存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历方式"><span class="nav-number">5.5.3.</span> <span class="nav-text">遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类-1"><span class="nav-number">5.5.4.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他树及森林"><span class="nav-number">5.6.</span> <span class="nav-text">其他树及森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的存储结构"><span class="nav-number">5.6.1.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并查集"><span class="nav-number">5.6.2.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡二叉树（AVL树）"><span class="nav-number">5.6.3.</span> <span class="nav-text">平衡二叉树（AVL树）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#性质-1"><span class="nav-number">5.6.3.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最小失衡树"><span class="nav-number">5.6.3.2.</span> <span class="nav-text">最小失衡树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">5.6.4.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#红黑树的特征是什么？"><span class="nav-number">5.6.4.1.</span> <span class="nav-text">红黑树的特征是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#调整"><span class="nav-number">5.6.4.2.</span> <span class="nav-text">调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#应用"><span class="nav-number">5.6.4.3.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#红黑树、B-树、B-树的区别？"><span class="nav-number">5.6.4.4.</span> <span class="nav-text">红黑树、B 树、B+ 树的区别？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树（B-tree）、B-树（B-tree）"><span class="nav-number">5.6.5.</span> <span class="nav-text">B 树（B-tree）、B+ 树（B+-tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#特点"><span class="nav-number">5.6.5.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#应用-1"><span class="nav-number">5.6.5.2.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#区别-1"><span class="nav-number">5.6.5.3.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B树的优点"><span class="nav-number">5.6.5.4.</span> <span class="nav-text">B树的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-树的优点"><span class="nav-number">5.6.5.5.</span> <span class="nav-text">B+树的优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八叉树"><span class="nav-number">5.6.6.</span> <span class="nav-text">八叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用途"><span class="nav-number">5.6.6.1.</span> <span class="nav-text">用途</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⚡️-算法"><span class="nav-number">6.</span> <span class="nav-text">⚡️ 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">6.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-number">6.2.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图搜索算法"><span class="nav-number">6.3.</span> <span class="nav-text">图搜索算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他算法"><span class="nav-number">6.4.</span> <span class="nav-text">其他算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#❓-Problems"><span class="nav-number">7.</span> <span class="nav-text">❓ Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-Problem"><span class="nav-number">7.1.</span> <span class="nav-text">Single Problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-Problems"><span class="nav-number">7.2.</span> <span class="nav-text">Leetcode Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer"><span class="nav-number">7.3.</span> <span class="nav-text">剑指 Offer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cracking-the-Coding-Interview-程序员面试金典"><span class="nav-number">7.4.</span> <span class="nav-text">Cracking the Coding Interview 程序员面试金典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#牛客网"><span class="nav-number">7.5.</span> <span class="nav-text">牛客网</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#💻-操作系统"><span class="nav-number">8.</span> <span class="nav-text">💻 操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与线程"><span class="nav-number">8.1.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间的通信方式以及优缺点"><span class="nav-number">8.1.1.</span> <span class="nav-text">进程之间的通信方式以及优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程之间的通信方式"><span class="nav-number">8.1.2.</span> <span class="nav-text">线程之间的通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间私有和共享的资源"><span class="nav-number">8.1.3.</span> <span class="nav-text">进程之间私有和共享的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程之间私有和共享的资源"><span class="nav-number">8.1.4.</span> <span class="nav-text">线程之间私有和共享的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程与多线程间的对比、优劣与选择"><span class="nav-number">8.1.5.</span> <span class="nav-text">多进程与多线程间的对比、优劣与选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对比"><span class="nav-number">8.1.5.1.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优劣"><span class="nav-number">8.1.5.2.</span> <span class="nav-text">优劣</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择"><span class="nav-number">8.1.5.3.</span> <span class="nav-text">选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-内核的同步方式"><span class="nav-number">8.2.</span> <span class="nav-text">Linux 内核的同步方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原因"><span class="nav-number">8.2.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步方式"><span class="nav-number">8.2.2.</span> <span class="nav-text">同步方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">8.3.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原因-1"><span class="nav-number">8.3.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生条件"><span class="nav-number">8.3.2.</span> <span class="nav-text">产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预防"><span class="nav-number">8.3.3.</span> <span class="nav-text">预防</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">8.4.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主机字节序与网络字节序"><span class="nav-number">8.5.</span> <span class="nav-text">主机字节序与网络字节序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主机字节序（CPU-字节序）"><span class="nav-number">8.5.1.</span> <span class="nav-text">主机字节序（CPU 字节序）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-2"><span class="nav-number">8.5.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存储方式"><span class="nav-number">8.5.1.2.</span> <span class="nav-text">存储方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断大端小端"><span class="nav-number">8.5.1.3.</span> <span class="nav-text">判断大端小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#各架构处理器的字节序"><span class="nav-number">8.5.1.4.</span> <span class="nav-text">各架构处理器的字节序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络字节序"><span class="nav-number">8.5.2.</span> <span class="nav-text">网络字节序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-number">8.6.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类-2"><span class="nav-number">8.6.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法"><span class="nav-number">8.6.2.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#☁️-计算机网络"><span class="nav-number">9.</span> <span class="nav-text">☁️ 计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各层作用及协议"><span class="nav-number">9.1.</span> <span class="nav-text">各层作用及协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理层"><span class="nav-number">9.2.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据链路层"><span class="nav-number">9.3.</span> <span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#点对点信道"><span class="nav-number">9.3.1.</span> <span class="nav-text">点对点信道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广播信道"><span class="nav-number">9.3.2.</span> <span class="nav-text">广播信道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络层"><span class="nav-number">9.4.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-网际协议"><span class="nav-number">9.4.1.</span> <span class="nav-text">IP 网际协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ICMP-网际控制报文协议"><span class="nav-number">9.4.2.</span> <span class="nav-text">ICMP 网际控制报文协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部网关协议"><span class="nav-number">9.4.3.</span> <span class="nav-text">内部网关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部网关协议"><span class="nav-number">9.4.4.</span> <span class="nav-text">外部网关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP多播"><span class="nav-number">9.4.5.</span> <span class="nav-text">IP多播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VPN-和-NAT"><span class="nav-number">9.4.6.</span> <span class="nav-text">VPN 和 NAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由表包含什么？"><span class="nav-number">9.4.7.</span> <span class="nav-text">路由表包含什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运输层"><span class="nav-number">9.5.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP"><span class="nav-number">9.5.1.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP"><span class="nav-number">9.5.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-与-UDP-的区别"><span class="nav-number">9.5.3.</span> <span class="nav-text">TCP 与 UDP 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-黏包问题"><span class="nav-number">9.5.4.</span> <span class="nav-text">TCP 黏包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#原因-2"><span class="nav-number">9.5.4.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解决"><span class="nav-number">9.5.4.2.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-流量控制"><span class="nav-number">9.5.5.</span> <span class="nav-text">TCP 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-3"><span class="nav-number">9.5.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法"><span class="nav-number">9.5.5.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-拥塞控制"><span class="nav-number">9.5.6.</span> <span class="nav-text">TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-4"><span class="nav-number">9.5.6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法-1"><span class="nav-number">9.5.6.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-传输连接管理"><span class="nav-number">9.5.7.</span> <span class="nav-text">TCP 传输连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-三次握手建立连接"><span class="nav-number">9.5.7.1.</span> <span class="nav-text">TCP 三次握手建立连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-为什么要进行三次握手？"><span class="nav-number">9.5.7.2.</span> <span class="nav-text">TCP 为什么要进行三次握手？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-四次挥手释放连接"><span class="nav-number">9.5.7.3.</span> <span class="nav-text">TCP 四次挥手释放连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-为什么要进行四次挥手？"><span class="nav-number">9.5.7.4.</span> <span class="nav-text">TCP 为什么要进行四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-有限状态机"><span class="nav-number">9.5.8.</span> <span class="nav-text">TCP 有限状态机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用层"><span class="nav-number">9.6.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">9.6.1.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FTP"><span class="nav-number">9.6.2.</span> <span class="nav-text">FTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TELNET"><span class="nav-number">9.6.3.</span> <span class="nav-text">TELNET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WWW"><span class="nav-number">9.6.4.</span> <span class="nav-text">WWW</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URL"><span class="nav-number">9.6.4.1.</span> <span class="nav-text">URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP"><span class="nav-number">9.6.4.2.</span> <span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他协议"><span class="nav-number">9.6.4.3.</span> <span class="nav-text">其他协议</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌩-网络编程"><span class="nav-number">10.</span> <span class="nav-text">🌩 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-number">10.1.</span> <span class="nav-text">Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket-中的-read-、write-函数"><span class="nav-number">10.1.1.</span> <span class="nav-text">Socket 中的 read()、write() 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#read"><span class="nav-number">10.1.1.1.</span> <span class="nav-text">read()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#write"><span class="nav-number">10.1.1.2.</span> <span class="nav-text">write()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket-中-TCP-的三次握手建立连接"><span class="nav-number">10.1.2.</span> <span class="nav-text">Socket 中 TCP 的三次握手建立连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket-中-TCP-的四次握手释放连接"><span class="nav-number">10.1.3.</span> <span class="nav-text">Socket 中 TCP 的四次握手释放连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#💾-数据库"><span class="nav-number">11.</span> <span class="nav-text">💾 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">11.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用数据模型"><span class="nav-number">11.2.</span> <span class="nav-text">常用数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用-SQL-操作"><span class="nav-number">11.3.</span> <span class="nav-text">常用 SQL 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系型数据库"><span class="nav-number">11.4.</span> <span class="nav-text">关系型数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引"><span class="nav-number">11.4.1.</span> <span class="nav-text">索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库完整性"><span class="nav-number">11.5.</span> <span class="nav-text">数据库完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据理论"><span class="nav-number">11.6.</span> <span class="nav-text">关系数据理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#范式"><span class="nav-number">11.6.1.</span> <span class="nav-text">范式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库恢复"><span class="nav-number">11.7.</span> <span class="nav-text">数据库恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发控制"><span class="nav-number">11.8.</span> <span class="nav-text">并发控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#📏-设计模式"><span class="nav-number">12.</span> <span class="nav-text">📏 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">12.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">12.2.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器模式"><span class="nav-number">12.3.</span> <span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥接模式"><span class="nav-number">12.4.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式"><span class="nav-number">12.5.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式的六大原则"><span class="nav-number">12.6.</span> <span class="nav-text">设计模式的六大原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⚙️-链接装载库"><span class="nav-number">13.</span> <span class="nav-text">⚙️ 链接装载库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存、栈、堆"><span class="nav-number">13.1.</span> <span class="nav-text">内存、栈、堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈"><span class="nav-number">13.1.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆"><span class="nav-number">13.1.2.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><span class="nav-number">13.1.3.</span> <span class="nav-text">“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译链接"><span class="nav-number">13.2.</span> <span class="nav-text">编译链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#各平台文件格式"><span class="nav-number">13.2.1.</span> <span class="nav-text">各平台文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译链接过程"><span class="nav-number">13.2.2.</span> <span class="nav-text">编译链接过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目标文件"><span class="nav-number">13.2.3.</span> <span class="nav-text">目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#目标文件格式"><span class="nav-number">13.2.3.1.</span> <span class="nav-text">目标文件格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目标文件存储结构"><span class="nav-number">13.2.3.2.</span> <span class="nav-text">目标文件存储结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接的接口————符号"><span class="nav-number">13.2.4.</span> <span class="nav-text">链接的接口————符号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-的共享库（Shared-Library）"><span class="nav-number">13.3.</span> <span class="nav-text">Linux 的共享库（Shared Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命名"><span class="nav-number">13.3.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径"><span class="nav-number">13.3.2.</span> <span class="nav-text">路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环境变量"><span class="nav-number">13.3.3.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#so-共享库的编写"><span class="nav-number">13.3.4.</span> <span class="nav-text">so 共享库的编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#so-共享库的使用（被可执行项目调用）"><span class="nav-number">13.3.5.</span> <span class="nav-text">so 共享库的使用（被可执行项目调用）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-应用程序入口函数"><span class="nav-number">13.4.</span> <span class="nav-text">Windows 应用程序入口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-的动态链接库（Dynamic-Link-Library）"><span class="nav-number">13.5.</span> <span class="nav-text">Windows 的动态链接库（Dynamic-Link Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用处"><span class="nav-number">13.5.1.</span> <span class="nav-text">用处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">13.5.2.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载-Windows-程序的搜索顺序"><span class="nav-number">13.5.3.</span> <span class="nav-text">加载 Windows 程序的搜索顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DLL-入口函数"><span class="nav-number">13.5.4.</span> <span class="nav-text">DLL 入口函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#载入卸载库"><span class="nav-number">13.5.5.</span> <span class="nav-text">载入卸载库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显示地链接到导出符号"><span class="nav-number">13.5.6.</span> <span class="nav-text">显示地链接到导出符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DumpBin-exe-查看-DLL-信息"><span class="nav-number">13.5.7.</span> <span class="nav-text">DumpBin.exe 查看 DLL 信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LoadLibrary-与-FreeLibrary-流程图"><span class="nav-number">13.5.8.</span> <span class="nav-text">LoadLibrary 与 FreeLibrary 流程图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LoadLibrary"><span class="nav-number">13.5.8.1.</span> <span class="nav-text">LoadLibrary</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FreeLibrary"><span class="nav-number">13.5.8.2.</span> <span class="nav-text">FreeLibrary</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DLL-库的编写（导出一个-DLL-模块）"><span class="nav-number">13.5.9.</span> <span class="nav-text">DLL 库的编写（导出一个 DLL 模块）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DLL-库的使用（运行时动态链接-DLL）"><span class="nav-number">13.5.10.</span> <span class="nav-text">DLL 库的使用（运行时动态链接 DLL）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行库（Runtime-Library）"><span class="nav-number">13.6.</span> <span class="nav-text">运行库（Runtime Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#典型程序运行步骤"><span class="nav-number">13.6.1.</span> <span class="nav-text">典型程序运行步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#glibc-入口"><span class="nav-number">13.6.2.</span> <span class="nav-text">glibc 入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSVC-CRT-入口"><span class="nav-number">13.6.3.</span> <span class="nav-text">MSVC CRT 入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-语言运行库（CRT）"><span class="nav-number">13.6.4.</span> <span class="nav-text">C 语言运行库（CRT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C语言标准库（ANSI-C）"><span class="nav-number">13.6.5.</span> <span class="nav-text">C语言标准库（ANSI C）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#📚-书籍"><span class="nav-number">14.</span> <span class="nav-text">📚 书籍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语言"><span class="nav-number">14.1.</span> <span class="nav-text">语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法-1"><span class="nav-number">14.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统"><span class="nav-number">14.3.</span> <span class="nav-text">系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络"><span class="nav-number">14.4.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他-1"><span class="nav-number">14.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🔱-C-C-发展方向"><span class="nav-number">15.</span> <span class="nav-text">🔱 C/C++ 发展方向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#后台-服务器"><span class="nav-number">15.1.</span> <span class="nav-text">后台/服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桌面客户端"><span class="nav-number">15.2.</span> <span class="nav-text">桌面客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图形学-游戏-VR-AR"><span class="nav-number">15.3.</span> <span class="nav-text">图形学/游戏/VR/AR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试开发"><span class="nav-number">15.4.</span> <span class="nav-text">测试开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络安全-逆向"><span class="nav-number">15.5.</span> <span class="nav-text">网络安全/逆向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌入式-物联网"><span class="nav-number">15.6.</span> <span class="nav-text">嵌入式/物联网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#音视频-流媒体-SDK"><span class="nav-number">15.7.</span> <span class="nav-text">音视频/流媒体/SDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机视觉-机器学习"><span class="nav-number">15.8.</span> <span class="nav-text">计算机视觉/机器学习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#💯-复习刷题网站"><span class="nav-number">16.</span> <span class="nav-text">💯 复习刷题网站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#📝-面试题目经验"><span class="nav-number">17.</span> <span class="nav-text">📝 面试题目经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。"><span class="nav-number">18.</span> <span class="nav-text">2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">18.1.</span> <span class="nav-text">阿里篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-如何实现一个高效的单向链表逆序输出？"><span class="nav-number">18.1.0.1.</span> <span class="nav-text">1.1.1 如何实现一个高效的单向链表逆序输出？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-已知sqrt-2-约等于1-414，要求不用数学库，求sqrt-2-精确到小数点后10位"><span class="nav-number">18.1.0.2.</span> <span class="nav-text">1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-给定一个二叉搜索树-BST-，找到树中第-K-小的节点"><span class="nav-number">18.1.0.3.</span> <span class="nav-text">1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-LRU缓存机制"><span class="nav-number">18.1.0.4.</span> <span class="nav-text">1.1.4 LRU缓存机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-关于epoll和select的区别，以下哪些说法是正确的"><span class="nav-number">18.1.0.5.</span> <span class="nav-text">1.1.5 关于epoll和select的区别，以下哪些说法是正确的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-6-从innodb的索引结构分析，为什么索引的-key-长度不能太长"><span class="nav-number">18.1.0.6.</span> <span class="nav-text">1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-7-MySQL的数据如何恢复到任意时间点？"><span class="nav-number">18.1.0.7.</span> <span class="nav-text">1.1.7 MySQL的数据如何恢复到任意时间点？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-8-NFS-和-SMB-是最常见的两种-NAS（Network-Attached-Storage）协议，当把一个文件系统同时通过-NFS-和-SMB-协议共享给多个主机访问时，以下哪些说法是错误的"><span class="nav-number">18.1.0.8.</span> <span class="nav-text">1.1.8 NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-9-输入-ping-IP-后敲回车，发包前会发生什么？"><span class="nav-number">18.1.0.9.</span> <span class="nav-text">1.1.9 输入 ping IP 后敲回车，发包前会发生什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-0-请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"><span class="nav-number">18.1.0.10.</span> <span class="nav-text">1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？"><span class="nav-number">18.1.0.11.</span> <span class="nav-text">1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-有一批气象观测站，现需要获取这些站点的观测数据，并存储到-Hive-中。但是气象局只提供了-api-查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"><span class="nav-number">18.1.0.12.</span> <span class="nav-text">1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-如何实现两金额数据相加（最多小数点两位）"><span class="nav-number">18.1.0.13.</span> <span class="nav-text">1.2.3 如何实现两金额数据相加（最多小数点两位）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-关于并行计算的一些基础开放问题"><span class="nav-number">18.1.0.14.</span> <span class="nav-text">1.2.4 关于并行计算的一些基础开放问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-5-请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式"><span class="nav-number">18.1.0.15.</span> <span class="nav-text">1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-6-一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素"><span class="nav-number">18.1.0.16.</span> <span class="nav-text">1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-7-请分析-MaxCompute-产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势"><span class="nav-number">18.1.0.17.</span> <span class="nav-text">1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-8-对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响"><span class="nav-number">18.1.0.18.</span> <span class="nav-text">1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-9-你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述"><span class="nav-number">18.1.0.19.</span> <span class="nav-text">1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-0-在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行-IO-读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时-如何保证优先级和公平性"><span class="nav-number">18.1.0.20.</span> <span class="nav-text">1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时,如何保证优先级和公平性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-最大频率栈"><span class="nav-number">18.1.0.21.</span> <span class="nav-text">1.3.1 最大频率栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点"><span class="nav-number">18.1.0.22.</span> <span class="nav-text">1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计"><span class="nav-number">18.1.0.23.</span> <span class="nav-text">1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-如果让你来设计一个支持数据库、NOSQL-和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？"><span class="nav-number">18.1.0.24.</span> <span class="nav-text">1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-5-给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度"><span class="nav-number">18.1.0.25.</span> <span class="nav-text">1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-6-假如给你一个新产品，你将从哪些方面来保障它的质量？"><span class="nav-number">18.1.0.26.</span> <span class="nav-text">1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-7-请评估一下程序的执行结果？"><span class="nav-number">18.1.0.27.</span> <span class="nav-text">1.3.7 请评估一下程序的执行结果？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2"><span class="nav-number">18.2.</span> <span class="nav-text">华为篇</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-1-引用与指针有什么区别？"><span class="nav-number">18.2.0.0.1.</span> <span class="nav-text">2.1.1 引用与指针有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-描述实时系统的基本特性"><span class="nav-number">18.2.0.1.</span> <span class="nav-text">2.1.2 描述实时系统的基本特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><span class="nav-number">18.2.0.2.</span> <span class="nav-text">2.1.3 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-什么是平衡二叉树？"><span class="nav-number">18.2.0.3.</span> <span class="nav-text">2.1.4 什么是平衡二叉树？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-堆栈溢出一般是由什么原因导致的？"><span class="nav-number">18.2.0.4.</span> <span class="nav-text">2.1.5 堆栈溢出一般是由什么原因导致的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-6-什么函数不能声明为虚函数？"><span class="nav-number">18.2.0.5.</span> <span class="nav-text">2.1.6 什么函数不能声明为虚函数？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-7-冒泡排序算法的时间复杂度是什么？"><span class="nav-number">18.2.0.6.</span> <span class="nav-text">2.1.7 冒泡排序算法的时间复杂度是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-8-写出float-x-与“零值”比较的if语句"><span class="nav-number">18.2.0.7.</span> <span class="nav-text">2.1.8 写出float x 与“零值”比较的if语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-9-Internet采用哪种网络协议？该协议的主要层次结构？"><span class="nav-number">18.2.0.8.</span> <span class="nav-text">2.1.9 Internet采用哪种网络协议？该协议的主要层次结构？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-0-Internet物理地址和IP地址转换采用什么协议？"><span class="nav-number">18.2.0.9.</span> <span class="nav-text">2.2.0 Internet物理地址和IP地址转换采用什么协议？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-IP地址的编码分为哪俩部分？"><span class="nav-number">18.2.0.10.</span> <span class="nav-text">2.2.1 IP地址的编码分为哪俩部分？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-用户输入M-N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"><span class="nav-number">18.2.0.11.</span> <span class="nav-text">2.2.2 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-不能做switch-的参数类型是"><span class="nav-number">18.2.0.12.</span> <span class="nav-text">2.2.3 不能做switch()的参数类型是</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-int-A-nSize-，其中隐藏着若干0，其余非0整数，写一个函数int-Func-int-A-int-nSize-，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。"><span class="nav-number">18.2.0.13.</span> <span class="nav-text">2.2.4 int A[nSize]，其中隐藏着若干0，其余非0整数，写一个函数int Func(int* A, int nSize)，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-5-写一个程序-要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数"><span class="nav-number">18.2.0.14.</span> <span class="nav-text">2.2.5 写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-6-实现一个函数，把一个字符串中的字符从小写转为大写"><span class="nav-number">18.2.0.15.</span> <span class="nav-text">2.2.6 实现一个函数，把一个字符串中的字符从小写转为大写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-7-随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数"><span class="nav-number">18.2.0.16.</span> <span class="nav-text">2.2.7 随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-8-求2-2000的所有素数-有足够的内存-要求尽量快"><span class="nav-number">18.2.0.17.</span> <span class="nav-text">2.2.8 求2~2000的所有素数.有足够的内存,要求尽量快</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-9-A-B-C-D四个进程，A向buf里面写数据，B-C-D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。"><span class="nav-number">18.2.0.18.</span> <span class="nav-text">2.2.9 A,B,C,D四个进程，A向buf里面写数据，B,C,D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-0-将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。"><span class="nav-number">18.2.0.19.</span> <span class="nav-text">2.3.0 将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。"><span class="nav-number">18.2.0.20.</span> <span class="nav-text">2.3.1 将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-以下属于物理层的设备是？"><span class="nav-number">18.2.0.21.</span> <span class="nav-text">2.3.2 以下属于物理层的设备是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-在以太网中，是根据（）地址来区分不同的设备的？"><span class="nav-number">18.2.0.22.</span> <span class="nav-text">2.3.3 在以太网中，是根据（）地址来区分不同的设备的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-以下为传输层协议的是？"><span class="nav-number">18.2.0.23.</span> <span class="nav-text">2.3.4 以下为传输层协议的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-以下对MAC地址描述正确的是？"><span class="nav-number">18.2.0.24.</span> <span class="nav-text">2.3.5 以下对MAC地址描述正确的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-以下属于数据链路层功能的是？"><span class="nav-number">18.2.0.25.</span> <span class="nav-text">2.3.6 以下属于数据链路层功能的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-7-IEEE802-3u标准是指？"><span class="nav-number">18.2.0.26.</span> <span class="nav-text">2.3.7 IEEE802.3u标准是指？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-8-如果要将两计算机通过双绞线直接连接，正确的线序是？"><span class="nav-number">18.2.0.27.</span> <span class="nav-text">2.3.8 如果要将两计算机通过双绞线直接连接，正确的线序是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-9-在V-35和V-24规程中，控制信号RTS表示？"><span class="nav-number">18.2.0.28.</span> <span class="nav-text">2.3.9 在V.35和V.24规程中，控制信号RTS表示？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-0-路由器作为网络互连设备，必须具备以下哪些特点？"><span class="nav-number">18.2.0.29.</span> <span class="nav-text">2.4.0 路由器作为网络互连设备，必须具备以下哪些特点？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-路由器的作用有？"><span class="nav-number">18.2.0.30.</span> <span class="nav-text">2.4.1 路由器的作用有？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-调用上一条历史命令的快捷键是？"><span class="nav-number">18.2.0.31.</span> <span class="nav-text">2.4.2 调用上一条历史命令的快捷键是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-3-交换机工作在OSI七层的哪一层？"><span class="nav-number">18.2.0.32.</span> <span class="nav-text">2.4.3 交换机工作在OSI七层的哪一层？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-4-以下对CSMA-CD描述正确的是？"><span class="nav-number">18.2.0.33.</span> <span class="nav-text">2.4.4 以下对CSMA/CD描述正确的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-5-以下对STORE-ANDFORWARD描述正确的是？"><span class="nav-number">18.2.0.34.</span> <span class="nav-text">2.4.5 以下对STORE ANDFORWARD描述正确的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-6-以下对交换机工作方式描述正确的是？"><span class="nav-number">18.2.0.35.</span> <span class="nav-text">2.4.6 以下对交换机工作方式描述正确的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-7-VLAN的主要作用有？"><span class="nav-number">18.2.0.36.</span> <span class="nav-text">2.4.7 VLAN的主要作用有？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-8-在交换机中用户权限分为几个级别？"><span class="nav-number">18.2.0.37.</span> <span class="nav-text">2.4.8 在交换机中用户权限分为几个级别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-9-在路由器的配置过程中查询以S开头所有命令的方法是？"><span class="nav-number">18.2.0.38.</span> <span class="nav-text">2.4.9 在路由器的配置过程中查询以S开头所有命令的方法是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-0-第一次配置路由器时可以使用的方法为？"><span class="nav-number">18.2.0.39.</span> <span class="nav-text">2.5.0 第一次配置路由器时可以使用的方法为？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-1-在何种状态下可以为路由器改名？"><span class="nav-number">18.2.0.40.</span> <span class="nav-text">2.5.1 在何种状态下可以为路由器改名？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有-26台计算机，每个子公司在一个网段中，则子网掩码应设为？"><span class="nav-number">18.2.0.41.</span> <span class="nav-text">2.5.2 某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-与10-110-12-29mask-255-255-255-224属于同一网段的主机IP地址是？"><span class="nav-number">18.2.0.42.</span> <span class="nav-text">2.5.3 与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-4-ARP协议的作用是？"><span class="nav-number">18.2.0.43.</span> <span class="nav-text">2.5.4 ARP协议的作用是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-5-当路由器接收的IP报文的TTL值等于1时，采取的策略是？"><span class="nav-number">18.2.0.44.</span> <span class="nav-text">2.5.5 当路由器接收的IP报文的TTL值等于1时，采取的策略是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-6-在NetWare-网络中，客户需要访问某个类型的服务器时，首先要发送一个-（）广播报文来寻找服务器？"><span class="nav-number">18.2.0.45.</span> <span class="nav-text">2.5.6 在NetWare 网络中，客户需要访问某个类型的服务器时，首先要发送一个 （）广播报文来寻找服务器？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-7-IPX地址网络地址有（-）个字节？"><span class="nav-number">18.2.0.46.</span> <span class="nav-text">2.5.7 IPX地址网络地址有（ ）个字节？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-8-对于帧中继描述正确的是？"><span class="nav-number">18.2.0.47.</span> <span class="nav-text">2.5.8 对于帧中继描述正确的是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-9-对于INVERSE-ARP的描述正确的是？"><span class="nav-number">18.2.0.48.</span> <span class="nav-text">2.5.9 对于INVERSE ARP的描述正确的是？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">18.3.</span> <span class="nav-text">百度篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-0-在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？"><span class="nav-number">18.3.0.1.</span> <span class="nav-text">3.1.0 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-C-中引用与指针的区别"><span class="nav-number">18.3.0.2.</span> <span class="nav-text">3.1.1 C++中引用与指针的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-C-C-程序的内存分区"><span class="nav-number">18.3.0.3.</span> <span class="nav-text">3.1.2 C/C++程序的内存分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-快速排序的思想、时间复杂度、实现以及优化方法"><span class="nav-number">18.3.0.4.</span> <span class="nav-text">3.1.3 快速排序的思想、时间复杂度、实现以及优化方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-4-IO模型——IO多路复用机制"><span class="nav-number">18.3.0.5.</span> <span class="nav-text">3.1.4 IO模型——IO多路复用机制?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-5-常用的Linux命令"><span class="nav-number">18.3.0.6.</span> <span class="nav-text">3.1.5 常用的Linux命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-6-C中变量的存储类型有哪些？"><span class="nav-number">18.3.0.7.</span> <span class="nav-text">3.1.6 C中变量的存储类型有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-7-动态规划的本质"><span class="nav-number">18.3.0.8.</span> <span class="nav-text">3.1.7 动态规划的本质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-实践中如何优化MySQL"><span class="nav-number">18.3.0.9.</span> <span class="nav-text">3.1.8 实践中如何优化MySQL?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-9-什么情况下设置了索引但无法使用"><span class="nav-number">18.3.0.10.</span> <span class="nav-text">3.1.9 什么情况下设置了索引但无法使用?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-0-SQL语句的优化"><span class="nav-number">18.3.0.11.</span> <span class="nav-text">3.2.0 SQL语句的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-数据库索引的底层实现原理和优化"><span class="nav-number">18.3.0.12.</span> <span class="nav-text">3.2.1 数据库索引的底层实现原理和优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-HTTP和HTTPS的主要区别"><span class="nav-number">18.3.0.13.</span> <span class="nav-text">3.2.2 HTTP和HTTPS的主要区别?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-如何设计一个高并发的系统"><span class="nav-number">18.3.0.14.</span> <span class="nav-text">3.2.3 如何设计一个高并发的系统?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-两条相交的单向链表，如何求他们的第一个公共节点"><span class="nav-number">18.3.0.15.</span> <span class="nav-text">3.2.4 两条相交的单向链表，如何求他们的第一个公共节点?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-求单向局部循环链表的环入口"><span class="nav-number">18.3.0.16.</span> <span class="nav-text">3.2.5 求单向局部循环链表的环入口?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-6-IP地址如何在数据库中存储"><span class="nav-number">18.3.0.17.</span> <span class="nav-text">3.2.6 IP地址如何在数据库中存储?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-7-new-delete和malloc-free的底层实现"><span class="nav-number">18.3.0.18.</span> <span class="nav-text">3.2.7 new/delete和malloc/free的底层实现?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-8-overload、override、overwrite的介绍"><span class="nav-number">18.3.0.19.</span> <span class="nav-text">3.2.8 overload、override、overwrite的介绍?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-9-小端-大端机器"><span class="nav-number">18.3.0.20.</span> <span class="nav-text">3.2.9 小端/大端机器?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-0-守护进程"><span class="nav-number">18.3.0.21.</span> <span class="nav-text">3.3.0 守护进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-多线程的优缺点"><span class="nav-number">18.3.0.22.</span> <span class="nav-text">3.3.1 多线程的优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-长连接与短连接"><span class="nav-number">18.3.0.23.</span> <span class="nav-text">3.3.2 长连接与短连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）"><span class="nav-number">18.3.0.24.</span> <span class="nav-text">3.3.3 二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-class与struct的区别？"><span class="nav-number">18.3.0.25.</span> <span class="nav-text">3.3.4 class与struct的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-5-虚函数和纯虚函数"><span class="nav-number">18.3.0.26.</span> <span class="nav-text">3.3.5 虚函数和纯虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-6-menset-函数"><span class="nav-number">18.3.0.27.</span> <span class="nav-text">3.3.6 menset()函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-7-实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。"><span class="nav-number">18.3.0.28.</span> <span class="nav-text">3.3.7 实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-8-找到满足条件的数组"><span class="nav-number">18.3.0.29.</span> <span class="nav-text">3.3.8 找到满足条件的数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-9-一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL"><span class="nav-number">18.3.0.30.</span> <span class="nav-text">3.3.9 一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-0-海量日志数据，提取出某日访问百度次数最多的那个IP"><span class="nav-number">18.3.0.31.</span> <span class="nav-text">3.4.0 海量日志数据，提取出某日访问百度次数最多的那个IP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？"><span class="nav-number">18.3.0.32.</span> <span class="nav-text">3.4.1 有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-蚂蚁爬杆问题"><span class="nav-number">18.3.0.33.</span> <span class="nav-text">3.4.2 蚂蚁爬杆问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-3-当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？"><span class="nav-number">18.3.0.34.</span> <span class="nav-text">3.4.3 当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-4-判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度"><span class="nav-number">18.3.0.35.</span> <span class="nav-text">3.4.4 判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-5-三个警察和三个囚徒的过河问题"><span class="nav-number">18.3.0.36.</span> <span class="nav-text">3.4.5 三个警察和三个囚徒的过河问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-6-从300万字符串中找到最热门的10条"><span class="nav-number">18.3.0.37.</span> <span class="nav-text">3.4.6 从300万字符串中找到最热门的10条</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-7-如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？"><span class="nav-number">18.3.0.38.</span> <span class="nav-text">3.4.7 如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-8-找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O-n-的复杂度的算法找出这个数。"><span class="nav-number">18.3.0.39.</span> <span class="nav-text">3.4.8 找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-9-找出被修改过的数字"><span class="nav-number">18.3.0.40.</span> <span class="nav-text">3.4.9 找出被修改过的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-0-设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）"><span class="nav-number">18.3.0.41.</span> <span class="nav-text">3.5.0 设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-找出给定字符串对应的序号"><span class="nav-number">18.3.0.42.</span> <span class="nav-text">3.5.1 找出给定字符串对应的序号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如-2，4，3，4，7-中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。"><span class="nav-number">18.3.0.43.</span> <span class="nav-text">3.5.2 找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-3-给40亿个不重复的unsigned-int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中"><span class="nav-number">18.3.0.44.</span> <span class="nav-text">3.5.3 给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-4-在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。"><span class="nav-number">18.3.0.45.</span> <span class="nav-text">3.5.4 在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-5-时分秒针在一天之类重合多少次？（24小时）"><span class="nav-number">18.3.0.46.</span> <span class="nav-text">3.5.5 时分秒针在一天之类重合多少次？（24小时）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-6-将多个集合合并成没有交集的集合。"><span class="nav-number">18.3.0.47.</span> <span class="nav-text">3.5.6 将多个集合合并成没有交集的集合。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-7-平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？"><span class="nav-number">18.3.0.48.</span> <span class="nav-text">3.5.7 平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4"><span class="nav-number">18.4.</span> <span class="nav-text">腾讯篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java基础"><span class="nav-number">18.4.1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。"><span class="nav-number">18.4.1.1.</span> <span class="nav-text">4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-String类能被继承吗，为什么。"><span class="nav-number">18.4.1.2.</span> <span class="nav-text">4.1.1 String类能被继承吗，为什么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2-String，Stringbuffer，StringBuilder的区别。"><span class="nav-number">18.4.1.3.</span> <span class="nav-text">4.1.2 String，Stringbuffer，StringBuilder的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3-ArrayList和LinkedList有什么区别。"><span class="nav-number">18.4.1.4.</span> <span class="nav-text">4.1.3 ArrayList和LinkedList有什么区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><span class="nav-number">18.4.1.5.</span> <span class="nav-text">4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><span class="nav-number">18.4.1.6.</span> <span class="nav-text">4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><span class="nav-number">18.4.1.7.</span> <span class="nav-text">4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><span class="nav-number">18.4.1.8.</span> <span class="nav-text">4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><span class="nav-number">18.4.1.9.</span> <span class="nav-text">4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-9-继承和聚合的区别在哪。"><span class="nav-number">18.4.1.10.</span> <span class="nav-text">4.1.9 继承和聚合的区别在哪。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。"><span class="nav-number">18.4.1.11.</span> <span class="nav-text">4.2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-反射的原理，反射创建类实例的三种方式是什么。"><span class="nav-number">18.4.1.12.</span> <span class="nav-text">4.2.1 反射的原理，反射创建类实例的三种方式是什么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-反射中，Class-forName和ClassLoader区别-。"><span class="nav-number">18.4.1.13.</span> <span class="nav-text">4.2.2 反射中，Class.forName和ClassLoader区别 。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。"><span class="nav-number">18.4.1.14.</span> <span class="nav-text">4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-4-动态代理与cglib实现的区别。"><span class="nav-number">18.4.1.15.</span> <span class="nav-text">4.2.4 动态代理与cglib实现的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-5-为什么CGlib方式可以对接口实现代理。"><span class="nav-number">18.4.1.16.</span> <span class="nav-text">4.2.5 为什么CGlib方式可以对接口实现代理。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-6-final的用途。"><span class="nav-number">18.4.1.17.</span> <span class="nav-text">4.2.6 final的用途。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-7-写出三种单例模式实现-。"><span class="nav-number">18.4.1.18.</span> <span class="nav-text">4.2.7 写出三种单例模式实现 。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><span class="nav-number">18.4.1.19.</span> <span class="nav-text">4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><span class="nav-number">18.4.1.20.</span> <span class="nav-text">4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-0-深拷贝和浅拷贝区别。"><span class="nav-number">18.4.1.21.</span> <span class="nav-text">4.3.0 深拷贝和浅拷贝区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-数组和链表数据结构描述，各自的时间复杂度。"><span class="nav-number">18.4.1.22.</span> <span class="nav-text">4.3.1 数组和链表数据结构描述，各自的时间复杂度。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-error和exception的区别，CheckedException，RuntimeException的区别。"><span class="nav-number">18.4.1.23.</span> <span class="nav-text">4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3-请列出5个运行时异常。"><span class="nav-number">18.4.1.24.</span> <span class="nav-text">4.3.3 请列出5个运行时异常。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><span class="nav-number">18.4.1.25.</span> <span class="nav-text">4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><span class="nav-number">18.4.1.26.</span> <span class="nav-text">4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><span class="nav-number">18.4.1.27.</span> <span class="nav-text">4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。"><span class="nav-number">18.4.1.28.</span> <span class="nav-text">4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-8-有没有可能2个不相等的对象有相同的hashcode。"><span class="nav-number">18.4.1.29.</span> <span class="nav-text">4.3.8 有没有可能2个不相等的对象有相同的hashcode。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-9-Java中的HashSet内部是如何工作的。"><span class="nav-number">18.4.1.30.</span> <span class="nav-text">4.3.9 Java中的HashSet内部是如何工作的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><span class="nav-number">18.4.1.31.</span> <span class="nav-text">4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-java8的新特性。"><span class="nav-number">18.4.1.32.</span> <span class="nav-text">4.4.1 java8的新特性。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM"><span class="nav-number">18.4.2.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-什么情况下会发生栈内存溢出。"><span class="nav-number">18.4.2.1.</span> <span class="nav-text">4.4.2 什么情况下会发生栈内存溢出。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-JVM的内存结构，Eden和Survivor比例。"><span class="nav-number">18.4.2.2.</span> <span class="nav-text">4.4.3 JVM的内存结构，Eden和Survivor比例。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-4-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><span class="nav-number">18.4.2.3.</span> <span class="nav-text">4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-5-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><span class="nav-number">18.4.2.4.</span> <span class="nav-text">4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-6-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><span class="nav-number">18.4.2.5.</span> <span class="nav-text">4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-7-垃圾回收算法的实现原理。"><span class="nav-number">18.4.2.6.</span> <span class="nav-text">4.4.7 垃圾回收算法的实现原理。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-8-当出现了内存溢出，你怎么排错。"><span class="nav-number">18.4.2.7.</span> <span class="nav-text">4.4.8 当出现了内存溢出，你怎么排错。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-9-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><span class="nav-number">18.4.2.8.</span> <span class="nav-text">4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-0-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><span class="nav-number">18.4.2.9.</span> <span class="nav-text">4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-1-讲讲JAVA的反射机制。"><span class="nav-number">18.4.2.10.</span> <span class="nav-text">4.5.1 讲讲JAVA的反射机制。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-你们线上应用的JVM参数有哪些。"><span class="nav-number">18.4.2.11.</span> <span class="nav-text">4.5.2 你们线上应用的JVM参数有哪些。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。"><span class="nav-number">18.4.2.12.</span> <span class="nav-text">4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-4-怎么打出线程栈信息。"><span class="nav-number">18.4.2.13.</span> <span class="nav-text">4.5.4 怎么打出线程栈信息。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开源框架"><span class="nav-number">18.4.3.</span> <span class="nav-text">开源框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-5-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"><span class="nav-number">18.4.3.1.</span> <span class="nav-text">4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-6-tomcat如何调优，涉及哪些参数-。"><span class="nav-number">18.4.3.2.</span> <span class="nav-text">4.5.6 tomcat如何调优，涉及哪些参数 。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-7-讲讲Spring加载流程。"><span class="nav-number">18.4.3.3.</span> <span class="nav-text">4.5.7 讲讲Spring加载流程。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-8-Spring-AOP的实现原理。"><span class="nav-number">18.4.3.4.</span> <span class="nav-text">4.5.8 Spring AOP的实现原理。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-9-讲讲Spring事务的传播属性。"><span class="nav-number">18.4.3.5.</span> <span class="nav-text">4.5.9 讲讲Spring事务的传播属性。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-0-Spring如何管理事务的。"><span class="nav-number">18.4.3.6.</span> <span class="nav-text">4.6.0 Spring如何管理事务的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-1-Spring怎么配置事务（具体说出一些关键的xml-元素）。"><span class="nav-number">18.4.3.7.</span> <span class="nav-text">4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-2-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。"><span class="nav-number">18.4.3.8.</span> <span class="nav-text">4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-3-Springmvc-中DispatcherServlet初始化过程。"><span class="nav-number">18.4.3.9.</span> <span class="nav-text">4.6.3 Springmvc 中DispatcherServlet初始化过程。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-4-netty的线程模型，netty如何基于reactor模型上实现的。"><span class="nav-number">18.4.3.10.</span> <span class="nav-text">4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-5-为什么选择netty。"><span class="nav-number">18.4.3.11.</span> <span class="nav-text">4.6.5 为什么选择netty。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-6-什么是TCP粘包，拆包。解决方式是什么。"><span class="nav-number">18.4.3.12.</span> <span class="nav-text">4.6.6 什么是TCP粘包，拆包。解决方式是什么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-7-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"><span class="nav-number">18.4.3.13.</span> <span class="nav-text">4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-8-netty的心跳处理在弱网下怎么办。"><span class="nav-number">18.4.3.14.</span> <span class="nav-text">4.6.8 netty的心跳处理在弱网下怎么办。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-9-netty的通讯协议是什么样的。"><span class="nav-number">18.4.3.15.</span> <span class="nav-text">4.6.9 netty的通讯协议是什么样的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-0-springmvc用到的注解，作用是什么，原理。"><span class="nav-number">18.4.3.16.</span> <span class="nav-text">4.7.0 springmvc用到的注解，作用是什么，原理。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-1-springboot启动机制。"><span class="nav-number">18.4.3.17.</span> <span class="nav-text">4.7.1 springboot启动机制。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统"><span class="nav-number">18.4.4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-2-Linux系统下你关注过哪些内核参数，说说你知道的。"><span class="nav-number">18.4.4.1.</span> <span class="nav-text">4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-3-Linux下IO模型有几种，各自的含义是什么。"><span class="nav-number">18.4.4.2.</span> <span class="nav-text">4.7.3 Linux下IO模型有几种，各自的含义是什么。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-4-epoll和poll有什么区别。"><span class="nav-number">18.4.4.3.</span> <span class="nav-text">4.7.4 epoll和poll有什么区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-5-平时用到哪些Linux命令。"><span class="nav-number">18.4.4.4.</span> <span class="nav-text">4.7.5 平时用到哪些Linux命令。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-6-用一行命令查看文件的最后五行。"><span class="nav-number">18.4.4.5.</span> <span class="nav-text">4.7.6 用一行命令查看文件的最后五行。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-7-用一行命令输出正在运行的java进程。"><span class="nav-number">18.4.4.6.</span> <span class="nav-text">4.7.7 用一行命令输出正在运行的java进程。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-8-介绍下你理解的操作系统中线程切换过程。"><span class="nav-number">18.4.4.7.</span> <span class="nav-text">4.7.8 介绍下你理解的操作系统中线程切换过程。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-9-进程和线程的区别。"><span class="nav-number">18.4.4.8.</span> <span class="nav-text">4.7.9 进程和线程的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-8-0-top-命令之后有哪些内容，有什么作用。"><span class="nav-number">18.4.4.9.</span> <span class="nav-text">4.8.0 top 命令之后有哪些内容，有什么作用。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-8-1-线上CPU爆高，请问你如何找到问题所在。"><span class="nav-number">18.4.4.10.</span> <span class="nav-text">4.8.1 线上CPU爆高，请问你如何找到问题所在。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5"><span class="nav-number">18.5.</span> <span class="nav-text">美团篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-0-java虚拟机内存模型"><span class="nav-number">18.5.0.1.</span> <span class="nav-text">5.1.0 java虚拟机内存模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-1-内存溢出一般发生在哪个区？永久代会不会导致内存溢出？"><span class="nav-number">18.5.0.2.</span> <span class="nav-text">5.1.1 内存溢出一般发生在哪个区？永久代会不会导致内存溢出？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-动态加载类的框架了解哪些？"><span class="nav-number">18.5.0.3.</span> <span class="nav-text">5.1.2 动态加载类的框架了解哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-3-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？"><span class="nav-number">18.5.0.4.</span> <span class="nav-text">5.1.3 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-4-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？"><span class="nav-number">18.5.0.5.</span> <span class="nav-text">5.1.4 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-5-用过哪些命令查看jvm的状态、堆栈信息？"><span class="nav-number">18.5.0.6.</span> <span class="nav-text">5.1.5 用过哪些命令查看jvm的状态、堆栈信息？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-6-jvm的垃圾回收机制？"><span class="nav-number">18.5.0.7.</span> <span class="nav-text">5.1.6 jvm的垃圾回收机制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-7-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？"><span class="nav-number">18.5.0.8.</span> <span class="nav-text">5.1.7 java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-8-String、StringBuffer、StringBuilder的区别？对应的使用场景？"><span class="nav-number">18.5.0.9.</span> <span class="nav-text">5.1.8 String、StringBuffer、StringBuilder的区别？对应的使用场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-9-如何实现不可变的类？"><span class="nav-number">18.5.0.10.</span> <span class="nav-text">5.1.9 如何实现不可变的类？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-0-浅复制和深复制？怎样实现深复制？"><span class="nav-number">18.5.0.11.</span> <span class="nav-text">5.2.0 浅复制和深复制？怎样实现深复制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-HashMap、HashTable、ConcurrentHashMap的区别？"><span class="nav-number">18.5.0.12.</span> <span class="nav-text">5.2.1 HashMap、HashTable、ConcurrentHashMap的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-CAS是一种什么样的同步机制？"><span class="nav-number">18.5.0.13.</span> <span class="nav-text">5.2.2 CAS是一种什么样的同步机制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-NIO的原理，包括哪几个组件？"><span class="nav-number">18.5.0.14.</span> <span class="nav-text">5.2.3 NIO的原理，包括哪几个组件？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-4-简单介绍一下java的反射机制？反射在哪些地方有应用场景？"><span class="nav-number">18.5.0.15.</span> <span class="nav-text">5.2.4 简单介绍一下java的反射机制？反射在哪些地方有应用场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-spring加载bean的流程？"><span class="nav-number">18.5.0.16.</span> <span class="nav-text">5.2.5 spring加载bean的流程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-6-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？"><span class="nav-number">18.5.0.17.</span> <span class="nav-text">5.2.6 java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-7-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？"><span class="nav-number">18.5.0.18.</span> <span class="nav-text">5.2.7 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-8-CountDownLatch和CyclicBarrier的区别？"><span class="nav-number">18.5.0.19.</span> <span class="nav-text">5.2.8 CountDownLatch和CyclicBarrier的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-9-线程加锁有哪些方式？synchronized和lock的区别？"><span class="nav-number">18.5.0.20.</span> <span class="nav-text">5.2.9 线程加锁有哪些方式？synchronized和lock的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-0-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？"><span class="nav-number">18.5.0.21.</span> <span class="nav-text">5.3.0 volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-mysql的存储引擎有哪几种？"><span class="nav-number">18.5.0.22.</span> <span class="nav-text">5.3.1 mysql的存储引擎有哪几种？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-sql优化有哪些着手点？组合索引的最左前缀原则的含义？"><span class="nav-number">18.5.0.23.</span> <span class="nav-text">5.3.2 sql优化有哪些着手点？组合索引的最左前缀原则的含义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-3-springmvc处理请求的流程？"><span class="nav-number">18.5.0.24.</span> <span class="nav-text">5.3.3 springmvc处理请求的流程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-4-spring的事务怎么使用？事务回滚？自定义异常？"><span class="nav-number">18.5.0.25.</span> <span class="nav-text">5.3.4 spring的事务怎么使用？事务回滚？自定义异常？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-脏读？幻读？"><span class="nav-number">18.5.0.26.</span> <span class="nav-text">5.3.5 脏读？幻读？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-6-tcp四次挥手的过程？TIME-WAIT为什么至少设置两倍的MSL时间？"><span class="nav-number">18.5.0.27.</span> <span class="nav-text">5.3.6 tcp四次挥手的过程？TIME_WAIT为什么至少设置两倍的MSL时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-7-get和post请求的区别？"><span class="nav-number">18.5.0.28.</span> <span class="nav-text">5.3.7 get和post请求的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-8-cookie和session的请求？"><span class="nav-number">18.5.0.29.</span> <span class="nav-text">5.3.8 cookie和session的请求？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-9-了解哪些开源的中间件？缓存？消息？分布式框架？"><span class="nav-number">18.5.0.30.</span> <span class="nav-text">5.3.9 了解哪些开源的中间件？缓存？消息？分布式框架？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-0-用到过哪些设计模式？单例模式的实现？"><span class="nav-number">18.5.0.31.</span> <span class="nav-text">5.4.0 用到过哪些设计模式？单例模式的实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-1-数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题"><span class="nav-number">18.5.0.32.</span> <span class="nav-text">5.4.1 数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-2-数据库的脏读，幻读，不可重复读出现的原因原理，解决办法"><span class="nav-number">18.5.0.33.</span> <span class="nav-text">5.4.2 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-3-数据库的隔离级别、MVCC"><span class="nav-number">18.5.0.34.</span> <span class="nav-text">5.4.3 数据库的隔离级别、MVCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-4-乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别"><span class="nav-number">18.5.0.35.</span> <span class="nav-text">5.4.4 乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-5-线程的生命周期"><span class="nav-number">18.5.0.36.</span> <span class="nav-text">5.4.5 线程的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-6-一致性hash算法原理与应用"><span class="nav-number">18.5.0.37.</span> <span class="nav-text">5.4.6 一致性hash算法原理与应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-7-CAP原则"><span class="nav-number">18.5.0.38.</span> <span class="nav-text">5.4.7 CAP原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-8-CAS操作"><span class="nav-number">18.5.0.39.</span> <span class="nav-text">5.4.8 CAS操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-9-分布式raft算法"><span class="nav-number">18.5.0.40.</span> <span class="nav-text">5.4.9 分布式raft算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6"><span class="nav-number">18.6.</span> <span class="nav-text">头条篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-0-5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。"><span class="nav-number">18.6.0.1.</span> <span class="nav-text">6.1.0 5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-1-给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。"><span class="nav-number">18.6.0.2.</span> <span class="nav-text">6.1.1 给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-2-一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？"><span class="nav-number">18.6.0.3.</span> <span class="nav-text">6.1.2 一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-3-一个乱序数组，求第K大的数。排序方式使用字典序。"><span class="nav-number">18.6.0.4.</span> <span class="nav-text">6.1.3 一个乱序数组，求第K大的数。排序方式使用字典序。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-4-一棵二叉树，求最大通路长度。（即最大左右子树高度之和）"><span class="nav-number">18.6.0.5.</span> <span class="nav-text">6.1.4 一棵二叉树，求最大通路长度。（即最大左右子树高度之和）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-进程和线程的区别，使用线程真的能节省时间？"><span class="nav-number">18.6.0.6.</span> <span class="nav-text">6.1.5 进程和线程的区别，使用线程真的能节省时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-6-go协程的调度方式，使用协程真的能节省时间？"><span class="nav-number">18.6.0.7.</span> <span class="nav-text">6.1.6 go协程的调度方式，使用协程真的能节省时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-7-水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？"><span class="nav-number">18.6.0.8.</span> <span class="nav-text">6.1.7 水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-8-有函数如下，输入1，返回什么？"><span class="nav-number">18.6.0.9.</span> <span class="nav-text">6.1.8 有函数如下，输入1，返回什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-9-设计http协议，A端发送-AAAA，至少让B端知道AAAA已发送完成。"><span class="nav-number">18.6.0.10.</span> <span class="nav-text">6.1.9 设计http协议，A端发送 AAAA，至少让B端知道AAAA已发送完成。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-0-流量总入口为api-gateway，api-gateway挂了会导致全部挂挂，用什么机制增大可用性？"><span class="nav-number">18.6.0.11.</span> <span class="nav-text">6.2.0 流量总入口为api_gateway，api_gateway挂了会导致全部挂挂，用什么机制增大可用性？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-1-mysql为什么要用b-树，不用平衡二叉树做索引结构？"><span class="nav-number">18.6.0.12.</span> <span class="nav-text">6.2.1 mysql为什么要用b+树，不用平衡二叉树做索引结构？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-2-创建数据库索引应该怎么考虑？"><span class="nav-number">18.6.0.13.</span> <span class="nav-text">6.2.2 创建数据库索引应该怎么考虑？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-3-使用int-做primary-key和使用string-有什么优劣？"><span class="nav-number">18.6.0.14.</span> <span class="nav-text">6.2.3 使用int 做primary key和使用string 有什么优劣？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-4-数据库分表的方法？"><span class="nav-number">18.6.0.15.</span> <span class="nav-text">6.2.4 数据库分表的方法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-5-表结构，订单纪录如下，写一个语句，求卖的最好的-top-10-product-id。"><span class="nav-number">18.6.0.16.</span> <span class="nav-text">6.2.5 表结构，订单纪录如下，写一个语句，求卖的最好的 top 10 product_id。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-6-微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？"><span class="nav-number">18.6.0.17.</span> <span class="nav-text">6.2.6 微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-7-不使用高级工具，只使用Linux自带的工具，你会如何debug"><span class="nav-number">18.6.0.18.</span> <span class="nav-text">6.2.7 不使用高级工具，只使用Linux自带的工具，你会如何debug?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-8-如何预估一个mysql语句的性能？"><span class="nav-number">18.6.0.19.</span> <span class="nav-text">6.2.8 如何预估一个mysql语句的性能？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-9-go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？"><span class="nav-number">18.6.0.20.</span> <span class="nav-text">6.2.9 go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-0-socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据-还是9-10次的数据会先到达？"><span class="nav-number">18.6.0.21.</span> <span class="nav-text">6.3.0 socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据?还是9-10次的数据会先到达？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-1-free-h，buffers-和cached有什么不同"><span class="nav-number">18.6.0.22.</span> <span class="nav-text">6.3.1 free -h，buffers 和cached有什么不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-2-后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么"><span class="nav-number">18.6.0.23.</span> <span class="nav-text">6.3.2 后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-3-僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程"><span class="nav-number">18.6.0.24.</span> <span class="nav-text">6.3.3 僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-4-孤儿进程是什么"><span class="nav-number">18.6.0.25.</span> <span class="nav-text">6.3.4 孤儿进程是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-5-一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？"><span class="nav-number">18.6.0.26.</span> <span class="nav-text">6.3.5 一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-6-tcp-ip-流量控制和拥塞控制"><span class="nav-number">18.6.0.27.</span> <span class="nav-text">6.3.6 tcp/ip 流量控制和拥塞控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-7-301-302有什么区别？应用上有什么异同。"><span class="nav-number">18.6.0.28.</span> <span class="nav-text">6.3.7 301/302有什么区别？应用上有什么异同。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-8-50X相关错误码的内涵是什么？"><span class="nav-number">18.6.0.29.</span> <span class="nav-text">6.3.8 50X相关错误码的内涵是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-9-close-wait和time-wait是什么？如何排查？有什么意义？"><span class="nav-number">18.6.0.30.</span> <span class="nav-text">6.3.9 close wait和time wait是什么？如何排查？有什么意义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-0-http-req和resp的中数据有哪些"><span class="nav-number">18.6.0.31.</span> <span class="nav-text">6.4.0 http req和resp的中数据有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-1-什么是连接的半打开，半关闭状态"><span class="nav-number">18.6.0.32.</span> <span class="nav-text">6.4.1 什么是连接的半打开，半关闭状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-2-假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进"><span class="nav-number">18.6.0.33.</span> <span class="nav-text">6.4.2 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-3-redis-sharding有哪些做法"><span class="nav-number">18.6.0.34.</span> <span class="nav-text">6.4.3 redis sharding有哪些做法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-4-当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案"><span class="nav-number">18.6.0.35.</span> <span class="nav-text">6.4.4 当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-5-当redis-采用hash做sharding，现在有8个节点，负载方案是-pos-hash-key-8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash-presharding）"><span class="nav-number">18.6.0.36.</span> <span class="nav-text">6.4.5 当redis 采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash, presharding）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-6-如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作-update-db-username-update-redis-username-。但是执行update-db后故障，update-redis没有执行。有什么简单办法解决这个问题。"><span class="nav-number">18.6.0.37.</span> <span class="nav-text">6.4.6 如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username); update_redis(username)。但是执行update_db后故障，update_redis没有执行。有什么简单办法解决这个问题。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7"><span class="nav-number">18.7.</span> <span class="nav-text">滴滴篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-0-B-树、B-树的区别"><span class="nav-number">18.7.0.1.</span> <span class="nav-text">7.1.0 B+树、B-树的区别?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-1-数据库隔离级别，幻读和不可重复读的区别？"><span class="nav-number">18.7.0.2.</span> <span class="nav-text">7.1.1 数据库隔离级别，幻读和不可重复读的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-2-有hell-well-hello-world等字符串组，现在问能否拼接成helloworld，代码实现。"><span class="nav-number">18.7.0.3.</span> <span class="nav-text">7.1.2 有hell, well, hello, world等字符串组，现在问能否拼接成helloworld，代码实现。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-3-快排算法实现"><span class="nav-number">18.7.0.4.</span> <span class="nav-text">7.1.3 快排算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-4-线程安全的单例模式"><span class="nav-number">18.7.0.5.</span> <span class="nav-text">7.1.4 线程安全的单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-5-25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？"><span class="nav-number">18.7.0.6.</span> <span class="nav-text">7.1.5 25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-6-kmp算法next数组的求解思路"><span class="nav-number">18.7.0.7.</span> <span class="nav-text">7.1.6 kmp算法next数组的求解思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-7-数组中有三个数字出现超过3-4，求这三个数字？"><span class="nav-number">18.7.0.8.</span> <span class="nav-text">7.1.7 数组中有三个数字出现超过3/4，求这三个数字？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-8-1到n-2个数组中缺了两个数，如何用O-n-时间，O-1-空间找到这两个数字。"><span class="nav-number">18.7.0.9.</span> <span class="nav-text">7.1.8 1到n+2个数组中缺了两个数，如何用O(n)时间，O(1)空间找到这两个数字。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-9-一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？"><span class="nav-number">18.7.0.10.</span> <span class="nav-text">7.1.9 一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-0-有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？"><span class="nav-number">18.7.0.11.</span> <span class="nav-text">7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-1-B-树做索引时，B-树通常高度为多少层？要参考哪些条件？"><span class="nav-number">18.7.0.12.</span> <span class="nav-text">7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8"><span class="nav-number">18.8.</span> <span class="nav-text">京东篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-0-一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。"><span class="nav-number">18.8.0.1.</span> <span class="nav-text">8.1.0 一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-1-masscan扫描端口时靠什么检测，为什么这么快-请详述"><span class="nav-number">18.8.0.2.</span> <span class="nav-text">8.1.1 masscan扫描端口时靠什么检测，为什么这么快? 请详述.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-2-你写过哪些小工具，你为你使用过的工具做过什么修改"><span class="nav-number">18.8.0.3.</span> <span class="nav-text">8.1.2 你写过哪些小工具，你为你使用过的工具做过什么修改.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-3-如何提高采用python编写的扫描速度，谈谈对GIL锁的了解"><span class="nav-number">18.8.0.4.</span> <span class="nav-text">8.1.3 如何提高采用python编写的扫描速度，谈谈对GIL锁的了解.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-4-你觉得你发现的那个漏洞影响比较大"><span class="nav-number">18.8.0.5.</span> <span class="nav-text">8.1.4 你觉得你发现的那个漏洞影响比较大.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-5-常见的web漏洞有哪些"><span class="nav-number">18.8.0.6.</span> <span class="nav-text">8.1.5 常见的web漏洞有哪些.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-6-有没有玩过硬件安全，研究程度如何"><span class="nav-number">18.8.0.7.</span> <span class="nav-text">8.1.6 有没有玩过硬件安全，研究程度如何.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-7-反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。-使用无头浏览器被检测到了，如何绕过"><span class="nav-number">18.8.0.8.</span> <span class="nav-text">8.1.7 反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。 使用无头浏览器被检测到了，如何绕过</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-8-nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手-如何不直接接触目标服务器探测对方端口是否开放"><span class="nav-number">18.8.0.9.</span> <span class="nav-text">8.1.8 nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手. 如何不直接接触目标服务器探测对方端口是否开放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-9-有没有自己编写过yara扫描模块，如果要解决扫描-k1-v1-k2-v2-k3-v3-，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3-v3。怎么实现"><span class="nav-number">18.8.0.10.</span> <span class="nav-text">8.1.9 有没有自己编写过yara扫描模块，如果要解决扫描{k1:v1, k2:v2, k3:v3} ，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3,v3。怎么实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-0-xss什么原理，如何自己实现一个beef类似的xss平台-既然这样实现，面临的跨域如何解决"><span class="nav-number">18.8.0.11.</span> <span class="nav-text">8.2.0 xss什么原理，如何自己实现一个beef类似的xss平台. 既然这样实现，面临的跨域如何解决?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-1-ip-频率限制-ip信誉度模型？"><span class="nav-number">18.8.0.12.</span> <span class="nav-text">8.2.1 ip 频率限制, ip信誉度模型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-2-SCTP协议是什么？如何使用-SCTP-优化网络？"><span class="nav-number">18.8.0.13.</span> <span class="nav-text">8.2.2 SCTP协议是什么？如何使用 SCTP 优化网络？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9"><span class="nav-number">18.9.</span> <span class="nav-text">mysql篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-0-主键-超键-候选键-外键"><span class="nav-number">18.9.0.1.</span> <span class="nav-text">9.1.0 主键 超键 候选键 外键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-1-数据库事务的四个特性及含义"><span class="nav-number">18.9.0.2.</span> <span class="nav-text">9.1.1 数据库事务的四个特性及含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-2-视图的作用，视图可以更改么？"><span class="nav-number">18.9.0.3.</span> <span class="nav-text">9.1.2 视图的作用，视图可以更改么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-3-drop-delete与truncate的区别"><span class="nav-number">18.9.0.4.</span> <span class="nav-text">9.1.3 drop,delete与truncate的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-4-索引的工作原理及其种类"><span class="nav-number">18.9.0.5.</span> <span class="nav-text">9.1.4 索引的工作原理及其种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-5-连接的种类"><span class="nav-number">18.9.0.6.</span> <span class="nav-text">9.1.5 连接的种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-6-数据库范式"><span class="nav-number">18.9.0.7.</span> <span class="nav-text">9.1.6 数据库范式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-7-数据库优化的思路"><span class="nav-number">18.9.0.8.</span> <span class="nav-text">9.1.7 数据库优化的思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-8-存储过程与触发器的区别"><span class="nav-number">18.9.0.9.</span> <span class="nav-text">9.1.8 存储过程与触发器的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10"><span class="nav-number">18.10.</span> <span class="nav-text">redis篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-1-redis相比memcached有哪些优势？"><span class="nav-number">18.10.0.1.</span> <span class="nav-text">10.1.1 redis相比memcached有哪些优势？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-2-redis常见性能问题和解决方案"><span class="nav-number">18.10.0.2.</span> <span class="nav-text">10.1.2 redis常见性能问题和解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-3-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><span class="nav-number">18.10.0.3.</span> <span class="nav-text">10.1.3 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-4-Memcache与Redis的区别都有哪些？"><span class="nav-number">18.10.0.4.</span> <span class="nav-text">10.1.4 Memcache与Redis的区别都有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-5-Redis-常见的性能问题都有哪些？如何解决？"><span class="nav-number">18.10.0.5.</span> <span class="nav-text">10.1.5 Redis 常见的性能问题都有哪些？如何解决？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-6-redis-最适合的场景"><span class="nav-number">18.10.0.6.</span> <span class="nav-text">10.1.6 redis 最适合的场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-7-Redis的同步机制了解么？"><span class="nav-number">18.10.0.7.</span> <span class="nav-text">10.1.7 Redis的同步机制了解么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-8-是否使用过Redis集群，集群的原理是什么？"><span class="nav-number">18.10.0.8.</span> <span class="nav-text">10.1.8 是否使用过Redis集群，集群的原理是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-9-redis集群如何保证一致性？"><span class="nav-number">18.10.0.9.</span> <span class="nav-text">10.1.9 redis集群如何保证一致性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11"><span class="nav-number">18.11.</span> <span class="nav-text">MongoDB篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-1-MongoDB是由哪种语言写的？"><span class="nav-number">18.11.0.1.</span> <span class="nav-text">11.1.1 MongoDB是由哪种语言写的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-2-MongoDB的优势有哪些？"><span class="nav-number">18.11.0.2.</span> <span class="nav-text">11.1.2 MongoDB的优势有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-3-什么是数据库？"><span class="nav-number">18.11.0.3.</span> <span class="nav-text">11.1.3 什么是数据库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-4-什么是集合？"><span class="nav-number">18.11.0.4.</span> <span class="nav-text">11.1.4 什么是集合？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-5-什么是文档？"><span class="nav-number">18.11.0.5.</span> <span class="nav-text">11.1.5 什么是文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-6-MongoDB和关系型数据库术语对比图"><span class="nav-number">18.11.0.6.</span> <span class="nav-text">11.1.6 MongoDB和关系型数据库术语对比图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-7-什么是“mongod”？"><span class="nav-number">18.11.0.7.</span> <span class="nav-text">11.1.7 什么是“mongod”？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-8-“mongod”参数有什么？"><span class="nav-number">18.11.0.8.</span> <span class="nav-text">11.1.8 “mongod”参数有什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-9-什么是“mongo”？"><span class="nav-number">18.11.0.9.</span> <span class="nav-text">11.1.9 什么是“mongo”？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-0-MongoDB哪个命令可以切换数据库？"><span class="nav-number">18.11.0.10.</span> <span class="nav-text">11.2.0 MongoDB哪个命令可以切换数据库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-1-什么是非关系型数据库？"><span class="nav-number">18.11.0.11.</span> <span class="nav-text">11.2.1 什么是非关系型数据库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-2-非关系型数据库有哪些类型？"><span class="nav-number">18.11.0.12.</span> <span class="nav-text">11.2.2 非关系型数据库有哪些类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-3-为什么用MOngoDB？"><span class="nav-number">18.11.0.13.</span> <span class="nav-text">11.2.3 为什么用MOngoDB？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-4-在哪些场景使用MongoDB？"><span class="nav-number">18.11.0.14.</span> <span class="nav-text">11.2.4 在哪些场景使用MongoDB？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-5-MongoDB中的命名空间是什么意思"><span class="nav-number">18.11.0.15.</span> <span class="nav-text">11.2.5 MongoDB中的命名空间是什么意思?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-6-哪些语言支持MongoDB"><span class="nav-number">18.11.0.16.</span> <span class="nav-text">11.2.6 哪些语言支持MongoDB?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-7-在MongoDB中如何创建一个新的数据库？"><span class="nav-number">18.11.0.17.</span> <span class="nav-text">11.2.7 在MongoDB中如何创建一个新的数据库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-8-在MongoDB中如何查看数据库列表？"><span class="nav-number">18.11.0.18.</span> <span class="nav-text">11.2.8 在MongoDB中如何查看数据库列表？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-9-MongoDB中的分片是什么意思？"><span class="nav-number">18.11.0.19.</span> <span class="nav-text">11.2.9 MongoDB中的分片是什么意思？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-0-如何查看使用MongoDB的连接？"><span class="nav-number">18.11.0.20.</span> <span class="nav-text">11.3.0 如何查看使用MongoDB的连接？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-1-什么是复制？"><span class="nav-number">18.11.0.21.</span> <span class="nav-text">11.3.1 什么是复制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-2-在MongoDB中如何在集合中插入一个文档？"><span class="nav-number">18.11.0.22.</span> <span class="nav-text">11.3.2 在MongoDB中如何在集合中插入一个文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-3-在MongoDB中如何除去一个数据库？"><span class="nav-number">18.11.0.23.</span> <span class="nav-text">11.3.3 在MongoDB中如何除去一个数据库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-4-在MongoDB中如何创建一个集合？"><span class="nav-number">18.11.0.24.</span> <span class="nav-text">11.3.4 在MongoDB中如何创建一个集合？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-5-在MongoDB中如何查看一个已经创建的集合？"><span class="nav-number">18.11.0.25.</span> <span class="nav-text">11.3.5 在MongoDB中如何查看一个已经创建的集合？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-6-在MongoDB中如何删除一个集合？"><span class="nav-number">18.11.0.26.</span> <span class="nav-text">11.3.6 在MongoDB中如何删除一个集合？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-7-为什么要在MongoDB中使用分析器？"><span class="nav-number">18.11.0.27.</span> <span class="nav-text">11.3.7 为什么要在MongoDB中使用分析器？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-8-MongoDB支持主键外键关系吗？"><span class="nav-number">18.11.0.28.</span> <span class="nav-text">11.3.8 MongoDB支持主键外键关系吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-9-MongoDB支持哪些数据类型？"><span class="nav-number">18.11.0.29.</span> <span class="nav-text">11.3.9 MongoDB支持哪些数据类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-0-为什么要在MongoDB中用”Code”数据类型？"><span class="nav-number">18.11.0.30.</span> <span class="nav-text">11.4.0 为什么要在MongoDB中用”Code”数据类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-1-为什么要在MongoDB中用”Regular-Expression”数据类型？"><span class="nav-number">18.11.0.31.</span> <span class="nav-text">11.4.1 为什么要在MongoDB中用”Regular Expression”数据类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-2-为什么在MongoDB中使用”Object-ID”数据类型？"><span class="nav-number">18.11.0.32.</span> <span class="nav-text">11.4.2 为什么在MongoDB中使用”Object ID”数据类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-3-如何在集合中插入一个文档？"><span class="nav-number">18.11.0.33.</span> <span class="nav-text">11.4.3 如何在集合中插入一个文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-4-“ObjectID”有哪些部分组成？"><span class="nav-number">18.11.0.34.</span> <span class="nav-text">11.4.4 “ObjectID”有哪些部分组成？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-5-在MongoDb中什么是索引？"><span class="nav-number">18.11.0.35.</span> <span class="nav-text">11.4.5 在MongoDb中什么是索引？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-6-如何添加索引？"><span class="nav-number">18.11.0.36.</span> <span class="nav-text">11.4.6 如何添加索引？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-7-MongoDB有哪些可替代产品？"><span class="nav-number">18.11.0.37.</span> <span class="nav-text">11.4.7 MongoDB有哪些可替代产品？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-8-如何查询集合中的文档？"><span class="nav-number">18.11.0.38.</span> <span class="nav-text">11.4.8 如何查询集合中的文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-9-用什么方法可以格式化输出结果？"><span class="nav-number">18.11.0.39.</span> <span class="nav-text">11.4.9 用什么方法可以格式化输出结果？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-0-如何使用”AND”或”OR”条件循环查询集合中的文档？"><span class="nav-number">18.11.0.40.</span> <span class="nav-text">11.5.0 如何使用”AND”或”OR”条件循环查询集合中的文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-1-在MongoDB中如何更新数据？"><span class="nav-number">18.11.0.41.</span> <span class="nav-text">11.5.1 在MongoDB中如何更新数据？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-2-如何删除文档？"><span class="nav-number">18.11.0.42.</span> <span class="nav-text">11.5.2 如何删除文档？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-3-在MongoDB中如何排序？"><span class="nav-number">18.11.0.43.</span> <span class="nav-text">11.5.3 在MongoDB中如何排序？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-4-什么是聚合？"><span class="nav-number">18.11.0.44.</span> <span class="nav-text">11.5.4 什么是聚合？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-5-在MongoDB中什么是副本集？"><span class="nav-number">18.11.0.45.</span> <span class="nav-text">11.5.5 在MongoDB中什么是副本集？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-5-6-Mongodb存储特性与内部原理"><span class="nav-number">18.11.0.46.</span> <span class="nav-text">11.5.6 Mongodb存储特性与内部原理?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12"><span class="nav-number">18.12.</span> <span class="nav-text">Zookeeper篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-1-zookeeper提供了什么？"><span class="nav-number">18.12.0.1.</span> <span class="nav-text">12.1.1 zookeeper提供了什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-2-zookeeper文件系统"><span class="nav-number">18.12.0.2.</span> <span class="nav-text">12.1.2 zookeeper文件系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-3-zookeeper的四种类型的znode"><span class="nav-number">18.12.0.3.</span> <span class="nav-text">12.1.3 zookeeper的四种类型的znode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-4-zookeeper通知机制"><span class="nav-number">18.12.0.4.</span> <span class="nav-text">12.1.4 zookeeper通知机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-5-zookeeper有哪些应用场景？"><span class="nav-number">18.12.0.5.</span> <span class="nav-text">12.1.5 zookeeper有哪些应用场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-6-zk的命名服务"><span class="nav-number">18.12.0.6.</span> <span class="nav-text">12.1.6 zk的命名服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-7-zk的配置管理服务"><span class="nav-number">18.12.0.7.</span> <span class="nav-text">12.1.7 zk的配置管理服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-8-zk的集群管理"><span class="nav-number">18.12.0.8.</span> <span class="nav-text">12.1.8 zk的集群管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-1-9-zk的分布式锁"><span class="nav-number">18.12.0.9.</span> <span class="nav-text">12.1.9 zk的分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-0-zk队列管理"><span class="nav-number">18.12.0.10.</span> <span class="nav-text">12.2.0 zk队列管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-1-zk数据复制"><span class="nav-number">18.12.0.11.</span> <span class="nav-text">12.2.1 zk数据复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-2-zk的工作原理"><span class="nav-number">18.12.0.12.</span> <span class="nav-text">12.2.2 zk的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-3-zk是如何保证事物的顺序一致性"><span class="nav-number">18.12.0.13.</span> <span class="nav-text">12.2.3 zk是如何保证事物的顺序一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-4-zk集群下server工作状态"><span class="nav-number">18.12.0.14.</span> <span class="nav-text">12.2.4 zk集群下server工作状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-5-zk是如何选举Leader的？"><span class="nav-number">18.12.0.15.</span> <span class="nav-text">12.2.5 zk是如何选举Leader的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-6-zk同步流程"><span class="nav-number">18.12.0.16.</span> <span class="nav-text">12.2.6 zk同步流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-7-分布式通知和协调"><span class="nav-number">18.12.0.17.</span> <span class="nav-text">12.2.7 分布式通知和协调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-2-8-zk的session机制"><span class="nav-number">18.12.0.18.</span> <span class="nav-text">12.2.8 zk的session机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13"><span class="nav-number">18.13.</span> <span class="nav-text">nginx篇</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-1-请列举Nginx的一些特性"><span class="nav-number">18.13.0.1.</span> <span class="nav-text">13.1.1 请列举Nginx的一些特性?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-2-请列举Nginx和Apache-之间的不同点"><span class="nav-number">18.13.0.2.</span> <span class="nav-text">13.1.2 请列举Nginx和Apache 之间的不同点?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-3-请解释Nginx如何处理HTTP请求。"><span class="nav-number">18.13.0.3.</span> <span class="nav-text">13.1.3 请解释Nginx如何处理HTTP请求。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-4-在Nginx中，如何使用未定义的服务器名称来阻止处理请求"><span class="nav-number">18.13.0.4.</span> <span class="nav-text">13.1.4 在Nginx中，如何使用未定义的服务器名称来阻止处理请求?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-5-使用“反向代理服务器”的优点是什么"><span class="nav-number">18.13.0.5.</span> <span class="nav-text">13.1.5 使用“反向代理服务器”的优点是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-6-请列举Nginx服务器的最佳用途。"><span class="nav-number">18.13.0.6.</span> <span class="nav-text">13.1.6 请列举Nginx服务器的最佳用途。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-7-请解释Nginx服务器上的Master和Worker进程分别是什么"><span class="nav-number">18.13.0.7.</span> <span class="nav-text">13.1.7 请解释Nginx服务器上的Master和Worker进程分别是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-8-请解释你如何通过不同于80的端口开启Nginx"><span class="nav-number">18.13.0.8.</span> <span class="nav-text">13.1.8 请解释你如何通过不同于80的端口开启Nginx?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-1-9-请解释是否有可能将Nginx的错误替换为502错误、503"><span class="nav-number">18.13.0.9.</span> <span class="nav-text">13.1.9  请解释是否有可能将Nginx的错误替换为502错误、503?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-0-在Nginx中，解释如何在URL中保留双斜线"><span class="nav-number">18.13.0.10.</span> <span class="nav-text">13.2.0 在Nginx中，解释如何在URL中保留双斜线?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-1-请解释ngx-http-upstream-module的作用是什么"><span class="nav-number">18.13.0.11.</span> <span class="nav-text">13.2.1 请解释ngx_http_upstream_module的作用是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-2-请解释什么是C10K问题，后来是怎么解决的？"><span class="nav-number">18.13.0.12.</span> <span class="nav-text">13.2.2 请解释什么是C10K问题，后来是怎么解决的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-3-请陈述stub-status和sub-filter指令的作用是什么"><span class="nav-number">18.13.0.13.</span> <span class="nav-text">13.2.3 请陈述stub_status和sub_filter指令的作用是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-4-解释Nginx是否支持将请求压缩到上游"><span class="nav-number">18.13.0.14.</span> <span class="nav-text">13.2.4 解释Nginx是否支持将请求压缩到上游?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-5-解释如何在Nginx中获得当前的时间"><span class="nav-number">18.13.0.15.</span> <span class="nav-text">13.2.5 解释如何在Nginx中获得当前的时间?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-6-用Nginx服务器解释-s的目的是什么"><span class="nav-number">18.13.0.16.</span> <span class="nav-text">13.2.6 用Nginx服务器解释-s的目的是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-7-解释如何在Nginx服务器上添加模块"><span class="nav-number">18.13.0.17.</span> <span class="nav-text">13.2.7 解释如何在Nginx服务器上添加模块?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-8-nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？"><span class="nav-number">18.13.0.18.</span> <span class="nav-text">13.2.8 nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-2-9-nginx程序的热更新是如何做的？"><span class="nav-number">18.13.0.19.</span> <span class="nav-text">13.2.9 nginx程序的热更新是如何做的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深信服"><span class="nav-number">18.13.1.</span> <span class="nav-text">深信服</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/bolgzxy.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/bolgzxy.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
