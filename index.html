<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/12/字符串/手写字符串函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/12/字符串/手写字符串函数/" itemprop="url">手写字符串的库函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T00:00:00+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/bolgzxy.github.io/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="1、strcpy"><a href="#1、strcpy" class="headerlink" title="1、strcpy"></a>1、strcpy</h4><p><strong>函数作用：</strong>把 src 所指向的字符串复制到 dest。</p>
<p>注意：dest定义的空间应该比src大。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/bolgzxy.github.io/2019/09/12/字符串/手写字符串函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/设计模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:27:16+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题"><a href="#请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题" class="headerlink" title="请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题"></a>请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>常见的设计模式如下：</p>
<p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>单例模式的多线程安全问题：</p>
<p>在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：</p>
<p>1)饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475722008_A2BE64A5AC63C768998DF8A4AB546BE6" alt="img"></p>
<p>2)懒汉式：通过双重锁机制实现线程安全。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475744068_794C59674E8895ACAE32F19FCD4DF359" alt="img"></p>
<h2 id="●-请问你了解哪些设计模式？"><a href="#●-请问你了解哪些设计模式？" class="headerlink" title="● 请问你了解哪些设计模式？"></a>● 请问你了解哪些设计模式？</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>常见的设计模式如下：</p>
<p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>装饰器模式：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<h2 id="●-请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？"><a href="#●-请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？" class="headerlink" title="● 请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？"></a>● 请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>单例的实现主要是通过以下两个步骤：</p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p>单例模式的实现主要有两种一种是饿汉式，一种是懒汉式。饿汉式线程安全的单例模式如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475817756_0ABB4D7B05F0CEEF9D60F6FD5B1F4040" alt="img"></p>
<p>懒汉式线程安全的单例模式如下</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475838096_082BA455073278EBC75F86A1E72C3EBD" alt="img"></p>
<h2 id="●-请你说一说OOP的设计模式的五项原则"><a href="#●-请你说一说OOP的设计模式的五项原则" class="headerlink" title="● 请你说一说OOP的设计模式的五项原则"></a>● 请你说一说OOP的设计模式的五项原则</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、单一职责原则</p>
<p>单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。</p>
<p>2、接口隔离原则</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。</p>
<p>该原则观点如下：<br>1）一个类对另外一个类的依赖性应当是建立在最小的接口上</p>
<p>2）客户端程序不应该依赖它不需要的接口方法。</p>
<p>3、开放-封闭原则</p>
<p>open模块的行为必须是开放的、支持扩展的，而不是僵化的。</p>
<p>closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p>
<p>核心思想就是对抽象编程，而不对具体编程。</p>
<p>4、替换原则</p>
<p>子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。</p>
<p>主要针对继承的设计原则</p>
<p>1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的,方法定义或实现。</p>
<p>2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。</p>
<p>5、依赖倒置原则</p>
<p>上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。</p>
<p>抽象不能依赖于具体，具体应该要依赖于抽象。</p>
<h2 id="●-请你说说工厂模式的优点？"><a href="#●-请你说说工厂模式的优点？" class="headerlink" title="● 请你说说工厂模式的优点？"></a>● 请你说说工厂模式的优点？</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>解耦，代码复用，更改功能容易。</p>
<h2 id="●-请你说一下观察者模式"><a href="#●-请你说一下观察者模式" class="headerlink" title="● 请你说一下观察者模式"></a>● 请你说一下观察者模式</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。</p>
<h2 id="●-请你介绍一下单例模式"><a href="#●-请你介绍一下单例模式" class="headerlink" title="● 请你介绍一下单例模式"></a>● 请你介绍一下单例模式</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>C++的实现有两种，一种通过局部静态变量，利用其只初始化一次的特点，返回对象。另外一种，则是定义全局的指针，getInstance判断该指针是否为空，为空时才实例化对象</p>
<h2 id="●-单例模式中的懒汉加载，如果并发访问该怎么做？"><a href="#●-单例模式中的懒汉加载，如果并发访问该怎么做？" class="headerlink" title="● 单例模式中的懒汉加载，如果并发访问该怎么做？"></a>● 单例模式中的懒汉加载，如果并发访问该怎么做？</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。</p>
<h2 id="●-装饰器模式和单例模式，使用单例模式应该注意什么"><a href="#●-装饰器模式和单例模式，使用单例模式应该注意什么" class="headerlink" title="● 装饰器模式和单例模式，使用单例模式应该注意什么"></a>● 装饰器模式和单例模式，使用单例模式应该注意什么</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>考察点：设计模式</p>
<p>公司：百度</p>
<p>1、装饰器模式</p>
<p>装饰器模式主要是为了动态的为一个对象增加新的功能，装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p>2、单例模式</p>
<p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>实现：</p>
<p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p>
<p>单例的实现主要是通过以下两个步骤：</p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<p>3）单例模式举例（常手撕）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">SingleTon() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>SingleTon(const SingleTon&amp;) {}; // 禁止拷贝</p>
<p>SingleTon&amp; operator=(const SingleTon&amp;) {}; // 禁止赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`static` `T* uniqueInstance;``static` `pthread_mutex_t mutex;``public``:``static` `T* GetInstance()``&#123;``pthread_mutex_lock(&amp;mutex);``if` `(uniqueInstance == nullptr)``&#123;``uniqueInstance = ``new` `T();``&#125;``pthread_mutex_unlock(&amp;mutex);``return` `uniqueInstance;``&#125;``&#125;;``template` `&lt;``class` `T&gt;``pthread_mutex_t SingleTon&lt;T&gt;::mutex = PTHREAD_MUTEX_INITIALIZER;``template` `&lt;``class` `T&gt;``T* SingleTon&lt;T&gt;::uniqueInstance = nullptr;`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/排序/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:26:22+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你来手写一下快排的代码"><a href="#●-请你来手写一下快排的代码" class="headerlink" title="● 请你来手写一下快排的代码"></a>● 请你来手写一下快排的代码</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int` `once_quick_sort(vector&lt;``int``&gt; &amp;data, ``int` `left, ``int` `right)``&#123;``int` `key = data[left];``while` `(left &lt; right)``&#123;``while` `(left &lt; right &amp;&amp; key &lt;= data[right])``&#123;``right--;``&#125;``if` `(left &lt; right)``&#123;``data[left++] = data[right];``&#125;``while` `(left &lt; right &amp;&amp; key &gt; data[left])``&#123;``left++;``&#125;``if` `(left &lt; right)``&#123;``data[right--] = data[left];``&#125;``&#125;``data[left] = key;``return` `left;``&#125;``int` `quick_sort(vector&lt;``int``&gt; &amp; data, ``int` `left, ``int` `right)``&#123;``if` `(left &gt;= right )``&#123;``return` `1;``&#125;``int` `middle = 0;``middle = once_quick_sort(data, left, right);``quick_sort(data, left, middle-1);``quick_sort(data, middle + 1, right);``&#125;；`</span><br></pre></td></tr></table></figure>

<h2 id="●-请你手写一下快排的代码"><a href="#●-请你手写一下快排的代码" class="headerlink" title="● 请你手写一下快排的代码"></a>● 请你手写一下快排的代码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`nt once_quick_sort(vector&lt;``int``&gt; &amp;data, ``int` `left, ``int` `right)``&#123;``int` `key = data[left];``while` `(left &lt; right)``&#123;``while` `(left &lt; right &amp;&amp; key &lt;= data[right])``&#123;``right--;``&#125;``if` `(left &lt; right)``&#123;``data[left++] = data[right];``&#125;``while` `(left &lt; right &amp;&amp; key &gt; data[left])``&#123;``left++;``&#125;``if` `(left &lt; right)``&#123;``data[right--] = data[left];``&#125;``&#125;``data[left] = key;``return` `left;``&#125;``int` `quick_sort(vector&lt;``int``&gt; &amp; data, ``int` `left, ``int` `right)``&#123;``if` `(left &gt;= right )``&#123;``return` `1;``&#125;``int` `middle = 0;``middle = once_quick_sort(data, left, right);``quick_sort(data, left, middle-1);``quick_sort(data, middle + 1, right);``&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="●-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"><a href="#●-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素" class="headerlink" title="● 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"></a>● 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)</p>
<p>使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)</p>
<p>首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数</p>
<p>利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。</p>
<p>当有相同元素的时候，</p>
<p>首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)</p>
<h2 id="●-请你来介绍一下各种排序算法及时间复杂度"><a href="#●-请你来介绍一下各种排序算法及时间复杂度" class="headerlink" title="● 请你来介绍一下各种排序算法及时间复杂度"></a>● 请你来介绍一下各种排序算法及时间复杂度</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
<p>希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
<p>归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
<p>冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
<p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
<p>堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
<p>各个排序的时间复杂度、空间复杂度及稳定性如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt="img"></p>
<h2 id="●-请你说一说你知道的排序算法及其复杂度"><a href="#●-请你说一说你知道的排序算法及其复杂度" class="headerlink" title="● 请你说一说你知道的排序算法及其复杂度"></a>● 请你说一说你知道的排序算法及其复杂度</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、冒泡排序：</p>
<p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>2、插入排序：</p>
<p>从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>3、希尔排序（缩小增量排序）：</p>
<p>希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p>
<p>希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。</p>
<p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量d就为1。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n ^ 1.3)到O(n ^ 2)之间。</p>
<p>4、选择排序：</p>
<p>从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>5、快速排序</p>
<p>1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;</p>
<p>2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p>
<p>3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>6、堆排序：</p>
<p>堆：</p>
<p>1、完全二叉树或者是近似完全二叉树。</p>
<p>2、大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序。</p>
<p>堆排序在选择排序的基础上提出的，步骤：</p>
<p>1、建立堆</p>
<p>2、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>7、归并排序：</p>
<p>采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>8、计数排序：</p>
<p>思想：如果比元素x小的元素个数有n个，则元素x排序后位置为n+1。</p>
<p>步骤：</p>
<p>1）找出待排序的数组中最大的元素；</p>
<p>2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</p>
<p>3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</p>
<p>4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<p>稳定性：稳定</p>
<p>时间复杂度：O(n+k)，k是待排序数的范围。</p>
<p>9、桶排序：</p>
<p>步骤：</p>
<p>1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：</p>
<p>2）寻访序列，并且把记录一个一个放到对应的桶子去；</p>
<p>3）对每个不是空的桶子进行排序。</p>
<p>4）从不是空的桶子里把项目再放回原来的序列中。</p>
<p>时间复杂度：O(n+C) ，C为桶内排序时间。</p>
<h2 id="●-请问海量数据如何去取最大的k个"><a href="#●-请问海量数据如何去取最大的k个" class="headerlink" title="● 请问海量数据如何去取最大的k个"></a>● 请问海量数据如何去取最大的k个</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2.快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3.最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4.分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5.Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h2 id="●-请问快排的时间复杂度最差是多少？什么时候时间最差"><a href="#●-请问快排的时间复杂度最差是多少？什么时候时间最差" class="headerlink" title="● 请问快排的时间复杂度最差是多少？什么时候时间最差"></a>● 请问快排的时间复杂度最差是多少？什么时候时间最差</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>O（N2),元素本来倒序排列用时最多</p>
<h2 id="●-请问稳定排序哪几种？"><a href="#●-请问稳定排序哪几种？" class="headerlink" title="● 请问稳定排序哪几种？"></a>● 请问稳定排序哪几种？</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、快排算法</p>
<p>根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>2、稳定排序</p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>快排算法是不稳定的排序算法。例如：</p>
<p>待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};</p>
<p>若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序。</p>
<p>若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序也非原序。</p>
<p>3、快排最差情况推倒</p>
<p>在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦：</p>
<p>1）数组已经是正序排过序的。 （每次最右边的那个元素被选为枢轴）</p>
<p>2）数组已经是倒序排过序的。 （每次最左边的那个元素被选为枢轴）</p>
<p>3）所有的元素都相同（1、2的特殊情况）</p>
<p>因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。</p>
<p>快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2次）。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/数组/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:25:54+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你回答一下Array-amp-List，-数组和链表的区别"><a href="#●-请你回答一下Array-amp-List，-数组和链表的区别" class="headerlink" title="● 请你回答一下Array&amp;List， 数组和链表的区别"></a>● 请你回答一下Array&amp;List， 数组和链表的区别</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>数组的特点：</p>
<p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
<p>链表的特点：</p>
<p>链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p>
<p>各自的优缺点</p>
<p>数组的优点：</p>
<p>\1. 随机访问性强</p>
<p>\2. 查找速度快</p>
<p>数组的缺点:</p>
<p>\1. 插入和删除效率低</p>
<p>\2. 可能浪费内存</p>
<p>\3. 内存空间要求高，必须有足够的连续内存空间。</p>
<p>\4. 数组大小固定，不能动态拓展</p>
<p>链表的优点:</p>
<p>\1. 插入删除速度快</p>
<p>\2. 内存利用率高，不会浪费内存</p>
<p>\3. 大小没有固定，拓展很灵活。</p>
<p>链表的缺点:</p>
<p>不能随机查找，必须从第一个开始遍历，查找效率低</p>
<h2 id="●-一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码"><a href="#●-一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码" class="headerlink" title="● 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码"></a>● 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`bool` `IsDuplicateNumber(``int` `*array, ``int` `n)``&#123;``if``(array==NULL) ``return` `false``;``int` `i,temp;``for``(i=0;i&lt;n;i++)``&#123;``while``(array[i]!=i)``&#123;``if``(array[array[i]]==array[i])``return` `true``;``temp=array[array[i]];``array[array[i]]=array[i];``array[i]=temp;``&#125;``&#125;``return` `false``;``&#125;`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/堆与栈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/堆与栈/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:25:09+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><a href="#●-请说一说你理解的stack-overflow，并举个简单例子导致栈溢出" class="headerlink" title="● 请说一说你理解的stack overflow，并举个简单例子导致栈溢出"></a>● 请说一说你理解的stack overflow，并举个简单例子导致栈溢出</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>栈溢出概念：</p>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>栈溢出的原因：</p>
<p>\1. 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</p>
<p>\2. 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p>
<p>\3. 指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p>
<p>栈溢出例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">char buf[256];</span><br><span class="line">strcpy(buf,argv[1]);</span><br><span class="line">printf(&quot;Input:%s\n&quot;,buf);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。</p>
<h2 id="●-请你回答一下栈和堆的区别，以及为什么栈要快"><a href="#●-请你回答一下栈和堆的区别，以及为什么栈要快" class="headerlink" title="● 请你回答一下栈和堆的区别，以及为什么栈要快"></a>● 请你回答一下栈和堆的区别，以及为什么栈要快</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>堆和栈的区别：</p>
<p>堆是由低地址向高地址扩展；栈是由高地址向低地址扩展</p>
<p>堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存</p>
<p>堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片</p>
<p>堆的分配效率较低，而栈的分配效率较高</p>
<p>栈的效率高的原因：</p>
<p>栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
<h2 id="●-手写代码：两个栈实现一个队列"><a href="#●-手写代码：两个栈实现一个队列" class="headerlink" title="● 手写代码：两个栈实现一个队列"></a>● 手写代码：两个栈实现一个队列</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`class` `Solution``&#123;``public``:``void` `push(``int` `node) &#123;``stack1.push(node);``&#125;``int` `pop() &#123;``if``(stack2.size()!=0)&#123;``int` `tmp = stack2.top();``stack2.pop();``return` `tmp;``&#125;``else``&#123;``while``(stack1.size()!=0)&#123;``int` `tmp = stack1.top();``stack1.pop();``stack2.push(tmp);``&#125;``return` `pop();``&#125;``&#125;`  `private``:``stack&lt;``int``&gt; stack1;``stack&lt;``int``&gt; stack2;`` ``&#125;；`</span><br></pre></td></tr></table></figure>

<h2 id="●-请你来说一下堆和栈的区别"><a href="#●-请你来说一下堆和栈的区别" class="headerlink" title="● 请你来说一下堆和栈的区别"></a>● 请你来说一下堆和栈的区别</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）申请方式：</p>
<p>栈由系统自动分配和管理，堆由程序员手动分配和管理。</p>
<p>2）效率：</p>
<p>栈由系统分配，速度快，不会有内存碎片。</p>
<p>堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。</p>
<p>3）扩展方向</p>
<p>栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。</p>
<p>4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。</p>
<h2 id="●-请你说一说小根堆特点"><a href="#●-请你说一说小根堆特点" class="headerlink" title="● 请你说一说小根堆特点"></a>● 请你说一说小根堆特点</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p>
<p>1）小根堆</p>
<p>若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p>
<p>2）大根堆</p>
<p>若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/树/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:24:47+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你来说一说红黑树和AVL树的定义，特点，以及二者区别"><a href="#●-请你来说一说红黑树和AVL树的定义，特点，以及二者区别" class="headerlink" title="● 请你来说一说红黑树和AVL树的定义，特点，以及二者区别"></a>● 请你来说一说红黑树和AVL树的定义，特点，以及二者区别</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>平衡二叉树（AVL树）：</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>红黑树：</p>
<p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>区别：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h2 id="●-请你说一下哈夫曼编码"><a href="#●-请你说一下哈夫曼编码" class="headerlink" title="● 请你说一下哈夫曼编码"></a>● 请你说一下哈夫曼编码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1表示个字符的最优表示方式，其具体算法如下：</p>
<p>(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。</p>
<p>(2)算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。</p>
<p>(3)假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。</p>
<h2 id="●-请你回答一下map底层为什么用红黑树实现"><a href="#●-请你回答一下map底层为什么用红黑树实现" class="headerlink" title="● 请你回答一下map底层为什么用红黑树实现"></a>● 请你回答一下map底层为什么用红黑树实现</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、红黑树：</p>
<p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>2、平衡二叉树（AVL树）：</p>
<p>红黑树是在AVL树的基础上提出来的。</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<p>AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p>
<p>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>3、红黑树较AVL树的优点：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h2 id="●-请你介绍一下B-树"><a href="#●-请你介绍一下B-树" class="headerlink" title="● 请你介绍一下B+树"></a>● 请你介绍一下B+树</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键值的大小顺序存放在同一层的叶节点中。相比B树，其具有以下几个特点：</p>
<p>每个节点上的指针上限为2d而不是2d+1（d为节点的出度）</p>
<p>内节点不存储data,只存储key</p>
<p>叶子节点不存储指针</p>
<h2 id="●-请你说一说map和unordered-map的底层实现"><a href="#●-请你说一说map和unordered-map的底层实现" class="headerlink" title="● 请你说一说map和unordered_map的底层实现"></a>● 请你说一说map和unordered_map的底层实现</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p>
<h2 id="●-请你回答一下map和unordered-map优点和缺点"><a href="#●-请你回答一下map和unordered-map优点和缺点" class="headerlink" title="● 请你回答一下map和unordered_map优点和缺点"></a>● 请你回答一下map和unordered_map优点和缺点</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<p>1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</p>
<p>2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</p>
<p>缺点如下：</p>
<p>1）查找、删除、增加等操作平均时间复杂度较慢，与n相关</p>
<p>对于unordered_map来说，其底层是一个哈希表，优点如下：</p>
<p>查找、删除、添加的速度快，时间复杂度为常数级O(c)</p>
<p>缺点如下：</p>
<p>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</p>
<p>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</p>
<h2 id="●-请你回答一下epoll怎么实现的"><a href="#●-请你回答一下epoll怎么实现的" class="headerlink" title="● 请你回答一下epoll怎么实现的"></a>● 请你回答一下epoll怎么实现的</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<h2 id="●-请你说一说Top-K-问题"><a href="#●-请你说一说Top-K-问题" class="headerlink" title="● 请你说一说Top(K)问题"></a>● 请你说一说Top(K)问题</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2、快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3、最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4、分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5、Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h2 id="●-请你说一说C-两种map"><a href="#●-请你说一说C-两种map" class="headerlink" title="● 请你说一说C++两种map"></a>● 请你说一说C++两种map</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>unordered_map（哈希表)和map（红黑树）</p>
<h2 id="●-请问红黑树了解吗"><a href="#●-请问红黑树了解吗" class="headerlink" title="● 请问红黑树了解吗"></a>● 请问红黑树了解吗</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>参考博客<a href="https://blog.csdn.net/tanrui519521/article/details/80980135" target="_blank" rel="noopener">https://blog.csdn.net/tanrui519521/article/details/80980135</a></p>
<h2 id="●-请你说一说红黑树的性质还有左右旋转"><a href="#●-请你说一说红黑树的性质还有左右旋转" class="headerlink" title="● 请你说一说红黑树的性质还有左右旋转"></a>● 请你说一说红黑树的性质还有左右旋转</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>考察点：算法</p>
<p>公司：京东，阿里巴巴</p>
<p>1）平衡二叉树（AVL树）：</p>
<p>红黑树是在AVL树的基础上提出来的。</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<p>AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p>
<p>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>2）红黑树：</p>
<p>红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次，</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656203034_7D91838E6EBEB8036D6138A019A0AF1A" alt="img"></p>
<p>3）红黑树较AVL树的优点：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<p>4）红黑树旋转：</p>
<p>旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。</p>
<p>左旋：对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。<img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656212115_1587159E7ADB036880D502D2927B9597" alt="img"></p>
<p>右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。<img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656223637_991B891FAD560CB072639E0791F9CBB7" alt="img"></p>
<h2 id="●-请你实现二叉树的层序遍历并输出"><a href="#●-请你实现二叉树的层序遍历并输出" class="headerlink" title="● 请你实现二叉树的层序遍历并输出"></a>● 请你实现二叉树的层序遍历并输出</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><h2 id="●-手写代码：二叉树序列化反序列化"><a href="#●-手写代码：二叉树序列化反序列化" class="headerlink" title="● 手写代码：二叉树序列化反序列化"></a>● 手写代码：二叉树序列化反序列化</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>&gt; 序列化：必须保存一个中序遍历结果，然后外加一个前序或者后序遍历结果</p>
<p>&gt;反序列化：根据两次遍历生成的结果恢复二叉树，代码如下(前序和中序)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​````TreeNode* helper(vector&lt;int&gt;``pre``,int startPre,int endPre,vector&lt;int&gt;in,int startIn,int endIn)``&#123;``if(startPre&gt;endPre||startIn&gt;endIn)``return nullptr;``TreeNode * root=new TreeNode(``pre``[startPre]);``for(int i=startIn;i&lt;=endIn;++i)``&#123;``if(in[i]==``pre``[startPre])``&#123;``root-&gt;``left``=helper(``pre``,startPre+``1``,startPre+i-startIn,in,startIn,i``-1``);``root-&gt;``right``=helper(``pre``,i-startIn+startPre+``1``,endPre,in,i+``1``,endIn);``break;``&#125;``&#125;``return root;``&#125;``TreeNode* reConstructBinaryTree(vector&lt;int&gt; ``pre``,vector&lt;int&gt; vin)``&#123;``TreeNode *root=helper(``pre``,``0``,``pre``.size()``-1``,vin,``0``,vin.size()``-1``);``return root;``&#125;`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/数据库/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:23:57+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你说一说数据库索引"><a href="#●-请你说一说数据库索引" class="headerlink" title="● 请你说一说数据库索引"></a>● 请你说一说数据库索引</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
<h2 id="●-请你说一说数据库事务"><a href="#●-请你说一说数据库事务" class="headerlink" title="● 请你说一说数据库事务"></a>● 请你说一说数据库事务</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
<h2 id="●-请你说一说数据库事务隔离"><a href="#●-请你说一说数据库事务隔离" class="headerlink" title="● 请你说一说数据库事务隔离"></a>● 请你说一说数据库事务隔离</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h2 id="●-请你说一说inner-join和left-join"><a href="#●-请你说一说inner-join和left-join" class="headerlink" title="● 请你说一说inner join和left join"></a>● 请你说一说inner join和left join</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p>
<h2 id="●-请你聊一聊数据库事物的一致性"><a href="#●-请你聊一聊数据库事物的一致性" class="headerlink" title="● 请你聊一聊数据库事物的一致性"></a>● 请你聊一聊数据库事物的一致性</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>1）原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>2）一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3）隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p>
<p>不同的隔离级别：</p>
<p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p>
<p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p>
<p>4）持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="●-请你说说索引是什么，多加索引一定会好吗"><a href="#●-请你说说索引是什么，多加索引一定会好吗" class="headerlink" title="● 请你说说索引是什么，多加索引一定会好吗"></a>● 请你说说索引是什么，多加索引一定会好吗</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、索引</p>
<p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>缺点：</p>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p>2、添加索引原则</p>
<p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h2 id="●-请你说一下数据库事务以及四个特性"><a href="#●-请你说一下数据库事务以及四个特性" class="headerlink" title="● 请你说一下数据库事务以及四个特性"></a>● 请你说一下数据库事务以及四个特性</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>\1. 原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>\2. 一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>\3. 隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p>
<p>不同的隔离级别：</p>
<p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p>
<p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p>
<p>\4. 持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="●-请你说一说数据库的三大范式"><a href="#●-请你说一说数据库的三大范式" class="headerlink" title="● 请你说一说数据库的三大范式"></a>● 请你说一说数据库的三大范式</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
<h2 id="●-请你介绍一下数据库的ACID特性"><a href="#●-请你介绍一下数据库的ACID特性" class="headerlink" title="● 请你介绍一下数据库的ACID特性"></a>● 请你介绍一下数据库的ACID特性</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1)原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</p>
<p>2)一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<p>3)隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。</p>
<p>4)持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。</p>
<h2 id="●-请你说一说mysql的四种隔离状态"><a href="#●-请你说一说mysql的四种隔离状态" class="headerlink" title="● 请你说一说mysql的四种隔离状态"></a>● 请你说一说mysql的四种隔离状态</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Mysql主要包含四种隔离状态：</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="●-请你介绍一下mysql的MVCC机制"><a href="#●-请你介绍一下mysql的MVCC机制" class="headerlink" title="● 请你介绍一下mysql的MVCC机制"></a>● 请你介绍一下mysql的MVCC机制</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h2 id="●-请问SQL优化方法有哪些"><a href="#●-请问SQL优化方法有哪些" class="headerlink" title="● 请问SQL优化方法有哪些"></a>● 请问SQL优化方法有哪些</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>通过建立索引对查询进行优化</p>
<p>对查询进行优化，应尽量避免全表扫描</p>
<h2 id="●-请你说一下MySQL引擎和区别"><a href="#●-请你说一下MySQL引擎和区别" class="headerlink" title="● 请你说一下MySQL引擎和区别"></a>● 请你说一下MySQL引擎和区别</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、MySQL引擎</p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p>
<p>但是最常用的是InnoDB和Mylsam。</p>
<p>2、InnoDB</p>
<p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>适用场景：</p>
<p>经常更新的表，适合处理多重并发的更新请求。</p>
<p>支持事务。</p>
<p>可以从灾难中恢复（通过bin-log日志等）。</p>
<p>外键约束。只有他支持外键。</p>
<p>支持自动增加列属性auto_increment。</p>
<p>索引结构：</p>
<p>InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>3、Mylsam</p>
<p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p>
<p>适用场景：</p>
<p>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p>
<p>不支持外键的表设计。</p>
<p>查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p>
<p>整天对表进行加锁的场景。</p>
<p>MyISAM极度强调快速读取操作。</p>
<p>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p>缺点：就是不能在表损坏后主动恢复数据。</p>
<p>索引结构：</p>
<p>MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>
<p>3、InnoDB和Mylsam的区别：</p>
<p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/计算机网路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/计算机网路/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:22:27+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"><a href="#1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程" class="headerlink" title="1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"></a>1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程</h2><p>TCP保证可靠性：</p>
<p>（1）序列号、确认应答、超时重传</p>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<p>（3）拥塞控制</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
<p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
<p>TCP建立连接和断开连接的过程：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471554293_3A87D0457A6EE404083BBF3CB192C358" alt="img"></p>
<p>三次握手：</p>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p>四次挥手：</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<h2 id="2、-请你说一说TCP的模型，状态转移"><a href="#2、-请你说一说TCP的模型，状态转移" class="headerlink" title="2、 请你说一说TCP的模型，状态转移"></a>2、 请你说一说TCP的模型，状态转移</h2><p>四层TCP/IP模型如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471617097_2C832BB517B9ED772DCA7DCAD9AFBC75" alt="img"></p>
<p>其状态转移图如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4" alt="img"></p>
<h2 id="3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<p>HTTPS优点：</p>
<p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p>HTTPS缺点：</p>
<p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h2 id="4、-请你说一说HTTP和HTTPS的不同"><a href="#4、-请你说一说HTTP和HTTPS的不同" class="headerlink" title="4、 请你说一说HTTP和HTTPS的不同"></a>4、 请你说一说HTTP和HTTPS的不同</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<h2 id="5、请你说一说HTTP返回码"><a href="#5、请你说一说HTTP返回码" class="headerlink" title="5、请你说一说HTTP返回码"></a>5、请你说一说HTTP返回码</h2><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p>
<p>1xx：指示信息–表示请求已接收，继续处理。</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的详细说明如下。</p>
<p>200 OK：客户端请求成功。</p>
<p>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</p>
<p>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</p>
<p>301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</p>
<p>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</p>
<p>304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</p>
<p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
<p>t Found：请求资源不存在，举个例子：输入了错误的URL。</p>
<h2 id="6、-请你说一说IP地址作用，以及MAC地址作用"><a href="#6、-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="6、 请你说一说IP地址作用，以及MAC地址作用"></a>6、 请你说一说IP地址作用，以及MAC地址作用</h2><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<h2 id="7、请介绍一下操作系统中的中断"><a href="#7、请介绍一下操作系统中的中断" class="headerlink" title="7、请介绍一下操作系统中的中断"></a>7、请介绍一下操作系统中的中断</h2><p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
<h2 id="8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议</h2><p>OSI七层模型及其包含的协议如下:</p>
<p>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</p>
<p>数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</p>
<p>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</p>
<p>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</p>
<p>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p>
<p>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p>
<p>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p>
<p>TCP/IP 4层模型包括：</p>
<p>网络接口层：MAC VLAN</p>
<p>网络层:IP ARP ICMP</p>
<p>传输层:TCP UDP</p>
<p>应用层:HTTP DNS SMTP</p>
<h2 id="9、-请你说一说TCP的三次握手和四次挥手的过程及原因"><a href="#9、-请你说一说TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="9、 请你说一说TCP的三次握手和四次挥手的过程及原因"></a>9、 请你说一说TCP的三次握手和四次挥手的过程及原因</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TCP的三次握手过程如下：</p>
<p>C-&gt; SYN -&gt; S</p>
<p>S-&gt;SYN/ACK-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
<p>TCP的四次挥手过程如下：</p>
<p>C-&gt;FIN-&gt;S</p>
<p>S-&gt;ACK-&gt;C</p>
<p>S-&gt;FIN-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p>
<h2 id="10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h2><p>浏览器中输入URL</p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<p>1、DNS协议，http协议，https协议属于应用层</p>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<p>2、TCP/UDP属于传输层</p>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<p>3、IP协议，ARP协议属于网络层</p>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br>4、数据链路层</p>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br>5、物理层</p>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<h2 id="11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"><a href="#11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"></a>11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？</h2><p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。</p>
<p>1、慢开始</p>
<p>最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。</p>
<p>2、拥塞避免</p>
<p>每经过一个往返时间RTT，cwnd就增长1。</p>
<p>在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p>
<p>3、快重传</p>
<p>接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p>
<p>4、快恢复</p>
<p>当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</p>
<p>采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p>
<p>达到什么情况的时候开始减慢增长的速度？</p>
<p>采用慢开始和拥塞避免算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p>
</li>
</ol>
<p>采用快恢复和快重传算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p>
</li>
</ol>
<h3 id="12、请你说说TCP-IP数据链路层的交互过程"><a href="#12、请你说说TCP-IP数据链路层的交互过程" class="headerlink" title="12、请你说说TCP/IP数据链路层的交互过程"></a>12、请你说说TCP/IP数据链路层的交互过程</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>
<h3 id="13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h3><p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
<h2 id="14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"><a href="#14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）" class="headerlink" title="14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"></a>14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）</h2><p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
<h2 id="●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
<h2 id="●-请问TCP三次握手是怎样的？"><a href="#●-请问TCP三次握手是怎样的？" class="headerlink" title="● 请问TCP三次握手是怎样的？"></a>● 请问TCP三次握手是怎样的？</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请问tcp握手为什么两次不可以？为什么不用四次？"><a href="#●-请问tcp握手为什么两次不可以？为什么不用四次？" class="headerlink" title="● 请问tcp握手为什么两次不可以？为什么不用四次？"></a>● 请问tcp握手为什么两次不可以？为什么不用四次？</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
<p>不用四次：</p>
<h2 id="●-请你来说一下TCP拥塞控制？"><a href="#●-请你来说一下TCP拥塞控制？" class="headerlink" title="● 请你来说一下TCP拥塞控制？"></a>● 请你来说一下TCP拥塞控制？</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。</p>
<h2 id="●-TCP和UDP的区别和各自适用的场景"><a href="#●-TCP和UDP的区别和各自适用的场景" class="headerlink" title="● TCP和UDP的区别和各自适用的场景"></a>● TCP和UDP的区别和各自适用的场景</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP和UDP区别</p>
<p>1） 连接</p>
<p>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</p>
<p>UDP无连接。</p>
<p>2） 服务对象</p>
<p>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p>
<p>UDP支持一对一，一对多，多对一，多对多的交互通信。</p>
<p>3） 可靠性</p>
<p>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</p>
<p>UDP是尽最大努力交付，不保证可靠交付。</p>
<p>4）拥塞控制，流量控制</p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性。</p>
<p>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p>
<p>5） 报文长度</p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p>
<p>6)   首部开销</p>
<p>TCP首部开销大，首部20个字节。</p>
<p>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p>
<p>2）TCP和UDP适用场景</p>
<p>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h2 id="●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态"><a href="#●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态" class="headerlink" title="● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态"></a>● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP连接（三次握手）过程：</p>
<p>客户端A：发送SYN连接报文，序列号为x，进入SYNC-SENT状态。</p>
<p>服务端B：发送SYN连接确认报文（SYN=1，ACK = 1），序列号为y（seq = y），确认报文x（ack = x + 1），进入SYNC-RCVD状态。</p>
<p>客户端A：发送ACK确认报文（ACK = 1），序列号为x+1（seq = x + 1），确认报文y+1（ack = y + 1），进入ESTABLISHED状态。</p>
<p>服务器B：收到后进入ESTABLISHED状态。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654514757_B2186A0EB2E4E9A381061A1CC4706248" alt="img"></p>
<p>2）三次握手原因：</p>
<p>三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。</p>
<p>服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。</p>
<p>3） TCP释放（四次分手）过程：</p>
<p>服务端A：发送FIN报文（FIN = 1），序列号为u（seq = u），进入FIN-WAIT 1状态。</p>
<p>客户端B：发送ACK确认报文（ACK = 1），序列号为v（seq = v），确认报文u（ack = u + 1），进入CLOSE-WAIT状态，继续传送数据。</p>
<p>服务端A：收到上述报文进入FIN-WAIT2状态，继续接受B传输的数据。</p>
<p>客户端B：数据传输完毕后，发送FIN报文（FIN = 1，ACK = 1），序列号为w（seq = w），确认报文u（ack = u + 1），进入LAST-ACK状态。</p>
<p>服务端A：发送ACK确认报文（ACK = 1），序列号为u+1（seq = u + 1），确认报文w（ack = w + 1），进入TIME-WAIT状态，等待2MSL（最长报文段寿命），进入CLOSED状态。</p>
<p>客户端B：收到后上述报文后进入CLOSED状态。</p>
<p>4）为什么TCP协议终止链接要四次？</p>
<p>1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。</p>
<p>2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。</p>
<p>3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。</p>
<p>4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。</p>
<p>5）2MSL意义：</p>
<p>1、保证最后一次握手报文能到B，能进行超时重传。</p>
<p>2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</p>
<h2 id="●-请你来说一说http协议"><a href="#●-请你来说一说http协议" class="headerlink" title="● 请你来说一说http协议"></a>● 请你来说一说http协议</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）HTTP协议：</p>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>2）HTTP协议特点</p>
<p>1、简单快速：</p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3、无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4、无状态：</p>
<p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
<p>3）HTTP过程概述：</p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>HTTP 请求/响应的步骤如下：</p>
<p>1、客户端连接到Web服务器</p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>。</p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>4、举例：</p>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
<h2 id="●-请你来说一下GET和POST的区别"><a href="#●-请你来说一下GET和POST的区别" class="headerlink" title="● 请你来说一下GET和POST的区别"></a>● 请你来说一下GET和POST的区别</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概括</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
<p>2、区别：</p>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而post支持多种编码方式。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<h2 id="●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数"><a href="#●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数"></a>● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）基于TCP的socket：</p>
<p>1、服务器端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2绑定IP地址、端口等信息到socket上，用函数bind()</p>
<p>3设置允许的最大连接数，用函数listen()</p>
<p>4接收客户端上来的连接，用函数accept()</p>
<p>5收发数据，用函数send()和recv()，或者read()和write()</p>
<p>6关闭网络连接</p>
<p>2、客户端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2设置要连接的对方的IP地址和端口等属性</p>
<p>3连接服务器，用函数connect()</p>
<p>4收发数据，用函数send()和recv()，或read()和write()</p>
<p>5关闭网络连接</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7" alt="img"></p>
<p>2）基于UDP的socket：</p>
<p>1、服务器端流程</p>
<p>1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p>
<p>2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p>
<p>3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p>
<p>4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p>
<p>5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p>
<p>6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p>
<p>2、客户端流程</p>
<p>1建立套接字文件描述符，socket()。</p>
<p>2设置服务器地址和端口，struct sockaddr。</p>
<p>3向服务器发送数据，sendto()。</p>
<p>4接收服务器的数据，recvfrom()。</p>
<p>5关闭套接字，close()。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="img"></p>
<h2 id="●-请你来说一下数字证书是什么，里面都包含那些内容"><a href="#●-请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="● 请你来说一下数字证书是什么，里面都包含那些内容"></a>● 请你来说一下数字证书是什么，里面都包含那些内容</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）概念：</p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p>2）数字证书颁发过程：</p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p>3）内容：</p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<p>1、证书的版本信息；</p>
<p>2、证书的序列号，每个证书都有一个唯一的证书序列号；</p>
<p>3、证书所使用的签名算法；</p>
<p>4、证书的发行机构名称，命名规则一般采用X.500格式；</p>
<p>5、证书的有效期，通用的证书一般采用UTC时间格式；</p>
<p>6、证书所有人的名称，命名规则一般采用X.500格式；</p>
<p>7、证书所有人的公开密钥；</p>
<p>8、证书发行者对证书的签名。</p>
<h2 id="●-请你来介绍一下udp的connect函数"><a href="#●-请你来介绍一下udp的connect函数" class="headerlink" title="● 请你来介绍一下udp的connect函数"></a>● 请你来介绍一下udp的connect函数</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<p>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</p>
<p>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p>
<p>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</p>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
<h2 id="●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"><a href="#●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？" class="headerlink" title="● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"></a>● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>三次握手</p>
<p>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复syn1,ack(syn0+1)<br>3.客户端收到syn1，回复ack(syn1+1)<br>四次挥手(这里以客户端主动断开为例)<br>1.客户端发送fin<br>2.服务端收到fin,回复ack,然后服务器去处理其他事<br>3.服务器事情处理完，回复fin<br>4.客户端回复ack<br>为什么用三次握手<br>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：<br>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复ack(syn0+1)<br>3.服务器发送syn1<br>3.客户端收到syn1，回复ack(syn1+1)<br>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
<h2 id="●-请你说一下阻塞，非阻塞，同步，异步"><a href="#●-请你说一下阻塞，非阻塞，同步，异步" class="headerlink" title="● 请你说一下阻塞，非阻塞，同步，异步"></a>● 请你说一下阻塞，非阻塞，同步，异步</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p>
<p>同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步</p>
<h2 id="●-请你讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#●-请你讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="● 请你讲述一下Socket编程的send() recv() accept() socket()函数？"></a>● 请你讲述一下Socket编程的send() recv() accept() socket()函数？</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<h2 id="●-请你说一下http协议会话结束标志怎么截出来？"><a href="#●-请你说一下http协议会话结束标志怎么截出来？" class="headerlink" title="● 请你说一下http协议会话结束标志怎么截出来？"></a>● 请你说一下http协议会话结束标志怎么截出来？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>看tcp连接是否有断开的四部挥手阶段。</p>
<h2 id="●-请你说一说三次握手"><a href="#●-请你说一说三次握手" class="headerlink" title="● 请你说一说三次握手"></a>● 请你说一说三次握手</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请你说一说四次挥手"><a href="#●-请你说一说四次挥手" class="headerlink" title="● 请你说一说四次挥手"></a>● 请你说一说四次挥手</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复ack(syn0+1)</p>
<h2 id="●-请你说一说TCP-IP数据链路层的交互过程"><a href="#●-请你说一说TCP-IP数据链路层的交互过程" class="headerlink" title="● 请你说一说TCP/IP数据链路层的交互过程"></a>● 请你说一说TCP/IP数据链路层的交互过程</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/操作系统/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T16:40:02+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h3><p>基本概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，==实现进程内部的并发==；==线程是操作系统可识别的最小执行和调度单位。==每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。==每个线程完成不同的任务==，但是共享同一地址空间（==也就是同样的动态内存，映射文件，目标代码等==等），打开的文件队列和其他内核资源。</p>
<p>区别：</p>
<p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫==运行时段==，用来存放所有局部变量和临时变量。）</p>
<p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
<p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——==需要进程同步和互斥手段==的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
<p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7.进程间不会相互影响 ；==线程一个线程挂掉将导致整个进程挂掉==</p>
<p>8.进程适应于多核、多机分布；线程适用于多核</p>
<p>进程间通信的方式：</p>
<p>进程间通信主要包括==管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。==</p>
<p>1.管道：</p>
<p>管道主要包括==无名管道和命名管道==:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p>1.1 普通管道PIPE：</p>
<p>1)==它是半双工的==（即数据只能在一个方向上流动），具有固定的读端和写端</p>
<p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
<p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p>1.2 命名管道FIFO：</p>
<p>1==)FIFO可以在无关的进程之间交换数据==</p>
<p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<ol start="2">
<li>系统IPC：</li>
</ol>
<p>2.1 消息队列</p>
<p>消息队列，是消息的==链接表==，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；权限得进程则可以从消息队列中读取信息；</p>
<p>特点：</p>
<p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>2.2 信号量semaphore</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。==信号量用于实现进程间的互斥与同步==，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<p>1)==信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。==</p>
<p>2)信号量基于操作系统的 PV 操作，==程序对信号量的操作都是原子操作。==</p>
<p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>4)支持信号量组。</p>
<p>2.3 信号signal</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>2.4 共享内存（Shared Memory）</p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如==互斥锁和信号量等==</p>
<p>特点：</p>
<p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
<p>2)因为多个进程可以同时操作，所以需要进行同步</p>
<p>3)信号量+共享内存通常结合在一起使用，==信号量用来同步对共享内存的访问==</p>
<p>3.套接字SOCKET：</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<p>线程间通信的方式:</p>
<p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>==互斥量Synchronized/Lock==：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>==信号量Semphare==：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="2、请你说一说Linux虚拟地址空间"><a href="#2、请你说一说Linux虚拟地址空间" class="headerlink" title="2、请你说一说Linux虚拟地址空间"></a>2、请你说一说Linux虚拟地址空间</h3><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p>虚拟内存的好处：</p>
<p>1.扩大地址空间；</p>
<p>2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
<p>3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
<p>4==.当进程通信时，可采用虚存共享的方式实现。==</p>
<p>5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p>
<p>6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p>
<p>7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
<p>虚拟内存的代价：</p>
<p>1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</p>
<p>2.虚拟地址到物理地址的转换，增加了指令的执行时间。</p>
<p>3.页面的换入换出需要磁盘I/O，这是很耗时的</p>
<p>4.如果一页中只有一部分数据，会浪费内存。</p>
<h3 id="3、-请你说一说操作系统中的程序的内存结构"><a href="#3、-请你说一说操作系统中的程序的内存结构" class="headerlink" title="3、 请你说一说操作系统中的程序的内存结构"></a>3、 请你说一说操作系统中的程序的内存结构</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<h3 id="4、请你说一说操作系统中的缺页中断"><a href="#4、请你说一说操作系统中的缺页中断" class="headerlink" title="4、请你说一说操作系统中的缺页中断"></a>4、请你说一说操作系统中的缺页中断</h3><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p>
<p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<p>1、在指令执行期间产生和处理缺页中断信号</p>
<p>2、一条指令在执行期间，可能产生多次缺页中断</p>
<p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p>
<h3 id="5、-请你回答一下fork和vfork的区别"><a href="#5、-请你回答一下fork和vfork的区别" class="headerlink" title="5、 请你回答一下fork和vfork的区别"></a>5、 请你回答一下fork和vfork的区别</h3><p>fork的基础知识：</p>
<p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>vfork的基础知识：</p>
<p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void);</p>
<p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。==vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像==。通过这样的方式，vfork( )避免了地址空间的按页复制。==在这个过程中，父进程和子进程共享相同的地址空间和页表项。==实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p>
<p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p>
<p>补充知识点：写时复制</p>
<p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p>
<p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。==只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。==</p>
<p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p>
<p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
<p>fork和vfork的区别：</p>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
<p>4.当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
<h3 id="6、-请问如何修改文件最大句柄数？"><a href="#6、-请问如何修改文件最大句柄数？" class="headerlink" title="6、 请问如何修改文件最大句柄数？"></a>6、 请问如何修改文件最大句柄数？</h3><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</li>
</ol>
<p>首先用ulimit -a查询Linux相关的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 94739</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 94739</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>其中，open files就是最大文件句柄数，默认是1024个。</p>
<p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p>
<ol start="2">
<li>对所有进程都有效的方法，修改Linux系统参数</li>
</ol>
<p>vi /etc/security/limits.conf 添加</p>
<p>*　　soft　　nofile　　65536</p>
<p>*　　hard　　nofile　　65536</p>
<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h3 id="7、请你说一说并发-concurrency-和并行-parallelism"><a href="#7、请你说一说并发-concurrency-和并行-parallelism" class="headerlink" title="7、请你说一说并发(concurrency)和并行(parallelism)"></a>7、请你说一说并发(concurrency)和并行(parallelism)</h3><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<h3 id="8、请问MySQL的端口号是多少，如何修改这个端口号"><a href="#8、请问MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="8、请问MySQL的端口号是多少，如何修改这个端口号"></a>8、请问MySQL的端口号是多少，如何修改这个端口号</h3><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>查看端口号：</p>
<p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>
<h3 id="9、请你说一说操作系统中的页表寻址"><a href="#9、请你说一说操作系统中的页表寻址" class="headerlink" title="9、请你说一说操作系统中的页表寻址"></a>9、请你说一说操作系统中的页表寻址</h3><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>Linux最初的两级页表机制：</p>
<p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p>
<p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p>
<p>* PTE(Page Table Entry)：中间10位，页表入口索引</p>
<p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p>
<p>Linux的三级页表机制：</p>
<p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p>
<p>字段            描述                        位数</p>
<p>cr3            指向一个PDPT            crs寄存器存储</p>
<p>PGD        指向PDPT中4个项中的一个    位31~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p>
<p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p>
<p>Linux的四级页表机制：</p>
<p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p>
<p>字段            描述                        位数</p>
<p>PML4        指向一个PDPT            位47~39</p>
<p>PGD        指向PDPT中4个项中的一个    位38~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p>
<p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p>
<h3 id="10、-请你说一说有了进程，为什么还要有线程？"><a href="#10、-请你说一说有了进程，为什么还要有线程？" class="headerlink" title="10、 请你说一说有了进程，为什么还要有线程？"></a>10、 请你说一说有了进程，为什么还要有线程？</h3><p>线程产生的原因：</p>
<p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p>
<p>进程在同一时间只能干一件事</p>
<p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p>
<p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p>
<p>从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
<p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（</p>
<p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
<p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
<h3 id="11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h3><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p>
<h3 id="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h3><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<p>SP:堆栈指针，指向当前栈的栈顶地址</p>
<p>PC:程序计数器，存储下一条将要执行的指令</p>
<p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>
<h3 id="13、-请你说一说线程间的同步方式，最好说出具体的系统调用"><a href="#13、-请你说一说线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="13、 请你说一说线程间的同步方式，最好说出具体的系统调用"></a>13、 请你说一说线程间的同步方式，最好说出具体的系统调用</h3><p>信号量</p>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</p>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</p>
<p>其系统调用为：</p>
<p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p>
<p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<p>互斥量</p>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<p>pthread_mutex_init:初始化互斥锁</p>
<p>pthread_mutex_destroy：销毁互斥锁</p>
<p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p>
<p>条件变量</p>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<p>pthread_cond_init:初始化条件变量</p>
<p>pthread_cond_destroy：销毁条件变量</p>
<p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p>
<p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p>
<h3 id="14、请你说一下多线程和多进程的不同"><a href="#14、请你说一下多线程和多进程的不同" class="headerlink" title="14、请你说一下多线程和多进程的不同"></a>14、请你说一下多线程和多进程的不同</h3><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</p>
<h3 id="15、-请你说一说进程和线程的区别"><a href="#15、-请你说一说进程和线程的区别" class="headerlink" title="15、 请你说一说进程和线程的区别"></a>15、 请你说一说进程和线程的区别</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p>
<p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p>
<p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p>
<p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p>
<p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p>
<h3 id="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h3><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p>
<h3 id="17、请你说一说OS缺页置换算法"><a href="#17、请你说一说OS缺页置换算法" class="headerlink" title="17、请你说一说OS缺页置换算法"></a>17、请你说一说OS缺页置换算法</h3><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p>
<p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
<p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
<p>当前最常采用的就是LRU算法。</p>
<h3 id="18、请你说一下多进程和多线程的使用场景"><a href="#18、请你说一下多进程和多线程的使用场景" class="headerlink" title="18、请你说一下多进程和多线程的使用场景"></a>18、请你说一下多进程和多线程的使用场景</h3><p>多进程模型的优势是CPU</p>
<p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p>
<p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p>
<h3 id="19、-请你说一说死锁发生的条件以及如何解决死锁"><a href="#19、-请你说一说死锁发生的条件以及如何解决死锁" class="headerlink" title="19、 请你说一说死锁发生的条件以及如何解决死锁"></a>19、 请你说一说死锁发生的条件以及如何解决死锁</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p>
<p>==互斥条件==：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p>
<p>==请求和保持条件==：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p>
<p>==不可剥夺条件==：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p>==环路等待条件==：进程发生死锁后，必然存在一个进程-资源之间的环形链</p>
<p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p>
<p>资源一次性分配，从而剥夺请求和保持条件</p>
<p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p>
<p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p>
<h3 id="20、请问虚拟内存和物理内存怎么对应"><a href="#20、请问虚拟内存和物理内存怎么对应" class="headerlink" title="20、请问虚拟内存和物理内存怎么对应"></a>20、请问虚拟内存和物理内存怎么对应</h3><p>1、概念：</p>
<p>物理地址(physical address)</p>
<p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。</p>
<p>虚拟地址(virtual memory)</p>
<p>这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p>
<p>之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。</p>
<p>有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。</p>
<p>——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。</p>
<p>2、地址转换</p>
<p>第一步：CPU段式管理中——逻辑地址转线性地址</p>
<p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p>
<p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p>
<p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p>
<p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址</p>
<p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p>
<p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。</p>
<p>GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p>
<p>段起始地址+ 段内偏移量 = 线性地址</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p>
<p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p>
<p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p>
<p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p>
<p>3、把Base + offset，就是要转换的线性地址了。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p>
<p>第一步：页式管理——线性地址转物理地址</p>
<p>再利用其页式内存管理单元，转换为最终物理地址。</p>
<p>linux假的段式管理</p>
<p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。</p>
<p>其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。</p>
<p>所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。</p>
<p>按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p>
<p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p>
<p>linux页式管理</p>
<p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p>
<p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p>
<p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p>
<p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p>
<p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p>
<p>依据以下步骤进行转换：</p>
<p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p>
<p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p>
<p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p>
<p>将页的起始地址与线性地址中最后12位相加。</p>
<p>目的：</p>
<p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p>
<p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p>
<p>64位，PUD和PMD ≠ 0</p>
<h3 id="21、-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#21、-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="21、 请你说一说操作系统中的结构体对齐，字节对齐"></a>21、 请你说一说操作系统中的结构体对齐，字节对齐</h3><p>1、原因：</p>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<p>2、规则</p>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
<p>4、举例</p>
<p>#pragma pack(2)</p>
<p>struct AA {</p>
<p>int a;       //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p>
<p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p>
<p>short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p>
<p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p>
<p>};</p>
<p>#pragma pack()</p>
<h3 id="22、-请你说一下虚拟内存置换的方式"><a href="#22、-请你说一下虚拟内存置换的方式" class="headerlink" title="22、 请你说一下虚拟内存置换的方式"></a>22、 请你说一下虚拟内存置换的方式</h3><p>比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。</p>
<p>1、FIFO（先进先出淘汰算法）</p>
<p>思想：最近刚访问的，将来访问的可能性比较大。</p>
<p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p>
<p>弊端：无法体现页面冷热信息</p>
<p>2、LFU（最不经常访问淘汰算法）</p>
<p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>开销：排序开销。</p>
<p>弊端：缓存颠簸。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p>
<p>3、LRU（最近最少使用替换算法）</p>
<p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p>
<p>优点：LRU算法对热点数据命中率是很高的。</p>
<p>缺陷：</p>
<p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p>
<p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p>
<p>4、LRU-K（LRU-2、LRU-3）</p>
<p>思想：最久未使用K次淘汰算法。</p>
<p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>实现：</p>
<p>1）数据第一次被访问，加入到访问历史列表；</p>
<p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>4）缓存数据队列中被再次访问后，重新排序；</p>
<p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>针对问题：</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>5、2Q</p>
<p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p>
<p>实现：</p>
<p>1）新访问的数据插入到FIFO队列；</p>
<p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>5）LRU队列淘汰末尾的数据。</p>
<p>针对问题：LRU的缓存污染</p>
<p>弊端：</p>
<p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p>
<h3 id="23、-请你说一下多线程，线程同步的几种方式"><a href="#23、-请你说一下多线程，线程同步的几种方式" class="headerlink" title="23、 请你说一下多线程，线程同步的几种方式"></a>23、 请你说一下多线程，线程同步的几种方式</h3><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<p>线程间通信的方式:</p>
<p>1、临界区：</p>
<p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>2、互斥量 Synchronized/Lock：</p>
<p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>3、信号量 Semphare：</p>
<p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>4、事件(信号)，Wait/Notify：</p>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h3><p>1、互斥锁和读写锁区别：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<p>1）读写锁区分读者和写者，而互斥锁不区分</p>
<p>2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p>
<p>2、Linux的4种锁机制：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
<p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p>
<h3 id="25、请回答一下进程和线程的区别"><a href="#25、请回答一下进程和线程的区别" class="headerlink" title="25、请回答一下进程和线程的区别"></a>25、请回答一下进程和线程的区别</h3><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<h3 id="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h3><p>1、进程的五种基本状态：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完</p>
<p>2、交换技术</p>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p>
<p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
<p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
<p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
<p>从而出现了：</p>
<p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p>
<p>执行     ——  静止就绪         （时间片用完）</p>
<h3 id="27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><p>1、程序内存管理：</p>
<p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74" alt="img"></p>
<p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
<p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
<p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
<p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
<p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
<p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p>可执行程序在运行时又多出两个区域：栈区和堆区。</p>
<p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
<p>2、A* a = new A; a-&gt;i = 10：</p>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p>
<p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p>
<p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p>
<p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
<h3 id="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3><p>1、static修饰符</p>
<p>1）static修饰成员变量</p>
<p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
<p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
<p>2）static修饰成员函数</p>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p>
<p>Static修饰的成员函数，在代码区分配内存。</p>
<p>2、C++继承和虚函数</p>
<p>C++多态分为静态多态和动态多态。==静态多态是通过重载和模板技术实现==，在编译的时候确定。==动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。==</p>
<p>动态多态实现有几个条件：</p>
<p>(1) 虚函数；</p>
<p>(2) 一个基类的指针或引用指向派生类的对象；</p>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
<p>3、virtual修饰符</p>
<p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
<p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p>
<p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p>
<h3 id="29、请你回答一下软链接和硬链接区别"><a href="#29、请你回答一下软链接和硬链接区别" class="headerlink" title="29、请你回答一下软链接和硬链接区别"></a>29、请你回答一下软链接和硬链接区别</h3><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p>
<p>若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。</p>
<p>若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p>
<h3 id="30、请问什么是大端小端以及如何判断大端小端"><a href="#30、请问什么是大端小端以及如何判断大端小端" class="headerlink" title="30、请问什么是大端小端以及如何判断大端小端"></a>30、请问什么是大端小端以及如何判断大端小端</h3><p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470995798_E694EFF3D7CC8BA2BB2EE978CE1EB6FB" alt="img"></p>
<h3 id="31、请你回答一下静态变量什么时候初始化"><a href="#31、请你回答一下静态变量什么时候初始化" class="headerlink" title="31、请你回答一下静态变量什么时候初始化"></a>31、请你回答一下静态变量什么时候初始化</h3><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
<h3 id="32、请你说一说用户态和内核态区别"><a href="#32、请你说一说用户态和内核态区别" class="headerlink" title="32、请你说一说用户态和内核态区别"></a>32、请你说一说用户态和内核态区别</h3><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<h3 id="33、如何设计server，使得能够接收多个客户端的请求"><a href="#33、如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="33、如何设计server，使得能够接收多个客户端的请求"></a>33、如何设计server，使得能够接收多个客户端的请求</h3><p>多线程，线程池，io复用</p>
<h3 id="34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h3><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h3 id="35、-怎么唤醒被阻塞的socket线程？"><a href="#35、-怎么唤醒被阻塞的socket线程？" class="headerlink" title="35、 怎么唤醒被阻塞的socket线程？"></a>35、 怎么唤醒被阻塞的socket线程？</h3><p>给阻塞时候缺少的资源</p>
<h3 id="36、-怎样确定当前线程是繁忙还是阻塞？"><a href="#36、-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="36、 怎样确定当前线程是繁忙还是阻塞？"></a>36、 怎样确定当前线程是繁忙还是阻塞？</h3><p>使用ps命令查看</p>
<h3 id="37、请问就绪状态的进程在等待什么？"><a href="#37、请问就绪状态的进程在等待什么？" class="headerlink" title="37、请问就绪状态的进程在等待什么？"></a>37、请问就绪状态的进程在等待什么？</h3><p>被调度使用cpu的运行权</p>
<h3 id="38、请你说一说多线程的同步，锁的机制"><a href="#38、请你说一说多线程的同步，锁的机制" class="headerlink" title="38、请你说一说多线程的同步，锁的机制"></a>38、请你说一说多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行</p>
<h3 id="39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="40、-windows消息机制知道吗，请说一说"><a href="#40、-windows消息机制知道吗，请说一说" class="headerlink" title="40、 windows消息机制知道吗，请说一说"></a>40、 windows消息机制知道吗，请说一说</h3><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h3 id="41、C-的锁你知道几种"><a href="#41、C-的锁你知道几种" class="headerlink" title="41、C++的锁你知道几种?"></a>41、C++的锁你知道几种?</h3><p>锁包括互斥锁，条件变量，自旋锁和读写锁</p>
<h3 id="42、-说一说你用到的锁"><a href="#42、-说一说你用到的锁" class="headerlink" title="42、 说一说你用到的锁"></a>42、 说一说你用到的锁</h3><p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p>
<h3 id="43、请你说一说死锁产生的必要条件？"><a href="#43、请你说一说死锁产生的必要条件？" class="headerlink" title="43、请你说一说死锁产生的必要条件？"></a>43、请你说一说死锁产生的必要条件？</h3><p>1.互斥条件：一个资源每次只能被一个进程使用。</p>
<h3 id="44、-请你说一说内存溢出和内存泄漏"><a href="#44、-请你说一说内存溢出和内存泄漏" class="headerlink" title="44、 请你说一说内存溢出和内存泄漏"></a>44、 请你说一说内存溢出和内存泄漏</h3><p>1、内存溢出</p>
<p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<p>内存溢出原因：</p>
<p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p>
<p>集合类中有对对象的引用，使用完后未清空，使得不能回收</p>
<p>代码中存在死循环或循环产生过多重复的对象实体</p>
<p>使用的第三方软件中的BUG</p>
<p>启动参数内存值设定的过小</p>
<p>2、内存泄漏</p>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<p>1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
<h3 id="45、进程和线程的区别，你都使用什么线程模型"><a href="#45、进程和线程的区别，你都使用什么线程模型" class="headerlink" title="45、进程和线程的区别，你都使用什么线程模型"></a>45、进程和线程的区别，你都使用什么线程模型</h3><p>1）进程和线程区别</p>
<p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<p>2、常用线程模型</p>
<p>1、Future模型</p>
<p>该模型通常在使用的时候需要结合Callable接口配合使用。</p>
<p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p>
<p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p>
<p>2、fork&amp;join模型</p>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
<p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
<p>3、actor模型</p>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
<p>4、生产者消费者模型</p>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p>
<p>5、master-worker模型</p>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
<h3 id="46、请你来说一说协程"><a href="#46、请你来说一说协程" class="headerlink" title="46、请你来说一说协程"></a>46、请你来说一说协程</h3><p>1、概念：</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def A() :</span><br><span class="line">print &apos;1&apos;</span><br><span class="line">print &apos;2&apos;</span><br><span class="line">print &apos;3&apos;</span><br><span class="line">def B() :</span><br><span class="line">print &apos;x&apos;</span><br><span class="line">print &apos;y&apos;</span><br><span class="line">print &apos;z&apos;</span><br></pre></td></tr></table></figure>

<p>由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
<p>2）协程和线程区别</p>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>3）其他</p>
<p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
<h3 id="47、-系统调用是什么，你用过哪些系统调用"><a href="#47、-系统调用是什么，你用过哪些系统调用" class="headerlink" title="47、 系统调用是什么，你用过哪些系统调用"></a>47、 系统调用是什么，你用过哪些系统调用</h3><p>1）概念：</p>
<p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p>
<p>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p>
<p>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p>
<p>2）系统调用举例：</p>
<p>对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include&lt;stdio.h&gt;``#include&lt;stdlib.h&gt;``#include&lt;string.h&gt;``#include&lt;errno.h&gt;``#include&lt;unistd.h&gt;``#include&lt;sys/types.h&gt;``#include&lt;sys/stat.h&gt;``#include&lt;fcntl.h&gt;``int` `main(``int` `argc, ``char` `*argv[])``&#123;``    ``if` `(argc&lt;``2``)``        ``return` `0``;``    ``//用读写追加方式打开一个已经存在的文件``    ``int` `fd = open(argv[``1``], O_RDWR | O_APPEND);``    ``if` `(fd == -``1``)``    ``&#123;``        ``printf(``&quot;error is %s\n&quot;``, strerror(errno));``    ``&#125;``    ``else``    ``&#123;``        ``//打印文件描述符号``        ``printf(``&quot;success fd = %d\n&quot;``, fd);``        ``char` `buf[``100``];``        ``memset(buf, ``0``, sizeof(buf));``        ``strcpy(buf, ``&quot;hello world\n&quot;``);``        ``write(fd, buf, strlen(buf));``        ``close(fd);``    ``&#125;``    ``return` `0``;``&#125;`</span><br></pre></td></tr></table></figure>

<p>还有写数据write，创建进程fork，vfork等都是系统调用。</p>
<h3 id="48、-请你来手写一下fork调用示例"><a href="#48、-请你来手写一下fork调用示例" class="headerlink" title="48、 请你来手写一下fork调用示例"></a>48、 请你来手写一下fork调用示例</h3><p>1、概念：</p>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>2、fork实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">signal(SIGCHLD, SIG_IGN);</span><br><span class="line">printf(&quot;before fork pid:%d\n&quot;, getpid());</span><br><span class="line">int abc = 10;</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>

<p>if (pid == -1) {           //错误返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror(&quot;tile&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if (pid &gt; 0) {              //父进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc++;</span><br><span class="line">printf(&quot;parent:pid:%d \n&quot;, getpid());</span><br><span class="line">printf(&quot;abc:%d \n&quot;, abc);</span><br><span class="line">sleep(20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if (pid == 0) {       //子进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`abc++;``printf``(``&quot;child:%d,parent: %d\n&quot;``, getpid(), getppid());``printf``(``&quot;abc:%d&quot;``, abc);``&#125;``printf``(``&quot;fork after...\n&quot;``);`` ``&#125;`</span><br></pre></td></tr></table></figure>

<h3 id="49、-请你来说一说用户态到内核态的转化原理"><a href="#49、-请你来说一说用户态到内核态的转化原理" class="headerlink" title="49、 请你来说一说用户态到内核态的转化原理"></a>49、 请你来说一说用户态到内核态的转化原理</h3><p>1）用户态切换到内核态的3种方式</p>
<p>1、系统调用</p>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>2、异常</p>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
<p>3、外围设备的中断</p>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>2）切换操作</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<h3 id="50、请你说一下源码到可执行文件的过程"><a href="#50、请你说一下源码到可执行文件的过程" class="headerlink" title="50、请你说一下源码到可执行文件的过程"></a>50、请你说一下源码到可执行文件的过程</h3><p>1）预编译</p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的注释，“//”和“/**/”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p>2）编译</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p>3）汇编</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p>4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2、动态链接：</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h3 id="51、请你来说一下微内核与宏内核"><a href="#51、请你来说一下微内核与宏内核" class="headerlink" title="51、请你来说一下微内核与宏内核"></a>51、请你来说一下微内核与宏内核</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<p>优点：效率高。</p>
<p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p>
<p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p>
<h3 id="52、请你说一下僵尸进程"><a href="#52、请你说一下僵尸进程" class="headerlink" title="52、请你说一下僵尸进程"></a>52、请你说一下僵尸进程</h3><p>1）正常进程</p>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<p>1进程号the process ID</p>
<p>2退出状态the termination status of the process</p>
<p>3运行时间the amount of CPU time taken by the process等</p>
<p>2）孤儿进程</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>3）僵尸进程</p>
<p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p>危害：</p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>外部消灭：</p>
<p>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p>
<p>内部解决：</p>
<p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
<h3 id="53、请问GDB调试用过吗，什么是条件断点"><a href="#53、请问GDB调试用过吗，什么是条件断点" class="headerlink" title="53、请问GDB调试用过吗，什么是条件断点"></a>53、请问GDB调试用过吗，什么是条件断点</h3><p>1、GDB调试</p>
<p>GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p>
<p>GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p>
<p>2、条件断点</p>
<p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p>
<p>例如：(gdb)break 666 if testsize==100</p>
<h3 id="54、请你来介绍一下5种IO模型"><a href="#54、请你来介绍一下5种IO模型" class="headerlink" title="54、请你来介绍一下5种IO模型"></a>54、请你来介绍一下5种IO模型</h3><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</p>
<p>3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。<br>4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h3 id="55、请你说一说异步编程的事件循环"><a href="#55、请你说一说异步编程的事件循环" class="headerlink" title="55、请你说一说异步编程的事件循环"></a>55、请你说一说异步编程的事件循环</h3><p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
<h3 id="56、请你回答一下操作系统为什么要分内核态和用户态"><a href="#56、请你回答一下操作系统为什么要分内核态和用户态" class="headerlink" title="56、请你回答一下操作系统为什么要分内核态和用户态"></a>56、请你回答一下操作系统为什么要分内核态和用户态</h3><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
<h3 id="57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache"></a>57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h3><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache</p>
<h3 id="58、请你说一下多线程的同步，锁的机制"><a href="#58、请你说一下多线程的同步，锁的机制" class="headerlink" title="58、请你说一下多线程的同步，锁的机制"></a>58、请你说一下多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<h3 id="59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="60、-请问怎么实现线程池"><a href="#60、-请问怎么实现线程池" class="headerlink" title="60、 请问怎么实现线程池"></a>60、 请问怎么实现线程池</h3><p>1.设置一个生产者消费者队列，作为临界资源</p>
<h3 id="61、-Linux下怎么得到一个文件的100到200行"><a href="#61、-Linux下怎么得到一个文件的100到200行" class="headerlink" title="61、 Linux下怎么得到一个文件的100到200行"></a>61、 Linux下怎么得到一个文件的100到200行</h3><p>sed -n ‘100,200p’ inputfile</p>
<p>awk ‘NR&gt;=100&amp;&amp;NR&lt;=200{print}’ inputfile</p>
<p>head -200 inputfile|tail -100</p>
<h3 id="62、-请你来说一下awk的使用"><a href="#62、-请你来说一下awk的使用" class="headerlink" title="62、 请你来说一下awk的使用"></a>62、 请你来说一下awk的使用</h3><p>1）作用：</p>
<p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<p>2）用法：</p>
<p>awk [-F  field-separator]  ‘commands’  input-file(s)</p>
<p>3）内置变量</p>
<table>
<thead>
<tr>
<th>ARGC</th>
<th>命令行参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody></table>
<p>4）实例：</p>
<p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p>
<p>&gt; ls -l | awk ‘{print $5 “\t” $9}’</p>
<p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p>
<p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l | awk &apos;BEGIN &#123;COUNT = -1; print &quot;BEGIN COUNT&quot;&#125;</span><br><span class="line">&#123;COUNT = COUNT + 1; print COUNT&quot;\t&quot;$5&quot;\t&quot;$9&#125;</span><br><span class="line">END &#123;print &quot;END, COUNT = &quot;COUNT&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p>
<p>3、找到当前文件夹下所有的子文件夹,并显示排序</p>
<p>&gt; ls -l | awk ‘BEGIN {print “BEGIN COUNT”} /4096/{print NR”\t”$5”\t”$9}</p>
<p>END {print “END”}’</p>
<p>* /4096/ 正则匹配式子</p>
<p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p>
<h3 id="63、-请你来说一下linux内核中的Timer-定时器机制"><a href="#63、-请你来说一下linux内核中的Timer-定时器机制" class="headerlink" title="63、 请你来说一下linux内核中的Timer 定时器机制"></a>63、 请你来说一下linux内核中的Timer 定时器机制</h3><p>1）低精度时钟</p>
<p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：</p>
<p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p>
<p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p>
<p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p>
<p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p>
<p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p>
<p>2）高精度时钟</p>
<p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p>
<p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p>
<p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p>
<p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p>
<p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p>
<p>hrtimer的工作原理：</p>
<p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p>
<p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p>
<p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p>
<p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p>
<p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p>
<p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p>
<p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/面试/基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/面试/基础知识/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T14:55:50+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、说一下static关键字的作用"><a href="#1、说一下static关键字的作用" class="headerlink" title="1、说一下static关键字的作用"></a>1、说一下static关键字的作用</h3><ol>
<li>全局静态变量</li>
</ol>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<ol start="2">
<li>局部静态变量</li>
</ol>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>==函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；==</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<ol start="4">
<li>类的静态成员</li>
</ol>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<ol start="5">
<li>类的静态函数</li>
</ol>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h3 id="2、说一下C-和C的区别"><a href="#2、说一下C-和C的区别" class="headerlink" title="2、说一下C++和C的区别"></a>2、说一下C++和C的区别</h3><p>设计思想上：</p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h3 id="3、说一说c-中四种cast转换"><a href="#3、说一说c-中四种cast转换" class="headerlink" title="3、说一说c++中四种cast转换"></a>3、说一说c++中四种cast转换</h3><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p>1、const_cast</p>
<p>用于将const变量转为非const</p>
<p>2、static_cast</p>
<p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p>3、dynamic_cast</p>
<p>用于==动态类型转换==。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p>4、reinterpret_cast</p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<p>5、为什么不使用C的强制转换？</p>
<p>==C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。==</p>
<h3 id="4、请说一下C-C-中指针和引用的区别？"><a href="#4、请说一下C-C-中指针和引用的区别？" class="headerlink" title="4、请说一下C/C++ 中指针和引用的区别？"></a>4、请说一下C/C++ 中指针和引用的区别？</h3><p>1.指针有自己的一块空间，而引用只是一个别名；</p>
<p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
<p>5.可以有const指针，但是没有const引用；</p>
<p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7.指针可以有多级指针（**p），而引用至于一级；</p>
<p>8.指针和引用使用++运算符的意义不一样；</p>
<p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<h3 id="5、请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#5、请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="5、请你说一下你理解的c++中的smart pointer四个智能指针：  shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>5、请你说一下你理解的c++中的smart pointer四个智能指针：  shared_ptr,unique_ptr,weak_ptr,auto_ptr</h3><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<ol>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）</li>
</ol>
<p>采用所有权模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<ol start="2">
<li>unique_ptr（替换auto_ptr）</li>
</ol>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (``<span class="keyword">new</span>` `<span class="built_in">string</span> (``<span class="string">"auto"</span>``));   ``<span class="comment">//#4``unique_ptr&lt;string&gt; p4；                       ``//#5``p4 = p3;``//此时会报错！！`</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>shared_ptr</li>
</ol>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p>
<ol start="4">
<li>weak_ptr</li>
</ol>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
<h3 id="6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"><a href="#6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码" class="headerlink" title="6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"></a>6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码</h3><p>1、判断一个数是不是二的倍数，即判断该数二进制末位是不是0：</p>
<p>a % 2 == 0 或者a &amp; 0x0001 == 0。</p>
<p>2、求一个数中1的位数，可以直接逐位除十取余判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">10</span>== <span class="number">1</span>)</span><br><span class="line">++_count;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fun(<span class="number">123321</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、请回答一下数组和指针的区别"><a href="#7、请回答一下数组和指针的区别" class="headerlink" title="7、请回答一下数组和指针的区别"></a>7、请回答一下数组和指针的区别</h3><p>指针和数组的主要区别如下：</p>
<table>
<thead>
<tr>
<th align="center">指针</th>
<th align="center">数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">保存数据的地址</td>
<td align="center">保存数据</td>
</tr>
<tr>
<td align="center">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td align="center">直接访问数据，</td>
</tr>
<tr>
<td align="center">通常用于动态的数据结构</td>
<td align="center">通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td align="center">通过Malloc分配内存，free释放内存</td>
<td align="center">隐式的分配和删除</td>
</tr>
<tr>
<td align="center">通常指向匿名数据，操作匿名函数</td>
<td align="center">自身即为数据名</td>
</tr>
</tbody></table>
<h3 id="8、请你回答一下野指针是什么？"><a href="#8、请你回答一下野指针是什么？" class="headerlink" title="8、请你回答一下野指针是什么？"></a>8、请你回答一下野指针是什么？</h3><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h3 id="9、请你理解的c-中的引用和指针"><a href="#9、请你理解的c-中的引用和指针" class="headerlink" title="9、请你理解的c++中的引用和指针"></a>9、请你理解的c++中的引用和指针</h3><p>定义：</p>
<p>1、引用：</p>
<p>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>相似，只是用&amp;代替了*。</p>
<p>2、指针：</p>
<p>指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p>
<p>区别：</p>
<p>1、指针有自己的一块空间，而引用只是一个别名；</p>
<p>2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p>
<p>4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
<p>5、可以有const指针，但是没有const引用；</p>
<p>6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7、指针可以有多级指针（**p），而引用至于一级；</p>
<p>8、指针和引用使用++运算符的意义不一样；</p>
<p>9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<p>10、引用常量不存在，没有int&amp; const p，常量引用是存在的cosnt int &amp;p</p>
<h3 id="10、请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#10、请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="10、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>10、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h3><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作==父类==时，设置为虚函数</p>
<h3 id="11、请你来说一下函数指针"><a href="#11、请你来说一下函数指针" class="headerlink" title="11、请你来说一下函数指针"></a>11、请你来说一下函数指针</h3><p>1、定义</p>
<p>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p>2、用途：</p>
<p>==调用函数和做函数的参数，比如回调函数==</p>
<p>3、示例：</p>
<p>char * fun(char * p)  {…}       // 函数fun</p>
<p>char * (*pf)(char * p);             // 函数指针pf</p>
<p>pf = fun;                        // 函数指针pf指向函数fun</p>
<p>pf(p);                        // 通过函数指针pf调用函数fun</p>
<h3 id="12、请你来说一下fork函数"><a href="#12、请你来说一下fork函数" class="headerlink" title="12、请你来说一下fork函数"></a>12、请你来说一下fork函数</h3><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<h3 id="13、请你来说一下C-中析构函数的作用"><a href="#13、请你来说一下C-中析构函数的作用" class="headerlink" title="13、请你来说一下C++中析构函数的作用"></a>13、请你来说一下C++中析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>
<p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好==显示构造析构函数==在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>==类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。==</p>
<h3 id="14、请你来说一下静态函数和虚函数的区别"><a href="#14、请你来说一下静态函数和虚函数的区别" class="headerlink" title="14、请你来说一下静态函数和虚函数的区别"></a>14、请你来说一下静态函数和虚函数的区别</h3><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h3 id="15、请你来说一说重载和覆盖"><a href="#15、请你来说一说重载和覆盖" class="headerlink" title="15、请你来说一说重载和覆盖"></a>15、请你来说一说重载和覆盖</h3><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<h3 id="16、请你说一说strcpy和strlen"><a href="#16、请你说一说strcpy和strlen" class="headerlink" title="16、请你说一说strcpy和strlen"></a>16、请你说一说strcpy和strlen</h3><p>strcpy是字符串拷贝函数，原型：</p>
<p>char <em>strcpy(char</em> dest, const char *src);</p>
<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<h3 id="17、-请你说一说你理解的虚函数和多态"><a href="#17、-请你说一说你理解的虚函数和多态" class="headerlink" title="17、 请你说一说你理解的虚函数和多态"></a>17、 请你说一说你理解的虚函数和多态</h3><p>多态的实现主要分为==静态多态==和==动态多态==，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：==一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数==，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h3 id="18、-请你来说一说-i和i-的实现"><a href="#18、-请你来说一说-i和i-的实现" class="headerlink" title="18、 请你来说一说++i和i++的实现"></a>18、 请你来说一说++i和i++的实现</h3><p>++i 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i++实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">++（*<span class="keyword">this</span>）；</span><br><span class="line"><span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19、请你来说一下智能指针shared-ptr的实现"><a href="#19、请你来说一下智能指针shared-ptr的实现" class="headerlink" title="19、请你来说一下智能指针shared_ptr的实现"></a>19、请你来说一下智能指针shared_ptr的实现</h3><p>核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p>
<h3 id="20、以下四行代码的区别是什么？"><a href="#20、以下四行代码的区别是什么？" class="headerlink" title="20、以下四行代码的区别是什么？"></a>20、以下四行代码的区别是什么？</h3><blockquote>
<p>const char * arr = “123”;</p>
<p>char * brr = “123”; </p>
<p>const char crr[] = “123”; </p>
<p>char drr[] = “123”;</p>
</blockquote>
<p>const char * arr = “123”;</p>
<p>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h3 id="21、请你来回答一下const修饰成员函数的目的是什么"><a href="#21、请你来回答一下const修饰成员函数的目的是什么" class="headerlink" title="21、请你来回答一下const修饰成员函数的目的是什么"></a>21、请你来回答一下const修饰成员函数的目的是什么</h3><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h3 id="22、请你来说一说隐式类型转换"><a href="#22、请你来说一说隐式类型转换" class="headerlink" title="22、请你来说一说隐式类型转换"></a>22、请你来说一说隐式类型转换</h3><p>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<h3 id="22、说说你了解的类型转换"><a href="#22、说说你了解的类型转换" class="headerlink" title="22、说说你了解的类型转换"></a>22、说说你了解的类型转换</h3><p>einterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证<br>dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常<br>const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。<br>static_cast：==完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。==</p>
<h3 id="23、请你来说一说C-函数栈空间的最大值"><a href="#23、请你来说一说C-函数栈空间的最大值" class="headerlink" title="23、请你来说一说C++函数栈空间的最大值"></a>23、请你来说一说C++函数栈空间的最大值</h3><p>默认是1M，不过可以调整</p>
<h3 id="24、-请你来说一说extern“C”"><a href="#24、-请你来说一说extern“C”" class="headerlink" title="24、 请你来说一说extern“C”"></a>24、 请你来说一说extern“C”</h3><p>C++调用C函数需要extern C，因为C语言没有函数重载。</p>
<h3 id="25、请你回答一下new-delete与malloc-free的区别是什么"><a href="#25、请你回答一下new-delete与malloc-free的区别是什么" class="headerlink" title="25、请你回答一下new/delete与malloc/free的区别是什么"></a>25、请你回答一下new/delete与malloc/free的区别是什么</h3><p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h3 id="26、请你说说你了解的RTTI"><a href="#26、请你说说你了解的RTTI" class="headerlink" title="26、请你说说你了解的RTTI"></a>26、请你说说你了解的RTTI</h3><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info</p>
<h3 id="27、-请你说说虚函数表具体是怎样实现运行时多态的"><a href="#27、-请你说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="27、 请你说说虚函数表具体是怎样实现运行时多态的?"></a>27、 请你说说虚函数表具体是怎样实现运行时多态的?</h3><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h3 id="28、请你说说C语言是怎么进行函数调用的？"><a href="#28、请你说说C语言是怎么进行函数调用的？" class="headerlink" title="28、请你说说C语言是怎么进行函数调用的？"></a>28、请你说说C语言是怎么进行函数调用的？</h3><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h3 id="29、请你说说C语言参数压栈顺序？"><a href="#29、请你说说C语言参数压栈顺序？" class="headerlink" title="29、请你说说C语言参数压栈顺序？"></a>29、请你说说C语言参数压栈顺序？</h3><p>从右到左</p>
<h3 id="30、请你说说C-如何处理返回值？"><a href="#30、请你说说C-如何处理返回值？" class="headerlink" title="30、请你说说C++如何处理返回值？"></a>30、请你说说C++如何处理返回值？</h3><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h3 id="31、-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#31、-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="31、 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>31、 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h3><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h3 id="32、-请你回答一下malloc与new区别"><a href="#32、-请你回答一下malloc与new区别" class="headerlink" title="32、 请你回答一下malloc与new区别"></a>32、 请你回答一下malloc与new区别</h3><p>malloc需要给定申请内存的大小，返回的指针需要强转。<br>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</p>
<h3 id="33、-请你说一说select"><a href="#33、-请你说一说select" class="headerlink" title="33、 请你说一说select"></a>33、 请你说一说select</h3><p>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大。</p>
<h3 id="34、-请你说说fork-wait-exec函数"><a href="#34、-请你说说fork-wait-exec函数" class="headerlink" title="34、 请你说说fork,wait,exec函数"></a>34、 请你说说fork,wait,exec函数</h3><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h3 id="35、请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#35、请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="35、请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>35、请你来说一下map和set有什么区别，分别又是怎么实现的？</h3><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map和set区别在于：</p>
<p>（1）==map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。==</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）==map支持下标操作，set不支持下标操作。==map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h3 id="36、请你来介绍一下STL的allocaotr"><a href="#36、请你来介绍一下STL的allocaotr" class="headerlink" title="36、请你来介绍一下STL的allocaotr"></a>36、请你来介绍一下STL的allocaotr</h3><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p>
<p>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p>
<h3 id="37、-请你来说一说STL迭代器删除元素"><a href="#37、-请你来说一说STL迭代器删除元素" class="headerlink" title="37、 请你来说一说STL迭代器删除元素"></a>37、 请你来说一说STL迭代器删除元素</h3><p>1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
<p>2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
<p>3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p>
<h3 id="38、-请你讲讲STL有什么基本组成"><a href="#38、-请你讲讲STL有什么基本组成" class="headerlink" title="38、 请你讲讲STL有什么基本组成"></a>38、 请你讲讲STL有什么基本组成</h3><p>STL主要由：以下几部分组成：<br>==容器 迭代器 仿函数 算法 分配器 配接器==<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h3 id="39、请你说说STL中map与unordered-map"><a href="#39、请你说说STL中map与unordered-map" class="headerlink" title="39、请你说说STL中map与unordered_map"></a>39、请你说说STL中map与unordered_map</h3><p>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<p>2、Multimap</p>
<p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对可重复映射</p>
<h3 id="40、请你说一说vector和list的区别，应用，越详细越好"><a href="#40、请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="40、请你说一说vector和list的区别，应用，越详细越好"></a>40、请你说一说vector和list的区别，应用，越详细越好</h3><p>1、概念：</p>
<p>1）Vector</p>
<p>连续存储的容器，动态数组，在堆上分配空间</p>
<p>底层实现：数组</p>
<p>两倍容量增长：</p>
<p>vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。</p>
<p>如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</p>
<p>性能：</p>
<p>访问：O(1)</p>
<p>插入：在最后插入（空间够）：很快</p>
<p>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>在中间插入（空间够）：内存拷贝</p>
<p>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>删除：在最后删除：很快</p>
<p>在中间删除：内存拷贝</p>
<p>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</p>
<p>2、List</p>
<p>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>底层：双向链表</p>
<p>性能：</p>
<p>访问：随机访问性能很差，只能快速访问头尾节点。</p>
<p>插入：很快，一般是常数开销</p>
<p>删除：很快，一般是常数开销</p>
<p>适用场景：经常插入删除大量数据</p>
<p>2、区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h3 id="41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h3><p>1、迭代器</p>
<p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>2、迭代器和指针的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果</p>
<h3 id="42、请你说一说epoll原理"><a href="#42、请你说一说epoll原理" class="headerlink" title="42、请你说一说epoll原理"></a>42、请你说一说epoll原理</h3><p>int epoll_create(int size);</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</p>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<h3 id="43、请你回答一下STL里resize和reserve的区别"><a href="#43、请你回答一下STL里resize和reserve的区别" class="headerlink" title="43、请你回答一下STL里resize和reserve的区别"></a>43、请你回答一下STL里resize和reserve的区别</h3><p>resize()：改变当前容器内含有元素的数量(size())，</p>
<p>eg: vector<int>v; v.resize(len);  v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</int></p>
<p>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<h3 id="44、请你来说一下C-中类成员的访问权限"><a href="#44、请你来说一下C-中类成员的访问权限" class="headerlink" title="44、请你来说一下C++中类成员的访问权限"></a>44、请你来说一下C++中类成员的访问权限</h3><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
<h3 id="45、-请你来说一下C-中struct和class的区别"><a href="#45、-请你来说一下C-中struct和class的区别" class="headerlink" title="45、 请你来说一下C++中struct和class的区别"></a>45、 请你来说一下C++中struct和class的区别</h3><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</p>
<p>另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p>
<h3 id="46、请你回答一下C-类内可以定义引用数据成员吗"><a href="#46、请你回答一下C-类内可以定义引用数据成员吗" class="headerlink" title="46、请你回答一下C++类内可以定义引用数据成员吗"></a>46、请你回答一下C++类内可以定义引用数据成员吗</h3><p>可以，必须通过成员函数初始化列表初始化。</p>
<h3 id="47、请你回答一下什么是右值引用，跟左值又有什么区别？"><a href="#47、请你回答一下什么是右值引用，跟左值又有什么区别？" class="headerlink" title="47、请你回答一下什么是右值引用，跟左值又有什么区别？"></a>47、请你回答一下什么是右值引用，跟左值又有什么区别？</h3><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
</ol>
<h3 id="48、请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#48、请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="48、请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>48、请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h3><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p>
<p>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h3 id="49、-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#49、-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="49、 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>49、 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h3><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p>
<p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<h3 id="50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块<strong>。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</strong></p>
<p>当进行内存分配时<strong>，Malloc会通过隐式链表遍历所有的空闲块</strong>，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，<strong>一般会通过brk或者mmap系统调用进行申请</strong>。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="51、请你说一说C-的内存管理是怎样的？"><a href="#51、请你说一说C-的内存管理是怎样的？" class="headerlink" title="51、请你说一说C++的内存管理是怎样的？"></a>51、请你说一说C++的内存管理是怎样的？</h3><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h3 id="52、请你来说一下C-C的内存分配"><a href="#52、请你来说一下C-C的内存分配" class="headerlink" title="52、请你来说一下C++/C的内存分配"></a>52、请你来说一下C++/C的内存分配</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272" alt="img"></p>
<p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<p>3G用户空间和1G内核空间</p>
<p>静态区域：</p>
<p>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</p>
<p>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p>
<p>动态区域：</p>
<p>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，<strong>结束地址由brk标识。</strong></p>
<p>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p>
<p>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p>
<h3 id="53、请你回答一下如何判断内存泄漏？"><a href="#53、请你回答一下如何判断内存泄漏？" class="headerlink" title="53、请你回答一下如何判断内存泄漏？"></a>53、请你回答一下如何判断内存泄漏？</h3><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h3 id="54、-请你来说一下什么时候会发生段错误、"><a href="#54、-请你来说一下什么时候会发生段错误、" class="headerlink" title="54、 请你来说一下什么时候会发生段错误、"></a>54、 请你来说一下什么时候会发生段错误、</h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<p>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h3 id="55、-请你来回答一下什么是memory-leak，也就是内存泄漏"><a href="#55、-请你来回答一下什么是memory-leak，也就是内存泄漏" class="headerlink" title="55、 请你来回答一下什么是memory leak，也就是内存泄漏"></a>55、 请你来回答一下什么是memory leak，也就是内存泄漏</h3><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h3 id="56、请你来回答一下new和malloc的区别"><a href="#56、请你来回答一下new和malloc的区别" class="headerlink" title="56、请你来回答一下new和malloc的区别"></a>56、请你来回答一下new和malloc的区别</h3><p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</p>
<p>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p>
<p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p>
<p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
<h3 id="57、-请你来说一下共享内存相关api"><a href="#57、-请你来说一下共享内存相关api" class="headerlink" title="57、 请你来说一下共享内存相关api"></a>57、 请你来说一下共享内存相关api</h3><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。</p>
<p>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h3 id="58、-请你来说一下reactor模型组成"><a href="#58、-请你来说一下reactor模型组成" class="headerlink" title="58、 请你来说一下reactor模型组成"></a>58、 请你来说一下reactor模型组成</h3><p>reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552468262115_CB656C4BF3B7635BECB0F5D128C95303" alt="img"></p>
<p>1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
<p>2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<p>3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
<p>4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
<p>5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。</p>
<h3 id="59、请你说一说C-STL-的内存优化"><a href="#59、请你说一说C-STL-的内存优化" class="headerlink" title="59、请你说一说C++ STL 的内存优化"></a>59、请你说一说C++ STL 的内存优化</h3><p>  1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190414/970829_1555246716341_19203EAD1152E0317EE9B5F6BFE090C6" alt="img"><br>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。<ol start="2">
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。<ol start="3">
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="60、-请你说说select，epoll的区别，原理，性能，限制都说一说"><a href="#60、-请你说说select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="60、 请你说说select，epoll的区别，原理，性能，限制都说一说"></a>60、 请你说说select，epoll的区别，原理，性能，限制都说一说</h3><p>1 IO多路复用</p>
<p>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/826546_1552638064152_94DD1FAB6C2E289FF496A8013E092EA5" alt="img"></p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>2、select</p>
<p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<p>3、poll</p>
<p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>4、epoll</p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h3 id="61、-请问C-11有哪些新特性？"><a href="#61、-请问C-11有哪些新特性？" class="headerlink" title="61、 请问C++11有哪些新特性？"></a>61、 请问C++11有哪些新特性？</h3><p>C++11 最常用的新特性如下：</p>
<p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
<p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
<p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
<p>初始化列表：使用初始化列表来对类进行初始化</p>
<p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
<p>atomic原子操作用于多线程资源互斥操作</p>
<p>新增STL容器array以及tuple</p>
<h3 id="62、请你详细介绍一下C-11中的可变参数模板、右值引用和lambda这几个新特性。"><a href="#62、请你详细介绍一下C-11中的可变参数模板、右值引用和lambda这几个新特性。" class="headerlink" title="62、请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。"></a>62、请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。</h3><p>可变参数模板：</p>
<p>C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号”。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> ... <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;”num is”&lt;&lt;<span class="keyword">sizeof</span> ...(args)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func();//args不含任何参数</p>
<p>func(1);//args包含一个int类型的实参</p>
<p>func(1,2.0)//args包含一个int一个double类型的实参</p>
<p>其中T叫做模板参数包，args叫做函数参数包</p>
<p>省略号作用如下：</p>
<p>1）声明一个包含0到任意个模板参数的参数包</p>
<p>2）在模板定义得右边，可以将参数包展成一个个独立的参数</p>
<p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终递归函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; head &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数包Args …在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。</p>
<p>右值引用:</p>
<p>C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将右值通常是指具有转移语义的对象，比如返回右值引用T&amp;&amp;的函数返回值等。</p>
<p>C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：</p>
<p>T &amp;&amp; a=ReturnRvale();</p>
<p>假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。</p>
<p>基于右值引用可以实现转移语义和完美转发新特性。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/bolgzxy.github.io/page/4/">4</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
