<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/网络编程/计算机网路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/网络编程/计算机网路/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T17:22:27+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"><a href="#1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程" class="headerlink" title="1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"></a>1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程</h2><p>TCP保证可靠性：</p>
<p>（1）序列号、确认应答、超时重传</p>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<p>（3）拥塞控制</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
<p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
<p>TCP建立连接和断开连接的过程：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471554293_3A87D0457A6EE404083BBF3CB192C358" alt="img"></p>
<p>三次握手：</p>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p>四次挥手：</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<h2 id="2、-请你说一说TCP的模型，状态转移"><a href="#2、-请你说一说TCP的模型，状态转移" class="headerlink" title="2、 请你说一说TCP的模型，状态转移"></a>2、 请你说一说TCP的模型，状态转移</h2><p>四层TCP/IP模型如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471617097_2C832BB517B9ED772DCA7DCAD9AFBC75" alt="img"></p>
<p>其状态转移图如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4" alt="img"></p>
<h2 id="3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<p>HTTPS优点：</p>
<p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p>HTTPS缺点：</p>
<p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h2 id="4、-请你说一说HTTP和HTTPS的不同"><a href="#4、-请你说一说HTTP和HTTPS的不同" class="headerlink" title="4、 请你说一说HTTP和HTTPS的不同"></a>4、 请你说一说HTTP和HTTPS的不同</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<h2 id="5、请你说一说HTTP返回码"><a href="#5、请你说一说HTTP返回码" class="headerlink" title="5、请你说一说HTTP返回码"></a>5、请你说一说HTTP返回码</h2><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p>
<p>1xx：指示信息–表示请求已接收，继续处理。</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的详细说明如下。</p>
<p>200 OK：客户端请求成功。</p>
<p>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</p>
<p>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</p>
<p>301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</p>
<p>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</p>
<p>304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</p>
<p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
<p>t Found：请求资源不存在，举个例子：输入了错误的URL。</p>
<h2 id="6、-请你说一说IP地址作用，以及MAC地址作用"><a href="#6、-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="6、 请你说一说IP地址作用，以及MAC地址作用"></a>6、 请你说一说IP地址作用，以及MAC地址作用</h2><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<h2 id="7、请介绍一下操作系统中的中断"><a href="#7、请介绍一下操作系统中的中断" class="headerlink" title="7、请介绍一下操作系统中的中断"></a>7、请介绍一下操作系统中的中断</h2><p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
<h2 id="8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议</h2><p>OSI七层模型及其包含的协议如下:</p>
<p>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</p>
<p>数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</p>
<p>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</p>
<p>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</p>
<p>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p>
<p>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p>
<p>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p>
<p>TCP/IP 4层模型包括：</p>
<p>网络接口层：MAC VLAN</p>
<p>网络层:IP ARP ICMP</p>
<p>传输层:TCP UDP</p>
<p>应用层:HTTP DNS SMTP</p>
<h2 id="9、-请你说一说TCP的三次握手和四次挥手的过程及原因"><a href="#9、-请你说一说TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="9、 请你说一说TCP的三次握手和四次挥手的过程及原因"></a>9、 请你说一说TCP的三次握手和四次挥手的过程及原因</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TCP的三次握手过程如下：</p>
<p>C-&gt; SYN -&gt; S</p>
<p>S-&gt;SYN/ACK-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
<p>TCP的四次挥手过程如下：</p>
<p>C-&gt;FIN-&gt;S</p>
<p>S-&gt;ACK-&gt;C</p>
<p>S-&gt;FIN-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p>
<h2 id="10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h2><p>浏览器中输入URL</p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<p>1、DNS协议，http协议，https协议属于应用层</p>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<p>2、TCP/UDP属于传输层</p>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<p>3、IP协议，ARP协议属于网络层</p>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br>4、数据链路层</p>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br>5、物理层</p>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<h2 id="11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"><a href="#11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"></a>11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？</h2><p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。</p>
<p>1、慢开始</p>
<p>最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。</p>
<p>2、拥塞避免</p>
<p>每经过一个往返时间RTT，cwnd就增长1。</p>
<p>在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p>
<p>3、快重传</p>
<p>接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p>
<p>4、快恢复</p>
<p>当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</p>
<p>采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p>
<p>达到什么情况的时候开始减慢增长的速度？</p>
<p>采用慢开始和拥塞避免算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p>
</li>
</ol>
<p>采用快恢复和快重传算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p>
</li>
</ol>
<h3 id="12、请你说说TCP-IP数据链路层的交互过程"><a href="#12、请你说说TCP-IP数据链路层的交互过程" class="headerlink" title="12、请你说说TCP/IP数据链路层的交互过程"></a>12、请你说说TCP/IP数据链路层的交互过程</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>
<h3 id="13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h3><p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
<h2 id="14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"><a href="#14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）" class="headerlink" title="14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"></a>14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）</h2><p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
<h2 id="●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
<h2 id="●-请问TCP三次握手是怎样的？"><a href="#●-请问TCP三次握手是怎样的？" class="headerlink" title="● 请问TCP三次握手是怎样的？"></a>● 请问TCP三次握手是怎样的？</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请问tcp握手为什么两次不可以？为什么不用四次？"><a href="#●-请问tcp握手为什么两次不可以？为什么不用四次？" class="headerlink" title="● 请问tcp握手为什么两次不可以？为什么不用四次？"></a>● 请问tcp握手为什么两次不可以？为什么不用四次？</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
<p>不用四次：</p>
<h2 id="●-请你来说一下TCP拥塞控制？"><a href="#●-请你来说一下TCP拥塞控制？" class="headerlink" title="● 请你来说一下TCP拥塞控制？"></a>● 请你来说一下TCP拥塞控制？</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。</p>
<h2 id="●-TCP和UDP的区别和各自适用的场景"><a href="#●-TCP和UDP的区别和各自适用的场景" class="headerlink" title="● TCP和UDP的区别和各自适用的场景"></a>● TCP和UDP的区别和各自适用的场景</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP和UDP区别</p>
<p>1） 连接</p>
<p>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</p>
<p>UDP无连接。</p>
<p>2） 服务对象</p>
<p>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p>
<p>UDP支持一对一，一对多，多对一，多对多的交互通信。</p>
<p>3） 可靠性</p>
<p>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</p>
<p>UDP是尽最大努力交付，不保证可靠交付。</p>
<p>4）拥塞控制，流量控制</p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性。</p>
<p>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p>
<p>5） 报文长度</p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p>
<p>6)   首部开销</p>
<p>TCP首部开销大，首部20个字节。</p>
<p>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p>
<p>2）TCP和UDP适用场景</p>
<p>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h2 id="●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态"><a href="#●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态" class="headerlink" title="● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态"></a>● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP连接（三次握手）过程：</p>
<p>客户端A：发送SYN连接报文，序列号为x，进入SYNC-SENT状态。</p>
<p>服务端B：发送SYN连接确认报文（SYN=1，ACK = 1），序列号为y（seq = y），确认报文x（ack = x + 1），进入SYNC-RCVD状态。</p>
<p>客户端A：发送ACK确认报文（ACK = 1），序列号为x+1（seq = x + 1），确认报文y+1（ack = y + 1），进入ESTABLISHED状态。</p>
<p>服务器B：收到后进入ESTABLISHED状态。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654514757_B2186A0EB2E4E9A381061A1CC4706248" alt="img"></p>
<p>2）三次握手原因：</p>
<p>三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。</p>
<p>服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。</p>
<p>3） TCP释放（四次分手）过程：</p>
<p>服务端A：发送FIN报文（FIN = 1），序列号为u（seq = u），进入FIN-WAIT 1状态。</p>
<p>客户端B：发送ACK确认报文（ACK = 1），序列号为v（seq = v），确认报文u（ack = u + 1），进入CLOSE-WAIT状态，继续传送数据。</p>
<p>服务端A：收到上述报文进入FIN-WAIT2状态，继续接受B传输的数据。</p>
<p>客户端B：数据传输完毕后，发送FIN报文（FIN = 1，ACK = 1），序列号为w（seq = w），确认报文u（ack = u + 1），进入LAST-ACK状态。</p>
<p>服务端A：发送ACK确认报文（ACK = 1），序列号为u+1（seq = u + 1），确认报文w（ack = w + 1），进入TIME-WAIT状态，等待2MSL（最长报文段寿命），进入CLOSED状态。</p>
<p>客户端B：收到后上述报文后进入CLOSED状态。</p>
<p>4）为什么TCP协议终止链接要四次？</p>
<p>1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。</p>
<p>2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。</p>
<p>3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。</p>
<p>4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。</p>
<p>5）2MSL意义：</p>
<p>1、保证最后一次握手报文能到B，能进行超时重传。</p>
<p>2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</p>
<h2 id="●-请你来说一说http协议"><a href="#●-请你来说一说http协议" class="headerlink" title="● 请你来说一说http协议"></a>● 请你来说一说http协议</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）HTTP协议：</p>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>2）HTTP协议特点</p>
<p>1、简单快速：</p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3、无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4、无状态：</p>
<p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
<p>3）HTTP过程概述：</p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>HTTP 请求/响应的步骤如下：</p>
<p>1、客户端连接到Web服务器</p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>。</p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>4、举例：</p>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
<h2 id="●-请你来说一下GET和POST的区别"><a href="#●-请你来说一下GET和POST的区别" class="headerlink" title="● 请你来说一下GET和POST的区别"></a>● 请你来说一下GET和POST的区别</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概括</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
<p>2、区别：</p>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而post支持多种编码方式。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<h2 id="●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数"><a href="#●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数"></a>● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）基于TCP的socket：</p>
<p>1、服务器端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2绑定IP地址、端口等信息到socket上，用函数bind()</p>
<p>3设置允许的最大连接数，用函数listen()</p>
<p>4接收客户端上来的连接，用函数accept()</p>
<p>5收发数据，用函数send()和recv()，或者read()和write()</p>
<p>6关闭网络连接</p>
<p>2、客户端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2设置要连接的对方的IP地址和端口等属性</p>
<p>3连接服务器，用函数connect()</p>
<p>4收发数据，用函数send()和recv()，或read()和write()</p>
<p>5关闭网络连接</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7" alt="img"></p>
<p>2）基于UDP的socket：</p>
<p>1、服务器端流程</p>
<p>1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p>
<p>2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p>
<p>3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p>
<p>4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p>
<p>5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p>
<p>6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p>
<p>2、客户端流程</p>
<p>1建立套接字文件描述符，socket()。</p>
<p>2设置服务器地址和端口，struct sockaddr。</p>
<p>3向服务器发送数据，sendto()。</p>
<p>4接收服务器的数据，recvfrom()。</p>
<p>5关闭套接字，close()。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="img"></p>
<h2 id="●-请你来说一下数字证书是什么，里面都包含那些内容"><a href="#●-请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="● 请你来说一下数字证书是什么，里面都包含那些内容"></a>● 请你来说一下数字证书是什么，里面都包含那些内容</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）概念：</p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p>2）数字证书颁发过程：</p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p>3）内容：</p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<p>1、证书的版本信息；</p>
<p>2、证书的序列号，每个证书都有一个唯一的证书序列号；</p>
<p>3、证书所使用的签名算法；</p>
<p>4、证书的发行机构名称，命名规则一般采用X.500格式；</p>
<p>5、证书的有效期，通用的证书一般采用UTC时间格式；</p>
<p>6、证书所有人的名称，命名规则一般采用X.500格式；</p>
<p>7、证书所有人的公开密钥；</p>
<p>8、证书发行者对证书的签名。</p>
<h2 id="●-请你来介绍一下udp的connect函数"><a href="#●-请你来介绍一下udp的connect函数" class="headerlink" title="● 请你来介绍一下udp的connect函数"></a>● 请你来介绍一下udp的connect函数</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<p>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</p>
<p>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p>
<p>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</p>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
<h2 id="●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"><a href="#●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？" class="headerlink" title="● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"></a>● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>三次握手</p>
<p>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复syn1,ack(syn0+1)<br>3.客户端收到syn1，回复ack(syn1+1)<br>四次挥手(这里以客户端主动断开为例)<br>1.客户端发送fin<br>2.服务端收到fin,回复ack,然后服务器去处理其他事<br>3.服务器事情处理完，回复fin<br>4.客户端回复ack<br>为什么用三次握手<br>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：<br>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复ack(syn0+1)<br>3.服务器发送syn1<br>3.客户端收到syn1，回复ack(syn1+1)<br>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
<h2 id="●-请你说一下阻塞，非阻塞，同步，异步"><a href="#●-请你说一下阻塞，非阻塞，同步，异步" class="headerlink" title="● 请你说一下阻塞，非阻塞，同步，异步"></a>● 请你说一下阻塞，非阻塞，同步，异步</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p>
<p>同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步</p>
<h2 id="●-请你讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#●-请你讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="● 请你讲述一下Socket编程的send() recv() accept() socket()函数？"></a>● 请你讲述一下Socket编程的send() recv() accept() socket()函数？</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<h2 id="●-请你说一下http协议会话结束标志怎么截出来？"><a href="#●-请你说一下http协议会话结束标志怎么截出来？" class="headerlink" title="● 请你说一下http协议会话结束标志怎么截出来？"></a>● 请你说一下http协议会话结束标志怎么截出来？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>看tcp连接是否有断开的四部挥手阶段。</p>
<h2 id="●-请你说一说三次握手"><a href="#●-请你说一说三次握手" class="headerlink" title="● 请你说一说三次握手"></a>● 请你说一说三次握手</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请你说一说四次挥手"><a href="#●-请你说一说四次挥手" class="headerlink" title="● 请你说一说四次挥手"></a>● 请你说一说四次挥手</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复ack(syn0+1)</p>
<h2 id="●-请你说一说TCP-IP数据链路层的交互过程"><a href="#●-请你说一说TCP-IP数据链路层的交互过程" class="headerlink" title="● 请你说一说TCP/IP数据链路层的交互过程"></a>● 请你说一说TCP/IP数据链路层的交互过程</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/操作系统/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/操作系统/操作系统/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T16:40:02+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h3><p>基本概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，==实现进程内部的并发==；==线程是操作系统可识别的最小执行和调度单位。==每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。==每个线程完成不同的任务==，但是共享同一地址空间（==也就是同样的动态内存，映射文件，目标代码等==等），打开的文件队列和其他内核资源。</p>
<p>区别：</p>
<p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫==运行时段==，用来存放所有局部变量和临时变量。）</p>
<p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
<p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——==需要进程同步和互斥手段==的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
<p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7.进程间不会相互影响 ；==线程一个线程挂掉将导致整个进程挂掉==</p>
<p>8.进程适应于多核、多机分布；线程适用于多核</p>
<p>进程间通信的方式：</p>
<p>进程间通信主要包括==管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。==</p>
<p>1.管道：</p>
<p>管道主要包括==无名管道和命名管道==:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p>1.1 普通管道PIPE：</p>
<p>1)==它是半双工的==（即数据只能在一个方向上流动），具有固定的读端和写端</p>
<p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
<p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p>1.2 命名管道FIFO：</p>
<p>1==)FIFO可以在无关的进程之间交换数据==</p>
<p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<ol start="2">
<li>系统IPC：</li>
</ol>
<p>2.1 消息队列</p>
<p>消息队列，是消息的==链接表==，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；权限得进程则可以从消息队列中读取信息；</p>
<p>特点：</p>
<p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>2.2 信号量semaphore</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。==信号量用于实现进程间的互斥与同步==，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<p>1)==信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。==</p>
<p>2)信号量基于操作系统的 PV 操作，==程序对信号量的操作都是原子操作。==</p>
<p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>4)支持信号量组。</p>
<p>2.3 信号signal</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>2.4 共享内存（Shared Memory）</p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如==互斥锁和信号量等==</p>
<p>特点：</p>
<p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
<p>2)因为多个进程可以同时操作，所以需要进行同步</p>
<p>3)信号量+共享内存通常结合在一起使用，==信号量用来同步对共享内存的访问==</p>
<p>3.套接字SOCKET：</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<p>线程间通信的方式:</p>
<p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>==互斥量Synchronized/Lock==：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>==信号量Semphare==：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="2、请你说一说Linux虚拟地址空间"><a href="#2、请你说一说Linux虚拟地址空间" class="headerlink" title="2、请你说一说Linux虚拟地址空间"></a>2、请你说一说Linux虚拟地址空间</h3><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p>虚拟内存的好处：</p>
<p>1.扩大地址空间；</p>
<p>2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
<p>3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
<p>4==.当进程通信时，可采用虚存共享的方式实现。==</p>
<p>5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p>
<p>6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p>
<p>7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
<p>虚拟内存的代价：</p>
<p>1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</p>
<p>2.虚拟地址到物理地址的转换，增加了指令的执行时间。</p>
<p>3.页面的换入换出需要磁盘I/O，这是很耗时的</p>
<p>4.如果一页中只有一部分数据，会浪费内存。</p>
<h3 id="3、-请你说一说操作系统中的程序的内存结构"><a href="#3、-请你说一说操作系统中的程序的内存结构" class="headerlink" title="3、 请你说一说操作系统中的程序的内存结构"></a>3、 请你说一说操作系统中的程序的内存结构</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<h3 id="4、请你说一说操作系统中的缺页中断"><a href="#4、请你说一说操作系统中的缺页中断" class="headerlink" title="4、请你说一说操作系统中的缺页中断"></a>4、请你说一说操作系统中的缺页中断</h3><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p>
<p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<p>1、在指令执行期间产生和处理缺页中断信号</p>
<p>2、一条指令在执行期间，可能产生多次缺页中断</p>
<p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p>
<h3 id="5、-请你回答一下fork和vfork的区别"><a href="#5、-请你回答一下fork和vfork的区别" class="headerlink" title="5、 请你回答一下fork和vfork的区别"></a>5、 请你回答一下fork和vfork的区别</h3><p>fork的基础知识：</p>
<p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>vfork的基础知识：</p>
<p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void);</p>
<p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。==vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像==。通过这样的方式，vfork( )避免了地址空间的按页复制。==在这个过程中，父进程和子进程共享相同的地址空间和页表项。==实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p>
<p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p>
<p>补充知识点：写时复制</p>
<p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p>
<p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。==只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。==</p>
<p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p>
<p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
<p>fork和vfork的区别：</p>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
<p>4.当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
<h3 id="6、-请问如何修改文件最大句柄数？"><a href="#6、-请问如何修改文件最大句柄数？" class="headerlink" title="6、 请问如何修改文件最大句柄数？"></a>6、 请问如何修改文件最大句柄数？</h3><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</li>
</ol>
<p>首先用ulimit -a查询Linux相关的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 94739</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 94739</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>其中，open files就是最大文件句柄数，默认是1024个。</p>
<p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p>
<ol start="2">
<li>对所有进程都有效的方法，修改Linux系统参数</li>
</ol>
<p>vi /etc/security/limits.conf 添加</p>
<p>*　　soft　　nofile　　65536</p>
<p>*　　hard　　nofile　　65536</p>
<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h3 id="7、请你说一说并发-concurrency-和并行-parallelism"><a href="#7、请你说一说并发-concurrency-和并行-parallelism" class="headerlink" title="7、请你说一说并发(concurrency)和并行(parallelism)"></a>7、请你说一说并发(concurrency)和并行(parallelism)</h3><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<h3 id="8、请问MySQL的端口号是多少，如何修改这个端口号"><a href="#8、请问MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="8、请问MySQL的端口号是多少，如何修改这个端口号"></a>8、请问MySQL的端口号是多少，如何修改这个端口号</h3><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>查看端口号：</p>
<p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>
<h3 id="9、请你说一说操作系统中的页表寻址"><a href="#9、请你说一说操作系统中的页表寻址" class="headerlink" title="9、请你说一说操作系统中的页表寻址"></a>9、请你说一说操作系统中的页表寻址</h3><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>Linux最初的两级页表机制：</p>
<p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p>
<p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p>
<p>* PTE(Page Table Entry)：中间10位，页表入口索引</p>
<p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p>
<p>Linux的三级页表机制：</p>
<p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p>
<p>字段            描述                        位数</p>
<p>cr3            指向一个PDPT            crs寄存器存储</p>
<p>PGD        指向PDPT中4个项中的一个    位31~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p>
<p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p>
<p>Linux的四级页表机制：</p>
<p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p>
<p>字段            描述                        位数</p>
<p>PML4        指向一个PDPT            位47~39</p>
<p>PGD        指向PDPT中4个项中的一个    位38~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p>
<p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p>
<h3 id="10、-请你说一说有了进程，为什么还要有线程？"><a href="#10、-请你说一说有了进程，为什么还要有线程？" class="headerlink" title="10、 请你说一说有了进程，为什么还要有线程？"></a>10、 请你说一说有了进程，为什么还要有线程？</h3><p>线程产生的原因：</p>
<p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p>
<p>进程在同一时间只能干一件事</p>
<p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p>
<p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p>
<p>从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
<p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（</p>
<p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
<p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
<h3 id="11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h3><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p>
<h3 id="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h3><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<p>SP:堆栈指针，指向当前栈的栈顶地址</p>
<p>PC:程序计数器，存储下一条将要执行的指令</p>
<p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>
<h3 id="13、-请你说一说线程间的同步方式，最好说出具体的系统调用"><a href="#13、-请你说一说线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="13、 请你说一说线程间的同步方式，最好说出具体的系统调用"></a>13、 请你说一说线程间的同步方式，最好说出具体的系统调用</h3><p>信号量</p>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</p>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</p>
<p>其系统调用为：</p>
<p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p>
<p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<p>互斥量</p>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<p>pthread_mutex_init:初始化互斥锁</p>
<p>pthread_mutex_destroy：销毁互斥锁</p>
<p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p>
<p>条件变量</p>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<p>pthread_cond_init:初始化条件变量</p>
<p>pthread_cond_destroy：销毁条件变量</p>
<p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p>
<p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p>
<h3 id="14、请你说一下多线程和多进程的不同"><a href="#14、请你说一下多线程和多进程的不同" class="headerlink" title="14、请你说一下多线程和多进程的不同"></a>14、请你说一下多线程和多进程的不同</h3><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</p>
<h3 id="15、-请你说一说进程和线程的区别"><a href="#15、-请你说一说进程和线程的区别" class="headerlink" title="15、 请你说一说进程和线程的区别"></a>15、 请你说一说进程和线程的区别</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p>
<p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p>
<p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p>
<p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p>
<p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p>
<h3 id="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h3><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p>
<h3 id="17、请你说一说OS缺页置换算法"><a href="#17、请你说一说OS缺页置换算法" class="headerlink" title="17、请你说一说OS缺页置换算法"></a>17、请你说一说OS缺页置换算法</h3><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p>
<p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
<p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
<p>当前最常采用的就是LRU算法。</p>
<h3 id="18、请你说一下多进程和多线程的使用场景"><a href="#18、请你说一下多进程和多线程的使用场景" class="headerlink" title="18、请你说一下多进程和多线程的使用场景"></a>18、请你说一下多进程和多线程的使用场景</h3><p>多进程模型的优势是CPU</p>
<p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p>
<p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p>
<h3 id="19、-请你说一说死锁发生的条件以及如何解决死锁"><a href="#19、-请你说一说死锁发生的条件以及如何解决死锁" class="headerlink" title="19、 请你说一说死锁发生的条件以及如何解决死锁"></a>19、 请你说一说死锁发生的条件以及如何解决死锁</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p>
<p>==互斥条件==：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p>
<p>==请求和保持条件==：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p>
<p>==不可剥夺条件==：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p>==环路等待条件==：进程发生死锁后，必然存在一个进程-资源之间的环形链</p>
<p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p>
<p>资源一次性分配，从而剥夺请求和保持条件</p>
<p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p>
<p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p>
<h3 id="20、请问虚拟内存和物理内存怎么对应"><a href="#20、请问虚拟内存和物理内存怎么对应" class="headerlink" title="20、请问虚拟内存和物理内存怎么对应"></a>20、请问虚拟内存和物理内存怎么对应</h3><p>1、概念：</p>
<p>物理地址(physical address)</p>
<p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。</p>
<p>虚拟地址(virtual memory)</p>
<p>这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p>
<p>之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。</p>
<p>有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。</p>
<p>——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。</p>
<p>2、地址转换</p>
<p>第一步：CPU段式管理中——逻辑地址转线性地址</p>
<p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p>
<p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p>
<p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p>
<p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址</p>
<p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p>
<p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。</p>
<p>GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p>
<p>段起始地址+ 段内偏移量 = 线性地址</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p>
<p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p>
<p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p>
<p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p>
<p>3、把Base + offset，就是要转换的线性地址了。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p>
<p>第一步：页式管理——线性地址转物理地址</p>
<p>再利用其页式内存管理单元，转换为最终物理地址。</p>
<p>linux假的段式管理</p>
<p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。</p>
<p>其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。</p>
<p>所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。</p>
<p>按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p>
<p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p>
<p>linux页式管理</p>
<p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p>
<p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p>
<p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p>
<p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p>
<p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p>
<p>依据以下步骤进行转换：</p>
<p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p>
<p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p>
<p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p>
<p>将页的起始地址与线性地址中最后12位相加。</p>
<p>目的：</p>
<p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p>
<p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p>
<p>64位，PUD和PMD ≠ 0</p>
<h3 id="21、-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#21、-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="21、 请你说一说操作系统中的结构体对齐，字节对齐"></a>21、 请你说一说操作系统中的结构体对齐，字节对齐</h3><p>1、原因：</p>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<p>2、规则</p>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
<p>4、举例</p>
<p>#pragma pack(2)</p>
<p>struct AA {</p>
<p>int a;       //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p>
<p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p>
<p>short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p>
<p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p>
<p>};</p>
<p>#pragma pack()</p>
<h3 id="22、-请你说一下虚拟内存置换的方式"><a href="#22、-请你说一下虚拟内存置换的方式" class="headerlink" title="22、 请你说一下虚拟内存置换的方式"></a>22、 请你说一下虚拟内存置换的方式</h3><p>比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。</p>
<p>1、FIFO（先进先出淘汰算法）</p>
<p>思想：最近刚访问的，将来访问的可能性比较大。</p>
<p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p>
<p>弊端：无法体现页面冷热信息</p>
<p>2、LFU（最不经常访问淘汰算法）</p>
<p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>开销：排序开销。</p>
<p>弊端：缓存颠簸。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p>
<p>3、LRU（最近最少使用替换算法）</p>
<p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p>
<p>优点：LRU算法对热点数据命中率是很高的。</p>
<p>缺陷：</p>
<p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p>
<p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p>
<p>4、LRU-K（LRU-2、LRU-3）</p>
<p>思想：最久未使用K次淘汰算法。</p>
<p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>实现：</p>
<p>1）数据第一次被访问，加入到访问历史列表；</p>
<p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>4）缓存数据队列中被再次访问后，重新排序；</p>
<p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>针对问题：</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>5、2Q</p>
<p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p>
<p>实现：</p>
<p>1）新访问的数据插入到FIFO队列；</p>
<p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>5）LRU队列淘汰末尾的数据。</p>
<p>针对问题：LRU的缓存污染</p>
<p>弊端：</p>
<p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p>
<h3 id="23、-请你说一下多线程，线程同步的几种方式"><a href="#23、-请你说一下多线程，线程同步的几种方式" class="headerlink" title="23、 请你说一下多线程，线程同步的几种方式"></a>23、 请你说一下多线程，线程同步的几种方式</h3><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<p>线程间通信的方式:</p>
<p>1、临界区：</p>
<p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>2、互斥量 Synchronized/Lock：</p>
<p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>3、信号量 Semphare：</p>
<p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>4、事件(信号)，Wait/Notify：</p>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h3><p>1、互斥锁和读写锁区别：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<p>1）读写锁区分读者和写者，而互斥锁不区分</p>
<p>2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p>
<p>2、Linux的4种锁机制：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
<p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p>
<h3 id="25、请回答一下进程和线程的区别"><a href="#25、请回答一下进程和线程的区别" class="headerlink" title="25、请回答一下进程和线程的区别"></a>25、请回答一下进程和线程的区别</h3><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<h3 id="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h3><p>1、进程的五种基本状态：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完</p>
<p>2、交换技术</p>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p>
<p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
<p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
<p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
<p>从而出现了：</p>
<p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p>
<p>执行     ——  静止就绪         （时间片用完）</p>
<h3 id="27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><p>1、程序内存管理：</p>
<p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74" alt="img"></p>
<p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
<p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
<p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
<p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
<p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
<p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p>可执行程序在运行时又多出两个区域：栈区和堆区。</p>
<p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
<p>2、A* a = new A; a-&gt;i = 10：</p>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p>
<p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p>
<p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p>
<p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
<h3 id="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3><p>1、static修饰符</p>
<p>1）static修饰成员变量</p>
<p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
<p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
<p>2）static修饰成员函数</p>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p>
<p>Static修饰的成员函数，在代码区分配内存。</p>
<p>2、C++继承和虚函数</p>
<p>C++多态分为静态多态和动态多态。==静态多态是通过重载和模板技术实现==，在编译的时候确定。==动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。==</p>
<p>动态多态实现有几个条件：</p>
<p>(1) 虚函数；</p>
<p>(2) 一个基类的指针或引用指向派生类的对象；</p>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
<p>3、virtual修饰符</p>
<p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
<p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p>
<p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p>
<h3 id="29、请你回答一下软链接和硬链接区别"><a href="#29、请你回答一下软链接和硬链接区别" class="headerlink" title="29、请你回答一下软链接和硬链接区别"></a>29、请你回答一下软链接和硬链接区别</h3><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p>
<p>若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。</p>
<p>若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p>
<h3 id="30、请问什么是大端小端以及如何判断大端小端"><a href="#30、请问什么是大端小端以及如何判断大端小端" class="headerlink" title="30、请问什么是大端小端以及如何判断大端小端"></a>30、请问什么是大端小端以及如何判断大端小端</h3><p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470995798_E694EFF3D7CC8BA2BB2EE978CE1EB6FB" alt="img"></p>
<h3 id="31、请你回答一下静态变量什么时候初始化"><a href="#31、请你回答一下静态变量什么时候初始化" class="headerlink" title="31、请你回答一下静态变量什么时候初始化"></a>31、请你回答一下静态变量什么时候初始化</h3><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
<h3 id="32、请你说一说用户态和内核态区别"><a href="#32、请你说一说用户态和内核态区别" class="headerlink" title="32、请你说一说用户态和内核态区别"></a>32、请你说一说用户态和内核态区别</h3><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<h3 id="33、如何设计server，使得能够接收多个客户端的请求"><a href="#33、如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="33、如何设计server，使得能够接收多个客户端的请求"></a>33、如何设计server，使得能够接收多个客户端的请求</h3><p>多线程，线程池，io复用</p>
<h3 id="34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h3><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h3 id="35、-怎么唤醒被阻塞的socket线程？"><a href="#35、-怎么唤醒被阻塞的socket线程？" class="headerlink" title="35、 怎么唤醒被阻塞的socket线程？"></a>35、 怎么唤醒被阻塞的socket线程？</h3><p>给阻塞时候缺少的资源</p>
<h3 id="36、-怎样确定当前线程是繁忙还是阻塞？"><a href="#36、-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="36、 怎样确定当前线程是繁忙还是阻塞？"></a>36、 怎样确定当前线程是繁忙还是阻塞？</h3><p>使用ps命令查看</p>
<h3 id="37、请问就绪状态的进程在等待什么？"><a href="#37、请问就绪状态的进程在等待什么？" class="headerlink" title="37、请问就绪状态的进程在等待什么？"></a>37、请问就绪状态的进程在等待什么？</h3><p>被调度使用cpu的运行权</p>
<h3 id="38、请你说一说多线程的同步，锁的机制"><a href="#38、请你说一说多线程的同步，锁的机制" class="headerlink" title="38、请你说一说多线程的同步，锁的机制"></a>38、请你说一说多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行</p>
<h3 id="39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="40、-windows消息机制知道吗，请说一说"><a href="#40、-windows消息机制知道吗，请说一说" class="headerlink" title="40、 windows消息机制知道吗，请说一说"></a>40、 windows消息机制知道吗，请说一说</h3><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h3 id="41、C-的锁你知道几种"><a href="#41、C-的锁你知道几种" class="headerlink" title="41、C++的锁你知道几种?"></a>41、C++的锁你知道几种?</h3><p>锁包括互斥锁，条件变量，自旋锁和读写锁</p>
<h3 id="42、-说一说你用到的锁"><a href="#42、-说一说你用到的锁" class="headerlink" title="42、 说一说你用到的锁"></a>42、 说一说你用到的锁</h3><p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p>
<h3 id="43、请你说一说死锁产生的必要条件？"><a href="#43、请你说一说死锁产生的必要条件？" class="headerlink" title="43、请你说一说死锁产生的必要条件？"></a>43、请你说一说死锁产生的必要条件？</h3><p>1.互斥条件：一个资源每次只能被一个进程使用。</p>
<h3 id="44、-请你说一说内存溢出和内存泄漏"><a href="#44、-请你说一说内存溢出和内存泄漏" class="headerlink" title="44、 请你说一说内存溢出和内存泄漏"></a>44、 请你说一说内存溢出和内存泄漏</h3><p>1、内存溢出</p>
<p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<p>内存溢出原因：</p>
<p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p>
<p>集合类中有对对象的引用，使用完后未清空，使得不能回收</p>
<p>代码中存在死循环或循环产生过多重复的对象实体</p>
<p>使用的第三方软件中的BUG</p>
<p>启动参数内存值设定的过小</p>
<p>2、内存泄漏</p>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<p>1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
<h3 id="45、进程和线程的区别，你都使用什么线程模型"><a href="#45、进程和线程的区别，你都使用什么线程模型" class="headerlink" title="45、进程和线程的区别，你都使用什么线程模型"></a>45、进程和线程的区别，你都使用什么线程模型</h3><p>1）进程和线程区别</p>
<p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<p>2、常用线程模型</p>
<p>1、Future模型</p>
<p>该模型通常在使用的时候需要结合Callable接口配合使用。</p>
<p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p>
<p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p>
<p>2、fork&amp;join模型</p>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
<p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
<p>3、actor模型</p>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
<p>4、生产者消费者模型</p>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p>
<p>5、master-worker模型</p>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
<h3 id="46、请你来说一说协程"><a href="#46、请你来说一说协程" class="headerlink" title="46、请你来说一说协程"></a>46、请你来说一说协程</h3><p>1、概念：</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def A() :</span><br><span class="line">print &apos;1&apos;</span><br><span class="line">print &apos;2&apos;</span><br><span class="line">print &apos;3&apos;</span><br><span class="line">def B() :</span><br><span class="line">print &apos;x&apos;</span><br><span class="line">print &apos;y&apos;</span><br><span class="line">print &apos;z&apos;</span><br></pre></td></tr></table></figure>

<p>由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
<p>2）协程和线程区别</p>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>3）其他</p>
<p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
<h3 id="47、-系统调用是什么，你用过哪些系统调用"><a href="#47、-系统调用是什么，你用过哪些系统调用" class="headerlink" title="47、 系统调用是什么，你用过哪些系统调用"></a>47、 系统调用是什么，你用过哪些系统调用</h3><p>1）概念：</p>
<p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p>
<p>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p>
<p>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p>
<p>2）系统调用举例：</p>
<p>对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include&lt;stdio.h&gt;``#include&lt;stdlib.h&gt;``#include&lt;string.h&gt;``#include&lt;errno.h&gt;``#include&lt;unistd.h&gt;``#include&lt;sys/types.h&gt;``#include&lt;sys/stat.h&gt;``#include&lt;fcntl.h&gt;``int` `main(``int` `argc, ``char` `*argv[])``&#123;``    ``if` `(argc&lt;``2``)``        ``return` `0``;``    ``//用读写追加方式打开一个已经存在的文件``    ``int` `fd = open(argv[``1``], O_RDWR | O_APPEND);``    ``if` `(fd == -``1``)``    ``&#123;``        ``printf(``&quot;error is %s\n&quot;``, strerror(errno));``    ``&#125;``    ``else``    ``&#123;``        ``//打印文件描述符号``        ``printf(``&quot;success fd = %d\n&quot;``, fd);``        ``char` `buf[``100``];``        ``memset(buf, ``0``, sizeof(buf));``        ``strcpy(buf, ``&quot;hello world\n&quot;``);``        ``write(fd, buf, strlen(buf));``        ``close(fd);``    ``&#125;``    ``return` `0``;``&#125;`</span><br></pre></td></tr></table></figure>

<p>还有写数据write，创建进程fork，vfork等都是系统调用。</p>
<h3 id="48、-请你来手写一下fork调用示例"><a href="#48、-请你来手写一下fork调用示例" class="headerlink" title="48、 请你来手写一下fork调用示例"></a>48、 请你来手写一下fork调用示例</h3><p>1、概念：</p>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>2、fork实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">signal(SIGCHLD, SIG_IGN);</span><br><span class="line">printf(&quot;before fork pid:%d\n&quot;, getpid());</span><br><span class="line">int abc = 10;</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>

<p>if (pid == -1) {           //错误返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror(&quot;tile&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if (pid &gt; 0) {              //父进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc++;</span><br><span class="line">printf(&quot;parent:pid:%d \n&quot;, getpid());</span><br><span class="line">printf(&quot;abc:%d \n&quot;, abc);</span><br><span class="line">sleep(20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if (pid == 0) {       //子进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`abc++;``printf``(``&quot;child:%d,parent: %d\n&quot;``, getpid(), getppid());``printf``(``&quot;abc:%d&quot;``, abc);``&#125;``printf``(``&quot;fork after...\n&quot;``);`` ``&#125;`</span><br></pre></td></tr></table></figure>

<h3 id="49、-请你来说一说用户态到内核态的转化原理"><a href="#49、-请你来说一说用户态到内核态的转化原理" class="headerlink" title="49、 请你来说一说用户态到内核态的转化原理"></a>49、 请你来说一说用户态到内核态的转化原理</h3><p>1）用户态切换到内核态的3种方式</p>
<p>1、系统调用</p>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>2、异常</p>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
<p>3、外围设备的中断</p>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>2）切换操作</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<h3 id="50、请你说一下源码到可执行文件的过程"><a href="#50、请你说一下源码到可执行文件的过程" class="headerlink" title="50、请你说一下源码到可执行文件的过程"></a>50、请你说一下源码到可执行文件的过程</h3><p>1）预编译</p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的注释，“//”和“/**/”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p>2）编译</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p>3）汇编</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p>4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2、动态链接：</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h3 id="51、请你来说一下微内核与宏内核"><a href="#51、请你来说一下微内核与宏内核" class="headerlink" title="51、请你来说一下微内核与宏内核"></a>51、请你来说一下微内核与宏内核</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<p>优点：效率高。</p>
<p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p>
<p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p>
<h3 id="52、请你说一下僵尸进程"><a href="#52、请你说一下僵尸进程" class="headerlink" title="52、请你说一下僵尸进程"></a>52、请你说一下僵尸进程</h3><p>1）正常进程</p>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<p>1进程号the process ID</p>
<p>2退出状态the termination status of the process</p>
<p>3运行时间the amount of CPU time taken by the process等</p>
<p>2）孤儿进程</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>3）僵尸进程</p>
<p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p>危害：</p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>外部消灭：</p>
<p>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p>
<p>内部解决：</p>
<p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
<h3 id="53、请问GDB调试用过吗，什么是条件断点"><a href="#53、请问GDB调试用过吗，什么是条件断点" class="headerlink" title="53、请问GDB调试用过吗，什么是条件断点"></a>53、请问GDB调试用过吗，什么是条件断点</h3><p>1、GDB调试</p>
<p>GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p>
<p>GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p>
<p>2、条件断点</p>
<p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p>
<p>例如：(gdb)break 666 if testsize==100</p>
<h3 id="54、请你来介绍一下5种IO模型"><a href="#54、请你来介绍一下5种IO模型" class="headerlink" title="54、请你来介绍一下5种IO模型"></a>54、请你来介绍一下5种IO模型</h3><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</p>
<p>3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。<br>4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h3 id="55、请你说一说异步编程的事件循环"><a href="#55、请你说一说异步编程的事件循环" class="headerlink" title="55、请你说一说异步编程的事件循环"></a>55、请你说一说异步编程的事件循环</h3><p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
<h3 id="56、请你回答一下操作系统为什么要分内核态和用户态"><a href="#56、请你回答一下操作系统为什么要分内核态和用户态" class="headerlink" title="56、请你回答一下操作系统为什么要分内核态和用户态"></a>56、请你回答一下操作系统为什么要分内核态和用户态</h3><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
<h3 id="57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache"></a>57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h3><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache</p>
<h3 id="58、请你说一下多线程的同步，锁的机制"><a href="#58、请你说一下多线程的同步，锁的机制" class="headerlink" title="58、请你说一下多线程的同步，锁的机制"></a>58、请你说一下多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<h3 id="59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="60、-请问怎么实现线程池"><a href="#60、-请问怎么实现线程池" class="headerlink" title="60、 请问怎么实现线程池"></a>60、 请问怎么实现线程池</h3><p>1.设置一个生产者消费者队列，作为临界资源</p>
<h3 id="61、-Linux下怎么得到一个文件的100到200行"><a href="#61、-Linux下怎么得到一个文件的100到200行" class="headerlink" title="61、 Linux下怎么得到一个文件的100到200行"></a>61、 Linux下怎么得到一个文件的100到200行</h3><p>sed -n ‘100,200p’ inputfile</p>
<p>awk ‘NR&gt;=100&amp;&amp;NR&lt;=200{print}’ inputfile</p>
<p>head -200 inputfile|tail -100</p>
<h3 id="62、-请你来说一下awk的使用"><a href="#62、-请你来说一下awk的使用" class="headerlink" title="62、 请你来说一下awk的使用"></a>62、 请你来说一下awk的使用</h3><p>1）作用：</p>
<p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<p>2）用法：</p>
<p>awk [-F  field-separator]  ‘commands’  input-file(s)</p>
<p>3）内置变量</p>
<table>
<thead>
<tr>
<th>ARGC</th>
<th>命令行参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody></table>
<p>4）实例：</p>
<p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p>
<p>&gt; ls -l | awk ‘{print $5 “\t” $9}’</p>
<p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p>
<p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l | awk &apos;BEGIN &#123;COUNT = -1; print &quot;BEGIN COUNT&quot;&#125;</span><br><span class="line">&#123;COUNT = COUNT + 1; print COUNT&quot;\t&quot;$5&quot;\t&quot;$9&#125;</span><br><span class="line">END &#123;print &quot;END, COUNT = &quot;COUNT&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p>
<p>3、找到当前文件夹下所有的子文件夹,并显示排序</p>
<p>&gt; ls -l | awk ‘BEGIN {print “BEGIN COUNT”} /4096/{print NR”\t”$5”\t”$9}</p>
<p>END {print “END”}’</p>
<p>* /4096/ 正则匹配式子</p>
<p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p>
<h3 id="63、-请你来说一下linux内核中的Timer-定时器机制"><a href="#63、-请你来说一下linux内核中的Timer-定时器机制" class="headerlink" title="63、 请你来说一下linux内核中的Timer 定时器机制"></a>63、 请你来说一下linux内核中的Timer 定时器机制</h3><p>1）低精度时钟</p>
<p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：</p>
<p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p>
<p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p>
<p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p>
<p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p>
<p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p>
<p>2）高精度时钟</p>
<p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p>
<p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p>
<p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p>
<p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p>
<p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p>
<p>hrtimer的工作原理：</p>
<p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p>
<p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p>
<p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p>
<p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p>
<p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p>
<p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p>
<p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/C++基础知识/基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/C++基础知识/基础知识/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T14:55:50+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、说一下static关键字的作用"><a href="#1、说一下static关键字的作用" class="headerlink" title="1、说一下static关键字的作用"></a>1、说一下static关键字的作用</h3><ol>
<li>全局静态变量</li>
</ol>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<ol start="2">
<li>局部静态变量</li>
</ol>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>==函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；==</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<ol start="4">
<li>类的静态成员</li>
</ol>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<ol start="5">
<li>类的静态函数</li>
</ol>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h3 id="2、说一下C-和C的区别"><a href="#2、说一下C-和C的区别" class="headerlink" title="2、说一下C++和C的区别"></a>2、说一下C++和C的区别</h3><p>设计思想上：</p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h3 id="3、说一说c-中四种cast转换"><a href="#3、说一说c-中四种cast转换" class="headerlink" title="3、说一说c++中四种cast转换"></a>3、说一说c++中四种cast转换</h3><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p>1、const_cast</p>
<p>用于将const变量转为非const</p>
<p>2、static_cast</p>
<p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p>3、dynamic_cast</p>
<p>用于==动态类型转换==。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p>4、reinterpret_cast</p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<p>5、为什么不使用C的强制转换？</p>
<p>==C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。==</p>
<h3 id="4、请说一下C-C-中指针和引用的区别？"><a href="#4、请说一下C-C-中指针和引用的区别？" class="headerlink" title="4、请说一下C/C++ 中指针和引用的区别？"></a>4、请说一下C/C++ 中指针和引用的区别？</h3><p>1.指针有自己的一块空间，而引用只是一个别名；</p>
<p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
<p>5.可以有const指针，但是没有const引用；</p>
<p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7.指针可以有多级指针（**p），而引用至于一级；</p>
<p>8.指针和引用使用++运算符的意义不一样；</p>
<p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<h3 id="5、请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#5、请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="5、请你说一下你理解的c++中的smart pointer四个智能指针：  shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>5、请你说一下你理解的c++中的smart pointer四个智能指针：  shared_ptr,unique_ptr,weak_ptr,auto_ptr</h3><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<ol>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）</li>
</ol>
<p>采用所有权模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<ol start="2">
<li>unique_ptr（替换auto_ptr）</li>
</ol>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (``<span class="keyword">new</span>` `<span class="built_in">string</span> (``<span class="string">"auto"</span>``));   ``<span class="comment">//#4``unique_ptr&lt;string&gt; p4；                       ``//#5``p4 = p3;``//此时会报错！！`</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>shared_ptr</li>
</ol>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p>
<ol start="4">
<li>weak_ptr</li>
</ol>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
<h3 id="6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"><a href="#6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码" class="headerlink" title="6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码"></a>6、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码</h3><p>1、判断一个数是不是二的倍数，即判断该数二进制末位是不是0：</p>
<p>a % 2 == 0 或者a &amp; 0x0001 == 0。</p>
<p>2、求一个数中1的位数，可以直接逐位除十取余判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">10</span>== <span class="number">1</span>)</span><br><span class="line">++_count;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fun(<span class="number">123321</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、请回答一下数组和指针的区别"><a href="#7、请回答一下数组和指针的区别" class="headerlink" title="7、请回答一下数组和指针的区别"></a>7、请回答一下数组和指针的区别</h3><p>指针和数组的主要区别如下：</p>
<table>
<thead>
<tr>
<th align="center">指针</th>
<th align="center">数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">保存数据的地址</td>
<td align="center">保存数据</td>
</tr>
<tr>
<td align="center">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td align="center">直接访问数据，</td>
</tr>
<tr>
<td align="center">通常用于动态的数据结构</td>
<td align="center">通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td align="center">通过Malloc分配内存，free释放内存</td>
<td align="center">隐式的分配和删除</td>
</tr>
<tr>
<td align="center">通常指向匿名数据，操作匿名函数</td>
<td align="center">自身即为数据名</td>
</tr>
</tbody></table>
<h3 id="8、请你回答一下野指针是什么？"><a href="#8、请你回答一下野指针是什么？" class="headerlink" title="8、请你回答一下野指针是什么？"></a>8、请你回答一下野指针是什么？</h3><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h3 id="9、请你理解的c-中的引用和指针"><a href="#9、请你理解的c-中的引用和指针" class="headerlink" title="9、请你理解的c++中的引用和指针"></a>9、请你理解的c++中的引用和指针</h3><p>定义：</p>
<p>1、引用：</p>
<p>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>相似，只是用&amp;代替了*。</p>
<p>2、指针：</p>
<p>指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p>
<p>区别：</p>
<p>1、指针有自己的一块空间，而引用只是一个别名；</p>
<p>2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p>
<p>4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
<p>5、可以有const指针，但是没有const引用；</p>
<p>6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7、指针可以有多级指针（**p），而引用至于一级；</p>
<p>8、指针和引用使用++运算符的意义不一样；</p>
<p>9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<p>10、引用常量不存在，没有int&amp; const p，常量引用是存在的cosnt int &amp;p</p>
<h3 id="10、请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#10、请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="10、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>10、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h3><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作==父类==时，设置为虚函数</p>
<h3 id="11、请你来说一下函数指针"><a href="#11、请你来说一下函数指针" class="headerlink" title="11、请你来说一下函数指针"></a>11、请你来说一下函数指针</h3><p>1、定义</p>
<p>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p>2、用途：</p>
<p>==调用函数和做函数的参数，比如回调函数==</p>
<p>3、示例：</p>
<p>char * fun(char * p)  {…}       // 函数fun</p>
<p>char * (*pf)(char * p);             // 函数指针pf</p>
<p>pf = fun;                        // 函数指针pf指向函数fun</p>
<p>pf(p);                        // 通过函数指针pf调用函数fun</p>
<h3 id="12、请你来说一下fork函数"><a href="#12、请你来说一下fork函数" class="headerlink" title="12、请你来说一下fork函数"></a>12、请你来说一下fork函数</h3><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<h3 id="13、请你来说一下C-中析构函数的作用"><a href="#13、请你来说一下C-中析构函数的作用" class="headerlink" title="13、请你来说一下C++中析构函数的作用"></a>13、请你来说一下C++中析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>
<p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好==显示构造析构函数==在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>==类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。==</p>
<h3 id="14、请你来说一下静态函数和虚函数的区别"><a href="#14、请你来说一下静态函数和虚函数的区别" class="headerlink" title="14、请你来说一下静态函数和虚函数的区别"></a>14、请你来说一下静态函数和虚函数的区别</h3><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h3 id="15、请你来说一说重载和覆盖"><a href="#15、请你来说一说重载和覆盖" class="headerlink" title="15、请你来说一说重载和覆盖"></a>15、请你来说一说重载和覆盖</h3><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<h3 id="16、请你说一说strcpy和strlen"><a href="#16、请你说一说strcpy和strlen" class="headerlink" title="16、请你说一说strcpy和strlen"></a>16、请你说一说strcpy和strlen</h3><p>strcpy是字符串拷贝函数，原型：</p>
<p>char <em>strcpy(char</em> dest, const char *src);</p>
<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<h3 id="17、-请你说一说你理解的虚函数和多态"><a href="#17、-请你说一说你理解的虚函数和多态" class="headerlink" title="17、 请你说一说你理解的虚函数和多态"></a>17、 请你说一说你理解的虚函数和多态</h3><p>多态的实现主要分为==静态多态==和==动态多态==，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：==一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数==，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h3 id="18、-请你来说一说-i和i-的实现"><a href="#18、-请你来说一说-i和i-的实现" class="headerlink" title="18、 请你来说一说++i和i++的实现"></a>18、 请你来说一说++i和i++的实现</h3><p>++i 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i++实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">++（*<span class="keyword">this</span>）；</span><br><span class="line"><span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19、请你来说一下智能指针shared-ptr的实现"><a href="#19、请你来说一下智能指针shared-ptr的实现" class="headerlink" title="19、请你来说一下智能指针shared_ptr的实现"></a>19、请你来说一下智能指针shared_ptr的实现</h3><p>核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p>
<h3 id="20、以下四行代码的区别是什么？"><a href="#20、以下四行代码的区别是什么？" class="headerlink" title="20、以下四行代码的区别是什么？"></a>20、以下四行代码的区别是什么？</h3><blockquote>
<p>const char * arr = “123”;</p>
<p>char * brr = “123”; </p>
<p>const char crr[] = “123”; </p>
<p>char drr[] = “123”;</p>
</blockquote>
<p>const char * arr = “123”;</p>
<p>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h3 id="21、请你来回答一下const修饰成员函数的目的是什么"><a href="#21、请你来回答一下const修饰成员函数的目的是什么" class="headerlink" title="21、请你来回答一下const修饰成员函数的目的是什么"></a>21、请你来回答一下const修饰成员函数的目的是什么</h3><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h3 id="22、请你来说一说隐式类型转换"><a href="#22、请你来说一说隐式类型转换" class="headerlink" title="22、请你来说一说隐式类型转换"></a>22、请你来说一说隐式类型转换</h3><p>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<h3 id="22、说说你了解的类型转换"><a href="#22、说说你了解的类型转换" class="headerlink" title="22、说说你了解的类型转换"></a>22、说说你了解的类型转换</h3><p>einterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证<br>dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常<br>const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。<br>static_cast：==完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。==</p>
<h3 id="23、请你来说一说C-函数栈空间的最大值"><a href="#23、请你来说一说C-函数栈空间的最大值" class="headerlink" title="23、请你来说一说C++函数栈空间的最大值"></a>23、请你来说一说C++函数栈空间的最大值</h3><p>默认是1M，不过可以调整</p>
<h3 id="24、-请你来说一说extern“C”"><a href="#24、-请你来说一说extern“C”" class="headerlink" title="24、 请你来说一说extern“C”"></a>24、 请你来说一说extern“C”</h3><p>C++调用C函数需要extern C，因为C语言没有函数重载。</p>
<h3 id="25、请你回答一下new-delete与malloc-free的区别是什么"><a href="#25、请你回答一下new-delete与malloc-free的区别是什么" class="headerlink" title="25、请你回答一下new/delete与malloc/free的区别是什么"></a>25、请你回答一下new/delete与malloc/free的区别是什么</h3><p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h3 id="26、请你说说你了解的RTTI"><a href="#26、请你说说你了解的RTTI" class="headerlink" title="26、请你说说你了解的RTTI"></a>26、请你说说你了解的RTTI</h3><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info</p>
<h3 id="27、-请你说说虚函数表具体是怎样实现运行时多态的"><a href="#27、-请你说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="27、 请你说说虚函数表具体是怎样实现运行时多态的?"></a>27、 请你说说虚函数表具体是怎样实现运行时多态的?</h3><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h3 id="28、请你说说C语言是怎么进行函数调用的？"><a href="#28、请你说说C语言是怎么进行函数调用的？" class="headerlink" title="28、请你说说C语言是怎么进行函数调用的？"></a>28、请你说说C语言是怎么进行函数调用的？</h3><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h3 id="29、请你说说C语言参数压栈顺序？"><a href="#29、请你说说C语言参数压栈顺序？" class="headerlink" title="29、请你说说C语言参数压栈顺序？"></a>29、请你说说C语言参数压栈顺序？</h3><p>从右到左</p>
<h3 id="30、请你说说C-如何处理返回值？"><a href="#30、请你说说C-如何处理返回值？" class="headerlink" title="30、请你说说C++如何处理返回值？"></a>30、请你说说C++如何处理返回值？</h3><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h3 id="31、-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#31、-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="31、 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>31、 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h3><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h3 id="32、-请你回答一下malloc与new区别"><a href="#32、-请你回答一下malloc与new区别" class="headerlink" title="32、 请你回答一下malloc与new区别"></a>32、 请你回答一下malloc与new区别</h3><p>malloc需要给定申请内存的大小，返回的指针需要强转。<br>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</p>
<h3 id="33、-请你说一说select"><a href="#33、-请你说一说select" class="headerlink" title="33、 请你说一说select"></a>33、 请你说一说select</h3><p>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大。</p>
<h3 id="34、-请你说说fork-wait-exec函数"><a href="#34、-请你说说fork-wait-exec函数" class="headerlink" title="34、 请你说说fork,wait,exec函数"></a>34、 请你说说fork,wait,exec函数</h3><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h3 id="35、请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#35、请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="35、请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>35、请你来说一下map和set有什么区别，分别又是怎么实现的？</h3><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map和set区别在于：</p>
<p>（1）==map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。==</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）==map支持下标操作，set不支持下标操作。==map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h3 id="36、请你来介绍一下STL的allocaotr"><a href="#36、请你来介绍一下STL的allocaotr" class="headerlink" title="36、请你来介绍一下STL的allocaotr"></a>36、请你来介绍一下STL的allocaotr</h3><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p>
<p>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p>
<h3 id="37、-请你来说一说STL迭代器删除元素"><a href="#37、-请你来说一说STL迭代器删除元素" class="headerlink" title="37、 请你来说一说STL迭代器删除元素"></a>37、 请你来说一说STL迭代器删除元素</h3><p>1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
<p>2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
<p>3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p>
<h3 id="38、-请你讲讲STL有什么基本组成"><a href="#38、-请你讲讲STL有什么基本组成" class="headerlink" title="38、 请你讲讲STL有什么基本组成"></a>38、 请你讲讲STL有什么基本组成</h3><p>STL主要由：以下几部分组成：<br>==容器 迭代器 仿函数 算法 分配器 配接器==<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h3 id="39、请你说说STL中map与unordered-map"><a href="#39、请你说说STL中map与unordered-map" class="headerlink" title="39、请你说说STL中map与unordered_map"></a>39、请你说说STL中map与unordered_map</h3><p>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<p>2、Multimap</p>
<p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对可重复映射</p>
<h3 id="40、请你说一说vector和list的区别，应用，越详细越好"><a href="#40、请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="40、请你说一说vector和list的区别，应用，越详细越好"></a>40、请你说一说vector和list的区别，应用，越详细越好</h3><p>1、概念：</p>
<p>1）Vector</p>
<p>连续存储的容器，动态数组，在堆上分配空间</p>
<p>底层实现：数组</p>
<p>两倍容量增长：</p>
<p>vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。</p>
<p>如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</p>
<p>性能：</p>
<p>访问：O(1)</p>
<p>插入：在最后插入（空间够）：很快</p>
<p>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>在中间插入（空间够）：内存拷贝</p>
<p>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>删除：在最后删除：很快</p>
<p>在中间删除：内存拷贝</p>
<p>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</p>
<p>2、List</p>
<p>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>底层：双向链表</p>
<p>性能：</p>
<p>访问：随机访问性能很差，只能快速访问头尾节点。</p>
<p>插入：很快，一般是常数开销</p>
<p>删除：很快，一般是常数开销</p>
<p>适用场景：经常插入删除大量数据</p>
<p>2、区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h3 id="41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>41、请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h3><p>1、迭代器</p>
<p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>2、迭代器和指针的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果</p>
<h3 id="42、请你说一说epoll原理"><a href="#42、请你说一说epoll原理" class="headerlink" title="42、请你说一说epoll原理"></a>42、请你说一说epoll原理</h3><p>int epoll_create(int size);</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</p>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<h3 id="43、请你回答一下STL里resize和reserve的区别"><a href="#43、请你回答一下STL里resize和reserve的区别" class="headerlink" title="43、请你回答一下STL里resize和reserve的区别"></a>43、请你回答一下STL里resize和reserve的区别</h3><p>resize()：改变当前容器内含有元素的数量(size())，</p>
<p>eg: vector<int>v; v.resize(len);  v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</int></p>
<p>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<h3 id="44、请你来说一下C-中类成员的访问权限"><a href="#44、请你来说一下C-中类成员的访问权限" class="headerlink" title="44、请你来说一下C++中类成员的访问权限"></a>44、请你来说一下C++中类成员的访问权限</h3><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
<h3 id="45、-请你来说一下C-中struct和class的区别"><a href="#45、-请你来说一下C-中struct和class的区别" class="headerlink" title="45、 请你来说一下C++中struct和class的区别"></a>45、 请你来说一下C++中struct和class的区别</h3><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</p>
<p>另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p>
<h3 id="46、请你回答一下C-类内可以定义引用数据成员吗"><a href="#46、请你回答一下C-类内可以定义引用数据成员吗" class="headerlink" title="46、请你回答一下C++类内可以定义引用数据成员吗"></a>46、请你回答一下C++类内可以定义引用数据成员吗</h3><p>可以，必须通过成员函数初始化列表初始化。</p>
<h3 id="47、请你回答一下什么是右值引用，跟左值又有什么区别？"><a href="#47、请你回答一下什么是右值引用，跟左值又有什么区别？" class="headerlink" title="47、请你回答一下什么是右值引用，跟左值又有什么区别？"></a>47、请你回答一下什么是右值引用，跟左值又有什么区别？</h3><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
</ol>
<h3 id="48、请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#48、请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="48、请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>48、请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h3><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p>
<p>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h3 id="49、-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#49、-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="49、 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>49、 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h3><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p>
<p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<h3 id="50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>50、请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块<strong>。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</strong></p>
<p>当进行内存分配时<strong>，Malloc会通过隐式链表遍历所有的空闲块</strong>，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，<strong>一般会通过brk或者mmap系统调用进行申请</strong>。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="51、请你说一说C-的内存管理是怎样的？"><a href="#51、请你说一说C-的内存管理是怎样的？" class="headerlink" title="51、请你说一说C++的内存管理是怎样的？"></a>51、请你说一说C++的内存管理是怎样的？</h3><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h3 id="52、请你来说一下C-C的内存分配"><a href="#52、请你来说一下C-C的内存分配" class="headerlink" title="52、请你来说一下C++/C的内存分配"></a>52、请你来说一下C++/C的内存分配</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272" alt="img"></p>
<p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<p>3G用户空间和1G内核空间</p>
<p>静态区域：</p>
<p>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</p>
<p>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p>
<p>动态区域：</p>
<p>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，<strong>结束地址由brk标识。</strong></p>
<p>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p>
<p>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p>
<h3 id="53、请你回答一下如何判断内存泄漏？"><a href="#53、请你回答一下如何判断内存泄漏？" class="headerlink" title="53、请你回答一下如何判断内存泄漏？"></a>53、请你回答一下如何判断内存泄漏？</h3><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h3 id="54、-请你来说一下什么时候会发生段错误、"><a href="#54、-请你来说一下什么时候会发生段错误、" class="headerlink" title="54、 请你来说一下什么时候会发生段错误、"></a>54、 请你来说一下什么时候会发生段错误、</h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<p>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h3 id="55、-请你来回答一下什么是memory-leak，也就是内存泄漏"><a href="#55、-请你来回答一下什么是memory-leak，也就是内存泄漏" class="headerlink" title="55、 请你来回答一下什么是memory leak，也就是内存泄漏"></a>55、 请你来回答一下什么是memory leak，也就是内存泄漏</h3><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h3 id="56、请你来回答一下new和malloc的区别"><a href="#56、请你来回答一下new和malloc的区别" class="headerlink" title="56、请你来回答一下new和malloc的区别"></a>56、请你来回答一下new和malloc的区别</h3><p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</p>
<p>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p>
<p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p>
<p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
<h3 id="57、-请你来说一下共享内存相关api"><a href="#57、-请你来说一下共享内存相关api" class="headerlink" title="57、 请你来说一下共享内存相关api"></a>57、 请你来说一下共享内存相关api</h3><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。</p>
<p>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h3 id="58、-请你来说一下reactor模型组成"><a href="#58、-请你来说一下reactor模型组成" class="headerlink" title="58、 请你来说一下reactor模型组成"></a>58、 请你来说一下reactor模型组成</h3><p>reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552468262115_CB656C4BF3B7635BECB0F5D128C95303" alt="img"></p>
<p>1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
<p>2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<p>3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
<p>4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
<p>5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。</p>
<h3 id="59、请你说一说C-STL-的内存优化"><a href="#59、请你说一说C-STL-的内存优化" class="headerlink" title="59、请你说一说C++ STL 的内存优化"></a>59、请你说一说C++ STL 的内存优化</h3><p>  1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190414/970829_1555246716341_19203EAD1152E0317EE9B5F6BFE090C6" alt="img"><br>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。<ol start="2">
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。<ol start="3">
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="60、-请你说说select，epoll的区别，原理，性能，限制都说一说"><a href="#60、-请你说说select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="60、 请你说说select，epoll的区别，原理，性能，限制都说一说"></a>60、 请你说说select，epoll的区别，原理，性能，限制都说一说</h3><p>1 IO多路复用</p>
<p>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/826546_1552638064152_94DD1FAB6C2E289FF496A8013E092EA5" alt="img"></p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>2、select</p>
<p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<p>3、poll</p>
<p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>4、epoll</p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h3 id="61、-请问C-11有哪些新特性？"><a href="#61、-请问C-11有哪些新特性？" class="headerlink" title="61、 请问C++11有哪些新特性？"></a>61、 请问C++11有哪些新特性？</h3><p>C++11 最常用的新特性如下：</p>
<p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
<p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
<p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
<p>初始化列表：使用初始化列表来对类进行初始化</p>
<p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
<p>atomic原子操作用于多线程资源互斥操作</p>
<p>新增STL容器array以及tuple</p>
<h3 id="62、请你详细介绍一下C-11中的可变参数模板、右值引用和lambda这几个新特性。"><a href="#62、请你详细介绍一下C-11中的可变参数模板、右值引用和lambda这几个新特性。" class="headerlink" title="62、请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。"></a>62、请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。</h3><p>可变参数模板：</p>
<p>C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号”。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> ... <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;”num is”&lt;&lt;<span class="keyword">sizeof</span> ...(args)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func();//args不含任何参数</p>
<p>func(1);//args包含一个int类型的实参</p>
<p>func(1,2.0)//args包含一个int一个double类型的实参</p>
<p>其中T叫做模板参数包，args叫做函数参数包</p>
<p>省略号作用如下：</p>
<p>1）声明一个包含0到任意个模板参数的参数包</p>
<p>2）在模板定义得右边，可以将参数包展成一个个独立的参数</p>
<p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终递归函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; head &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数包Args …在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。</p>
<p>右值引用:</p>
<p>C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将右值通常是指具有转移语义的对象，比如返回右值引用T&amp;&amp;的函数返回值等。</p>
<p>C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：</p>
<p>T &amp;&amp; a=ReturnRvale();</p>
<p>假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。</p>
<p>基于右值引用可以实现转移语义和完美转发新特性。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/STL函数对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/STL函数对象/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:16:10+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在STL中，函数对象也是比较重要的，有时候可以限定STL算法的行为，例如在前面介绍的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL</a><a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">算法剖析</a>》中，每个算法基本上都提供了两个操作版本，其中就有一个版本允许用户指定函数对象，这样可以根据用户的需要对算法进行操作。函数对象是一种具有函数特质的对象，所以可以作为算法的参数。本文介绍的函数对象比较简单，是基于一元或者二元操作结构的算术类函数对象、关系运算类函数对象、逻辑运算类函数对象。在定义函数对象时，为了使其具有函数行为，则必须重载operator()操作符。本文源码出自SGI STL中的&lt;stl_function.h&gt;文件。</p>
<h3 id="函数对象源码剖析"><a href="#函数对象源码剖析" class="headerlink" title="函数对象源码剖析"></a>函数对象源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">_STL_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">//一元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg argument_type;<span class="comment">//参数类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//二元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg1 first_argument_type;<span class="comment">//参数一类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg2 second_argument_type;<span class="comment">//参数二类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作算术函数对象，继承二元操作binary_function的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加法操作plus&lt;T&gt;,减法操作minus&lt;T&gt;,乘法操作multiplies&lt;T&gt;,除法操作divides&lt;T&gt;,</span></span><br><span class="line"><span class="comment">取模运算modulus&lt;T&gt;,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x + __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x - __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">multiplies</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x * __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">divides</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x / __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">modulus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x % __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一元操作，继承一元操作unary_function结构</span></span><br><span class="line"><span class="comment">//负值操作negate&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// identity_element (not part of the C++ standard).</span></span><br><span class="line"><span class="comment">//证同元素：</span></span><br><span class="line"><span class="comment">//以下只提供的两种证同元素</span></span><br><span class="line"><span class="comment">//加法：任何元素加上0结果都为自身</span></span><br><span class="line"><span class="comment">//乘法：任何元素乘以1结果都为自身</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">plus</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">multiplies</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作关系函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值的类型是bool型别</span></span><br><span class="line"><span class="comment">equal_to,not_equal_to,greater,less,greater_equal,less_equal,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x == __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">not_equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x != __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作逻辑函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中logical_not为一元操作函数</span></span><br><span class="line"><span class="comment">logical_and,logical_or,logical_not</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &amp;&amp; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x || __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// identity is an extensions: it is not part of the standard.</span></span><br><span class="line"><span class="comment">//证同函数</span></span><br><span class="line"><span class="comment">//任何数值通过此函数后，不会有任何修改。所以返回值类型为const引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Identity</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> _<span class="function">Tp&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> _Identity&lt;_Tp&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select1st and select2nd are extensions: they are not part of the standard.</span></span><br><span class="line"><span class="comment">//选择函数</span></span><br><span class="line"><span class="comment">//版本一：选择pair元素的第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：选择pair元素的第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::second_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> _Select1st&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> _Select2nd&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project1st and project2nd are extensions: they are not part of the standard</span></span><br><span class="line"><span class="comment">//投射函数</span></span><br><span class="line"><span class="comment">//版本一：投射出第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project1st</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg1&gt; &#123;</span><br><span class="line">  _<span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp; __x, <span class="keyword">const</span> _Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：投射出第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project2nd</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg2&gt; &#123;</span><br><span class="line">  _<span class="function">Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp;, <span class="keyword">const</span> _Arg2&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project1st</span> :</span> <span class="keyword">public</span> _Project1st&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project2nd</span> :</span> <span class="keyword">public</span> _Project2nd&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Permutation/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:15:08+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文讲解的是STL算法中的permutation排列组合算法，根据输入序列，排列出下一个排列组合或前一个排列组合。</p>
<h3 id="permutation排列组合源码剖析"><a href="#permutation排列组合源码剖析" class="headerlink" title="permutation排列组合源码剖析"></a>permutation排列组合源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next_permutation and prev_permutation, with and without an explicitly </span></span><br><span class="line"><span class="comment">// supplied comparison function.</span></span><br><span class="line"><span class="comment">//next_permutation获取[first,last)区间所标示序列的下一个排列组合，若果没有下一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the next lexicographically greater permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp决定</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若为空，则返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;<span class="comment">//i指向尾端</span></span><br><span class="line">  --__i;<span class="comment">//不断后移</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;<span class="comment">//</span></span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__ii) &#123;<span class="comment">//若前一个元素小于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个大于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端</span></span><br><span class="line">      <span class="keyword">while</span> (!(*__i &lt; *--__j))<span class="comment">//由尾端往前检查，直到遇到比*i大的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);<span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//整个区间全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__ii)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*__i, *--__j))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//next_permutation函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt;' ' &lt;&lt; myints[3]&lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::next_permutation(myints,myints+4) );</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">	  //std::next_permutation(myints,myints+4);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; ' ' &lt;&lt; myints[3]&lt;&lt;'\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	1 2 3 4</span></span><br><span class="line"><span class="comment">	1 2 4 3</span></span><br><span class="line"><span class="comment">	1 3 2 4</span></span><br><span class="line"><span class="comment">	1 3 4 2</span></span><br><span class="line"><span class="comment">	1 4 2 3</span></span><br><span class="line"><span class="comment">	1 4 3 2</span></span><br><span class="line"><span class="comment">	2 1 3 4</span></span><br><span class="line"><span class="comment">	2 1 4 3</span></span><br><span class="line"><span class="comment">	2 3 1 4</span></span><br><span class="line"><span class="comment">	2 3 4 1</span></span><br><span class="line"><span class="comment">	2 4 1 3</span></span><br><span class="line"><span class="comment">	2 4 3 1</span></span><br><span class="line"><span class="comment">	3 1 2 4</span></span><br><span class="line"><span class="comment">	3 1 4 2</span></span><br><span class="line"><span class="comment">	3 2 1 4</span></span><br><span class="line"><span class="comment">	3 2 4 1</span></span><br><span class="line"><span class="comment">	3 4 1 2</span></span><br><span class="line"><span class="comment">	3 4 2 1</span></span><br><span class="line"><span class="comment">	4 1 2 3</span></span><br><span class="line"><span class="comment">	4 1 3 2</span></span><br><span class="line"><span class="comment">	4 2 1 3</span></span><br><span class="line"><span class="comment">	4 2 3 1</span></span><br><span class="line"><span class="comment">	4 3 1 2</span></span><br><span class="line"><span class="comment">	4 3 2 1</span></span><br><span class="line"><span class="comment">	After loop: 1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prev_permutation获取[first,last)区间所标示序列的上一个排列组合，若果没有上一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the previous lexicographically-ordered permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last );</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若区间为空，返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false</span></span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__ii &lt; *__i) &#123;<span class="comment">//若前一个元素大于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个小于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端      </span></span><br><span class="line">      <span class="keyword">while</span> (!(*--__j &lt; *__i))<span class="comment">//由尾端往前检查，直到遇到比*i小的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j); <span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//把区间所有元素逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__ii, *__i)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*--__j, *__i))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prev_permutation函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort, std::reverse</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+3);</span></span><br><span class="line"><span class="comment">	  std::reverse (myints,myints+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::prev_permutation(myints,myints+3) );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	3 2 1</span></span><br><span class="line"><span class="comment">	3 1 2</span></span><br><span class="line"><span class="comment">	2 3 1</span></span><br><span class="line"><span class="comment">	2 1 3</span></span><br><span class="line"><span class="comment">	1 3 2</span></span><br><span class="line"><span class="comment">	1 2 3</span></span><br><span class="line"><span class="comment">	After loop: 3 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/remove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/remove/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:14:31+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的remove删除算法，源码中介绍了函数remove、remove_copy、remove_if、remove_copy_if、unique、unique_copy。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="remove移除算法源码剖析"><a href="#remove移除算法源码剖析" class="headerlink" title="remove移除算法源码剖析"></a>remove移除算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove, remove_if, remove_copy, remove_copy_if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素，并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">OutputIter</span> __<span class="title">result</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__first == __value)) &#123;<span class="comment">//如果不相等</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内被仿函数pred判断为true的元素,并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!__pred(*__first)) &#123;<span class="comment">//若pred判断为false</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  __STL_CONVERTIBLE(_Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find(__first, __last, __value);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy(++__i, __last, __first, __value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有被pred判断为true的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove_if</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">               <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find_if(__first, __last, __pred);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy_if</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy_if(++__i, __last, __first, __pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面四个移除函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::remove</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return ((i%2)==1); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,31,30,20,11,10,20&#125;;      // 10 20 31 30 20 11 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (8);</span></span><br><span class="line"><span class="comment">	  std::remove_copy (myints,myints+8,myvector.begin(),20); // 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // bounds of range:</span></span><br><span class="line"><span class="comment">	  int* pbegin = myints;                          // ^</span></span><br><span class="line"><span class="comment">	  int* pend = myints+sizeof(myints)/sizeof(int); // ^                       ^</span></span><br><span class="line"><span class="comment">	  pend = std::remove (pbegin, pend, 20);         // 10 31 30 11 10 ?  ?  ?</span></span><br><span class="line"><span class="comment">													 // ^              ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector2 (7);</span></span><br><span class="line"><span class="comment">	  std::remove_copy_if (myints,myints+7,myvector2.begin(),IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector2 contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector2.begin(); it!=myvector2.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  pend = std::remove_if (pbegin, pend, IsOdd);   // 10 30 10 ? ? ? ? ?</span></span><br><span class="line"><span class="comment">													 // ^       ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "the range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	myvector contains: 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	range contains: 10 31 30 11 10</span></span><br><span class="line"><span class="comment">	myvector2 contains: 10 30 10 10 0 0 0</span></span><br><span class="line"><span class="comment">	the range contains: 10 30 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique and unique_copy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!(__value == *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为output_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">		<span class="comment">//判断first的value_type类型，根据不同类型调用不同函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为forward_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  *__result = *__first;<span class="comment">//记录第一个元素</span></span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)<span class="comment">//遍历区间</span></span><br><span class="line">	  <span class="comment">//若不存在相邻重复元素，则继续记录到目标区result</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__result == *__first))</span><br><span class="line">      *++__result = *__first;<span class="comment">//记录元素到目标区</span></span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////unique_copy将区间[first,last)内元素复制到以result开头的区间上，但是如果存在相邻重复元素时，只复制其中第一个元素</span></span><br><span class="line"><span class="comment">//和unique一样，这里也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result);</span></span><br><span class="line"><span class="comment">predicate (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result, BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(__value, *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(*__result, *__first)) *++__result = *__first;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除区间[first,last)相邻连续重复的元素</span></span><br><span class="line"><span class="comment">//unique有两个版本</span></span><br><span class="line"><span class="comment">//功能：Removes all but the first element from every consecutive group of equivalent elements in the range [first,last).</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一采用operator==	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二采用pred操作	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                          BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __first = adjacent_find(__first, __last);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = adjacent_find(__first, __last, __binary_pred);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first, __binary_pred);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/merge/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:14:02+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的merge合并算法。源码中介绍了函数merge、inplace_merge。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="merge合并算法源码剖析"><a href="#merge合并算法源码剖析" class="headerlink" title="merge合并算法源码剖析"></a>merge合并算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//将两个已排序的区间[first1,last1)和区间[first2,last2)合并</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Combines the elements in the sorted ranges [first1,last1) and [first2,last2), </span></span><br><span class="line"><span class="comment">into a new range beginning at result with all its elements sorted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2,</span></span><br><span class="line"><span class="comment">          class OutputIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//两个序列都尚未到达尾端，则执行while循环</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若序列二元素较小,则记录到目标区，且移动序列二的迭代器，但是序列一的迭代器不变.</span></span><br><span class="line"><span class="comment">  情况2：若序列一元素较小或相等,则记录到目标区，且移动序列一的迭代器，但是序列二的迭代器不变.</span></span><br><span class="line"><span class="comment">  最后：把剩余元素的序列复制到目标区</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">	  <span class="comment">//情况1</span></span><br><span class="line">    <span class="keyword">if</span> (*__first2 &lt; *__first1) &#123;<span class="comment">//若序列二元素较小</span></span><br><span class="line">      *__result = *__first2;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first2;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//情况2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列一元素较小或相等</span></span><br><span class="line">      *__result = *__first1;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first1;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;<span class="comment">//更新目标区位置，以便下次记录数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若有序列到达尾端，则把没到达尾端的序列剩余元素复制到目标区</span></span><br><span class="line">  <span class="comment">//此时，区间[first1,last1)和区间[first2,last2)至少一个必定为空</span></span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type);</span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first2, *__first1)) &#123;</span><br><span class="line">      *__result = *__first2;</span><br><span class="line">      ++__first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *__result = *__first1;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::merge, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment">	  std::merge (first,first+5,second,second+5,v.begin());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inplace_merge and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//版本一的辅助函数，无缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; *__first)</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle,</span><br><span class="line">                         __len11, __len22);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, *__first))</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,</span><br><span class="line">                         __comp);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span> __<span class="title">rotate_adaptive</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter2</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _BidirectionalIter2 __buffer_end;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2 &amp;&amp; __len2 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列二</span></span><br><span class="line">    __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    copy_backward(__first, __middle, __last);</span><br><span class="line">    <span class="keyword">return</span> copy(__buffer, __buffer_end, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len1 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列一</span></span><br><span class="line">    __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    copy(__middle, __last, __first);</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若缓冲区仍然不够，则调用STL算法rotate，不使用缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> rotate(__first, __middle, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__last2 &lt; *__last1) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__last2, *__last1)) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case1：把序列一放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">	<span class="comment">//直接调用归并函数merge</span></span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case2：把序列二放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//case3：缓冲区不足放置任何一个序列</span></span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;<span class="comment">//若序列一比较长</span></span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;<span class="comment">//计算序列一的一半</span></span><br><span class="line">      advance(__first_cut, __len11);<span class="comment">//让first_cut指向序列一的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__first_cut在[middle,last)区间中的第一个不小于*__first_cut的元素位置</span></span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">	  <span class="comment">//计算middle到__second_cut之间的距离，保存在__len22</span></span><br><span class="line">      distance(__middle, __second_cut, __len22); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列二比较长</span></span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;<span class="comment">//计算序列二的一半</span></span><br><span class="line">      advance(__second_cut, __len22);<span class="comment">//让__second_cut指向序列二的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__second_cut在[first,middle)区间中的第一个大于*__second_cut的元素位置</span></span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">	  <span class="comment">//计算__first到__first_cut之间的距离，保存在__len11</span></span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对左半段递归调用</span></span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对右半段递归调用</span></span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last,</span><br><span class="line">                     __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">      advance(__first_cut, __len11);</span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">      distance(__middle, __second_cut, __len22);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">      advance(__second_cut, __len22);</span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);<span class="comment">//计算序列一的长度</span></span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);<span class="comment">//计算序列二的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用暂时缓冲区</span></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)<span class="comment">//若缓冲区配置失败</span></span><br><span class="line">	  <span class="comment">//则调用不使用缓冲区的合并操作</span></span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2);</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若分配成功</span></span><br><span class="line">	  <span class="comment">//则调用具有缓冲区的合并操作</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);</span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);</span><br><span class="line"></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()),</span><br><span class="line">                     __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个已排序的序列[first,middle)和[middle,last)合并成单一有序序列.</span></span><br><span class="line"><span class="comment">//若原来是增序，现在也是递增排序，若原来是递减排序，现在也是递减排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Merges two consecutive sorted ranges: [first,middle) and [middle,last), </span></span><br><span class="line"><span class="comment">putting the result into the combined sorted range [first,last).</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)<span class="comment">//若有空序列，则之间返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first),</span><br><span class="line">                      __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inplace_merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::inplace_merge, std::sort, std::copy</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  it=std::copy (first, first+5, v.begin());</span></span><br><span class="line"><span class="comment">		 std::copy (second,second+5,it);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::inplace_merge (v.begin(),v.begin()+5,v.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/find/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:13:28+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的find、search查找算法。在STL源码中有关算法的函数大部分在本文介绍，包含findand find_if、adjacent_find、search、search_n、lower_bound、upper_bound、equal_range、binary_search、find_first_of、find_end相关算法，下面对这些算法的源码进行了详细的剖析，并且适当给出应用例子，增加我们对其理解，方便我们使用这些算法。具体详见下面源码剖析。</p>
<h3 id="查找算法源码剖析"><a href="#查找算法源码剖析" class="headerlink" title="查找算法源码剖析"></a>查找算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find and find_if.</span></span><br><span class="line"><span class="comment">//查找区间[first,last)内元素第一个与value值相等的元素，并返回其位置</span></span><br><span class="line"><span class="comment">//其中find函数是采用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//find_if是采用用户自行指定的操作pred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !(*__first == __val))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !__pred(*__first))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find_if</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"><span class="comment">/*find函数功能：Returns an iterator to the first element in the range [first,last) that compares equal to val. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find (InputIterator first, InputIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">            <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find(__first, __last, __val, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*find_if函数功能：Returns an iterator to the first element in the range [first,last) for which pred returns true. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find_if函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find_if 函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find_if(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find和find_if函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_if</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123;</span></span><br><span class="line"><span class="comment">	  return ((i%2)==1);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  myvector.push_back(10);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(25);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(40);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(55);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it = std::find_if (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The first odd value is " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using std::find with vector and iterator:</span></span><br><span class="line"><span class="comment">	  it = find (myvector.begin(), myvector.end(), 40);</span></span><br><span class="line"><span class="comment">	  if (it != myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element not found in myints\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first odd value is 25</span></span><br><span class="line"><span class="comment">	Element found in myvector: 40</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjacent_find.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找区间[first,last)内第一次重复的相邻元素</span></span><br><span class="line"><span class="comment">//若存在返回相邻元素的第一个元素位置</span></span><br><span class="line"><span class="comment">//若不存在返回last位置</span></span><br><span class="line"><span class="comment">/*该函数有两个版本：第一版本是默认操作operator==；第二版本是用户指定的二元操作pred</span></span><br><span class="line"><span class="comment">函数对外接口的原型：</span></span><br><span class="line"><span class="comment">equality (1)：默认操作是operator==</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                                  BinaryPredicate pred);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：默认操作是operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若输入区间为空，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  情况2：若输入区间不为空，且存在相邻重复元素，则返回相邻元素的第一个元素的位置；</span></span><br><span class="line"><span class="comment">  情况3：若输入区间不为空，但是不存在相邻重复元素，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//情况1：</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last)<span class="comment">//若输入区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last;<span class="comment">//直接返回last</span></span><br><span class="line">  <span class="comment">//情况2：</span></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//定义当前位置的下一个位置(即当前元素的相邻元素)</span></span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;<span class="comment">//若还没到达尾端，执行while循环</span></span><br><span class="line">    <span class="keyword">if</span> (*__first == *__next)<span class="comment">//相邻元素值相等，则找到相邻重复元素</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//返回第一个元素的位置</span></span><br><span class="line">    __first = __next;<span class="comment">//若暂时找不到，则继续找，直到到达区间尾端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//情况3：</span></span><br><span class="line">  <span class="keyword">return</span> __last;<span class="comment">//直接返回尾端last</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">//实现过程和版本一一样，只是判断规则不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;</span><br><span class="line">	  <span class="comment">//如果找到相邻元素符合用户指定条件，就返回第一元素位置</span></span><br><span class="line">    <span class="keyword">if</span> (__binary_pred(*__first, *__next))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    __first = __next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//adjacent_find函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::adjacent_find</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;5,20,5,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (myvector.begin(), myvector.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the first pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  //using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (++it, myvector.end(), myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the second pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	the first pair of repeated elements are: 30</span></span><br><span class="line"><span class="comment">	the second pair of repeated elements are: 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search.</span></span><br><span class="line"><span class="comment">//在序列一[first1,last1)所涵盖的区间中，查找序列二[first2,last2)的首次出现点</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search函数功能：Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                            BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2)</span><br><span class="line">    <span class="keyword">return</span> find(__first1, __last1, *__first2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;<span class="comment">//若还没到达区间尾端</span></span><br><span class="line">    __first1 = find(__first1, __last1, *__first2);<span class="comment">//查找*first2在区间[first1,last1)首次出现的位置</span></span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)<span class="comment">//若在[first1,last1)中不存在*first2，即在[first1,last1)不存在子序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//则直接返回区间尾端</span></span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若[first1,last1)只有一个元素，即序列[first1,last1)小于序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//不可能成为其子序列，返回last1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*__current == *__p) &#123;<span class="comment">//若两个序列相对应的值相同</span></span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)<span class="comment">//若序列[first2,last2)只有两个元素，且与序列一匹配</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//则返回匹配的首次位置</span></span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若第一个序列小于第二个序列</span></span><br><span class="line">        <span class="keyword">return</span> __last1;<span class="comment">//返回last1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">BinaryPred</span>  __<span class="title">predicate</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">return</span> __first1;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__predicate(*__first1, *__first2))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">      <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1) <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (__predicate(*__current, *__p)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)</span><br><span class="line">        <span class="keyword">return</span> __last1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search_n.  Search for __count consecutive copies of __val.</span></span><br><span class="line"><span class="comment">//在序列[first,last)查找连续count个符合条件值value元素的位置</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search_n函数功能：Searches the range [first,last) for a sequence of count elements, </span></span><br><span class="line"><span class="comment">each comparing equal to val (or for which pred returns true).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search_n函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                             Size count, const T&amp; val);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n ( ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                              Size count, const T&amp; val, BinaryPredicate pred );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __STL_REQUIRES(_Tp, _EqualityComparable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//首先查找value第一次出现的位置</span></span><br><span class="line">    __first = find(__first, __last, __val);</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;<span class="comment">//若出现的位置不是区间尾端</span></span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;<span class="comment">//更新个数，下面只需查找n=count-1个连续相同value即可</span></span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;<span class="comment">//从当前位置的下一个位置开始查找</span></span><br><span class="line">	  <span class="comment">//若没有到达区间尾端，且个数n大于0，且区间元素与value值相等</span></span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; *__i == __val) &#123;</span><br><span class="line">        ++__i;<span class="comment">//继续查找</span></span><br><span class="line">        --__n;<span class="comment">//减少查找的次数，因为已经找到value再次出现</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)<span class="comment">//若区间尚未到达尾端，但是count个value已经查找到</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//则输出查找到的首次出现value的位置</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        __first = find(__i, __last, __val);<span class="comment">//若尚未找到连续count个value值的位置，则找出value下次出现的位置，并准备下一次while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BinaryPred</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>, </span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__binary_pred(*__first, __val))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;</span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;</span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; __binary_pred(*__i, __val)) &#123;</span><br><span class="line">        ++__i;</span><br><span class="line">        --__n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> __first;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (__i != __last) &#123;</span><br><span class="line">          <span class="keyword">if</span> (__binary_pred(*__i, __val))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++__i;</span><br><span class="line">        &#125;</span><br><span class="line">        __first = __i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//search和search_n函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::search_n</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mypredicate (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[]=&#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 30);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 30s found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 10, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 10s found at position " &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;10,20&#125;;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle1, needle1+2);  </span></span><br><span class="line"><span class="comment">	   if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle2, needle2+3, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	two 30s found at position 2</span></span><br><span class="line"><span class="comment">	two 10s found at position 5</span></span><br><span class="line"><span class="comment">	needle1 found at position 0</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary search (lower_bound, upper_bound, equal_range, binary_search).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//将value值与中间值比较，即是二分查找,若中间值小于value，则继续查找右半部分</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//若该区间存在与value相等的元素，则返回指向第一个与value相等的迭代器</span></span><br><span class="line"><span class="comment">//若该区间不存在与value相等的元素，则返回指向第一个不小于value值的迭代器</span></span><br><span class="line"><span class="comment">//若该区间的任何元素都比value值小，则返回last</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;<span class="comment">//若comp判断为true，则继续在右半部分查找</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若value小于中间元素值</span></span><br><span class="line">      __len = __half;<span class="comment">//查找左半部分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新len的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//返回大于value值的第一个元素的迭代器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator low,up;</span></span><br><span class="line"><span class="comment">	  low=std::lower_bound (v.begin(), v.end(), 20); //          ^</span></span><br><span class="line"><span class="comment">	  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	lower_bound at position 3</span></span><br><span class="line"><span class="comment">	upper_bound at position 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//计算区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间非空</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//len右移一位，相等于除以2，即half为区间的长度的一半</span></span><br><span class="line">    __middle = __first;<span class="comment">//初始化middle的值</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//前进middle位置，使其指向区间中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//若指定元素value大于中间元素值，则在右半部分继续查找</span></span><br><span class="line">		<span class="comment">//下面两行使first指向middle的下一个位置，即右半区间的起始位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若指定元素value小于中间元素值，则在左半部分继续查找</span></span><br><span class="line">      __len = __half;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若指定元素value等于中间元素值</span></span><br><span class="line">		<span class="comment">//在前半部分找lower_bound位置</span></span><br><span class="line">      __left = lower_bound(__first, __middle, __val);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">	  <span class="comment">//在后半部分找upper_bound</span></span><br><span class="line">      __right = upper_bound(++__middle, __first, __val);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);<span class="comment">//返回pair对象，第一个迭代器为left，第二个迭代器为right</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找区间与value相等的相邻重复元素的起始位置和结束位置</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序，思想还是采用二分查找法</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns the bounds of the subrange that includes all the elements of the range [first,last) with values equivalent to val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val,</span></span><br><span class="line"><span class="comment">                  Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __left = lower_bound(__first, __middle, __val, __comp);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">      __right = upper_bound(++__middle, __first, __val, __comp);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;           </span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//equal_range函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::equal_range, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mygreater (int i,int j) &#123; return (i&gt;j); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);                         // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment">	  std::pair&lt;std::vector&lt;int&gt;::iterator,std::vector&lt;int&gt;::iterator&gt; bounds;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                              // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20);            //          ^        ^</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using "mygreater" as comp:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end(), mygreater);                   // 30 30 20 20 20 10 10 10</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20, mygreater); //       ^        ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	bounds at positions 3 and 6</span></span><br><span class="line"><span class="comment">	bounds at positions 2 and 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找法</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !(__val &lt; *__i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val, __comp);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !__comp(__val, *__i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find_first_of, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//以[first2,last2)区间内的某些元素为查找目标，寻找他们在[first1,last1)区间首次出现的位置</span></span><br><span class="line"><span class="comment">//find_first_of函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator to the first element in the range [first1,last1) that matches any of the elements in [first2,last2). </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last1.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                                   BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) <span class="comment">//若序列一不为空，则遍历序列一，每次指定一个元素</span></span><br><span class="line">	  <span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (*__first1 == *__iter)<span class="comment">//若序列一的元素等于序列二的元素，则表示找到</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//返回找到的位置</span></span><br><span class="line">  <span class="keyword">return</span> __last1;<span class="comment">//否则没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) </span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (__comp(*__first1, *__iter))</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">  <span class="keyword">return</span> __last1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_first_of函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_first_of</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment">	#include &lt;cctype&gt;       // std::tolower</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool comp_case_insensitive (char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">	  return (std::tolower(c1)==std::tolower(c2));</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int mychars[] = &#123;'a','b','c','A','B','C'&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt; haystack (mychars,mychars+6);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle[] = &#123;'A','B','C'&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(), needle, needle+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(),</span></span><br><span class="line"><span class="comment">						  needle, needle+3, comp_case_insensitive);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first match is: A</span></span><br><span class="line"><span class="comment">	The first match is: a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">// Search [first2, last2) as a subsequence in [first1, last1), and return</span></span><br><span class="line"><span class="comment">// the *last* possible match.  Note that find_end for bidirectional iterators</span></span><br><span class="line"><span class="comment">// is much faster than for forward iterators.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for forward iterators. </span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为正向迭代器forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)<span class="comment">//若第二个区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last1;<span class="comment">//则直接返回第一个区间的尾端</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//以下利用search函数查找出某个子序列的首次出现点；若找不到直接返回last1</span></span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line"></span><br><span class="line">        = search(__first1, __last1, __first2, __last2);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)<span class="comment">//若返回的位置为尾端，则表示没找到</span></span><br><span class="line">        <span class="keyword">return</span> __result;<span class="comment">//返回last1</span></span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//若在[first1,last1)中找到[first2,last2)首次出现的位置，继续准备下一次查找</span></span><br><span class="line">		  </span><br><span class="line">        __result = __new_result;<span class="comment">//更新返回的位置</span></span><br><span class="line">        __first1 = __new_result;<span class="comment">//更新查找的起始位置</span></span><br><span class="line">        ++__first1;<span class="comment">//确定正确查找起始位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line">        = search(__first1, __last1, __first2, __last2, __comp);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __result = __new_result;</span><br><span class="line">        __first1 = __new_result;</span><br><span class="line">        ++__first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for bidirectional iterators.  Requires partial specialization.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为双向迭代器bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="comment">//利用反向迭代器很快就可以找到</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  <span class="comment">//查找时将序列一和序列二逆方向</span></span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)<span class="comment">//表示没找到</span></span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//找到了</span></span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();<span class="comment">//转会正常迭代器</span></span><br><span class="line">    advance(__result, -distance(__first2, __last2));<span class="comment">//调整回到子序列的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>, </span></span><br><span class="line"><span class="class">           _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2,</span><br><span class="line">                               __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();</span><br><span class="line">    advance(__result, -distance(__first2, __last2));</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">		  <span class="comment">// Dispatching functions for find_end.</span></span><br><span class="line"><span class="comment">//find_end函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">//注意：这里也有偏特化的知识</span></span><br><span class="line"><span class="comment">/*函数功能：Searches the range [first1,last1) for the last occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                              BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2),</span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_end函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_end</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4,5,1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; haystack (myints,myints+10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle1, needle1+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;4,5,1&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle2, needle2+3, myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	needle1 found at position 5</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/sort/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:12:55+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的sort排序算法，SGI STL中的排序算法不是简单的快速排序，而是交叉利用各种排序：堆排序、插入排序和快速排序；这样做的目的是提高效率，针对数据量比较大的采用快速排序，数据量比较小的可以采用堆排序或插入排序。本文介绍了有关排序的算法random_shuffle、partition、stable_partition、sort、stable_sort、partial_sort、partial_sort_copy、nth_element；注意：STL的sort排序算法的迭代器必须是随机访问迭代器。</p>
<h3 id="sort排序算法剖析"><a href="#sort排序算法剖析" class="headerlink" title="sort排序算法剖析"></a>sort排序算法剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a random number in the range [0, __n).  This function encapsulates</span></span><br><span class="line"><span class="comment">// whether we're using rand (part of the standard C library) or lrand48</span></span><br><span class="line"><span class="comment">// (not standard, but a much better choice whenever it's available).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Distance</span> __<span class="title">random_number</span>(_<span class="title">Distance</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">  <span class="keyword">return</span> rand() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> lrand48() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_shuffle</span></span><br><span class="line"><span class="comment">//将区间[first,last)内的元素随机重排</span></span><br><span class="line"><span class="comment">//两个版本的不同是随机数的取得</span></span><br><span class="line"><span class="comment">//版本一是使用内部随机数产生器</span></span><br><span class="line"><span class="comment">//版本二是使用一个会产生随机数的仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) randomly.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">generator by default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">specific generator (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last,</span></span><br><span class="line"><span class="comment">                       RandomNumberGenerator&amp; gen);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __random_number((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __rand((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_sample and random_sample_n (extensions, not part of the standard).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__random_number(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__rand(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first) </span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __random_number(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first)</span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __rand(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __rand,</span><br><span class="line">                         __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition, stable_partition, and their auxiliary functions</span></span><br><span class="line"><span class="comment">//若迭代器的类型为forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">		         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			 _<span class="title">Predicate</span>   __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			 <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;<span class="comment">//若为空，直接退出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__pred(*__first))<span class="comment">//若pred出first的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (++__first == __last) <span class="keyword">return</span> __first;<span class="comment">//先移动迭代器first，在判断是否到达尾端last</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//继续判断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++__next != __last)<span class="comment">//若下一个位置依然不是尾端</span></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__next)) &#123;<span class="comment">//继续pred出next的值，若为true</span></span><br><span class="line">      swap(*__first, *__next);<span class="comment">//交换值</span></span><br><span class="line">      ++__first;<span class="comment">//继续下一位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若迭代器的类型为bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter</span> __<span class="title">partition</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			       _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			       <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//若为空</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//直接退出</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (__pred(*__first))<span class="comment">//first的值符合不移动条件，则不移动该值</span></span><br><span class="line">        ++__first;<span class="comment">//只移动迭代器</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//若头指针符合移动</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    --__last;<span class="comment">//尾指针回溯</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//头指针等于尾指针</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//操作结束</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!__pred(*__last))<span class="comment">//尾指针的元素符合不移动操作</span></span><br><span class="line">        --__last;<span class="comment">//至移动迭代器，并不移动具体元素</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//尾指针的元素符合移动操作</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//头尾指针交换元素</span></span><br><span class="line">    ++__first;<span class="comment">//准备下一次循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将区间[first,last)的元素进行排序，被pred判断为true的放在区间的前段，判定为false的放在区间后段</span></span><br><span class="line"><span class="comment">//该算算可能会使元素的元素位置放生改变.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法功能：Rearranges the elements from the range [first,last), in such a way that all the elements</span></span><br><span class="line"><span class="comment">for which pred returns true precede all those for which it returns false. </span></span><br><span class="line"><span class="comment">The iterator returned points to the first element of the second group.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法原型：</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	BidirectionalIterator partition (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                                   BidirectionalIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">   			      _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			      _<span class="title">Predicate</span>   __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出迭代器first的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partition函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::partition</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return (i%2)==1; &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // set some values:</span></span><br><span class="line"><span class="comment">	  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator bound;</span></span><br><span class="line"><span class="comment">	  bound = std::partition (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // print out content:</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "odd elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "even elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	odd elements: 1 9 3 7 5</span></span><br><span class="line"><span class="comment">	even elements: 6 4 8 2</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">inplace_stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __pred(*__first) ? __last : __first;</span><br><span class="line">  _ForwardIter __middle = __first;</span><br><span class="line">  advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> rotate(__inplace_stable_partition(__first, __middle, __pred, </span><br><span class="line">                                           __len / <span class="number">2</span>),</span><br><span class="line">                __middle,</span><br><span class="line">                __inplace_stable_partition(__middle, __last, __pred,</span><br><span class="line">                                           __len - __len / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Predicate</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">stable_partition_adaptive</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Distance</span> __<span class="title">buffer_size</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len &lt;= __buffer_size) &#123;</span><br><span class="line">    _ForwardIter __result1 = __first;</span><br><span class="line">    _Pointer __result2 = __buffer;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last ; ++__first)</span><br><span class="line">      <span class="keyword">if</span> (__pred(*__first)) &#123;</span><br><span class="line">        *__result1 = *__first;</span><br><span class="line">        ++__result1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__result2 = *__first;</span><br><span class="line">        ++__result2;</span><br><span class="line">      &#125;</span><br><span class="line">    copy(__buffer, __result2, __result1);</span><br><span class="line">    <span class="keyword">return</span> __result1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter __middle = __first;</span><br><span class="line">    advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rotate(__stable_partition_adaptive(</span><br><span class="line">                          __first, __middle, __pred,</span><br><span class="line">                          __len / <span class="number">2</span>, __buffer, __buffer_size),</span><br><span class="line">                    __middle,</span><br><span class="line">                    __stable_partition_adaptive(</span><br><span class="line">                          __middle, __last, __pred,</span><br><span class="line">                          __len - __len / <span class="number">2</span>, __buffer, __buffer_size));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">stable_partition_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_ForwardIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.size() &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __stable_partition_adaptive(__first, __last, __pred,</span><br><span class="line">                                       _Distance(__buf.requested_size()),</span><br><span class="line">                                       __buf.begin(), __buf.size());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __inplace_stable_partition(__first, __last, __pred, </span><br><span class="line">                                      _Distance(__buf.requested_size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                     _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __stable_partition_aux(__first, __last, __pred,</span><br><span class="line">                                  __VALUE_TYPE(__first),</span><br><span class="line">                                  __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出快速排序的枢纽位置</span></span><br><span class="line"><span class="comment">//版本一采用operator&lt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//找出枢纽轴的位置</span></span><br><span class="line">	<span class="comment">//令头端迭代器向尾端方向移动，尾端迭代器向头端移动。</span></span><br><span class="line">	<span class="comment">//当*first不小于枢纽值时，就停下来，当*last不大于枢纽值时也停下来，然后检测两个迭代器是否交错</span></span><br><span class="line">	<span class="comment">//如果first仍然在左侧而last仍然在右侧，就交换两个元素，然后各自调整位置，向中央逼近，再继续执行相同的行为.</span></span><br><span class="line">	<span class="comment">//直到first和last两个迭代器交错，此时表示已找到枢纽轴位置即first所在的位置</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;<span class="comment">//first向尾端移动，直到遇到不小于枢纽值时，停止</span></span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;<span class="comment">//last向头端移动，直到遇到不大于枢纽值时，停止</span></span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))<span class="comment">//检测两个迭代器是否交错</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//交错，则此时已找到，即为first迭代器所指位置</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//否则交换迭代器所指的元素</span></span><br><span class="line">    ++__first;<span class="comment">//继续执行相同行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//版本一采用__comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__comp(*__first, __pivot))</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    iter_swap(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort() and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;</span><br><span class="line">  <span class="comment">//__insertion_sort的内循环</span></span><br><span class="line">  <span class="comment">//注意：一旦不再出现逆转对，循环就结束</span></span><br><span class="line">  <span class="keyword">while</span> (__val &lt; *__next) &#123;<span class="comment">//存在逆转对</span></span><br><span class="line">    *__last = *__next;<span class="comment">//调整元素</span></span><br><span class="line">    __last = __next;<span class="comment">//调整迭代器</span></span><br><span class="line">    --__next;<span class="comment">//左移一个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;<span class="comment">//value的正确插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>, </span></span><br><span class="line"><span class="class">                               _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;  </span><br><span class="line">  <span class="keyword">while</span> (__comp(__val, *__next)) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __val = *__last;<span class="comment">//记录尾元素</span></span><br><span class="line">  <span class="keyword">if</span> (__val &lt; *__first) &#123;<span class="comment">//尾元素比头元素还小</span></span><br><span class="line">	  <span class="comment">//将整个区间向右移一个位置</span></span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;<span class="comment">//令头元素等于原先的尾元素</span></span><br><span class="line">	<span class="comment">//以上两行命令的功能相等于交换两个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//尾元素不小于头元素</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Tp __val = *__last;</span><br><span class="line">  <span class="keyword">if</span> (__comp(__val, *__first)) &#123;</span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort以双层循环形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；</span></span><br><span class="line"><span class="comment">//内循环遍历子区间，将子区间内的每一个“逆转对”倒转过来，如果一旦不存在“逆转对”，表示排序完毕。</span></span><br><span class="line"><span class="comment">//“逆转对”概念：指任何两个迭代器i和j，i&lt;j,而*i&gt;*j.</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>; <span class="comment">//若区间为空，则退出</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)<span class="comment">//外循环，遍历整个区间</span></span><br><span class="line">	  <span class="comment">//[first,i)形成的子空间</span></span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                    _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                       _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first),</span><br><span class="line">                                 __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//判断元素个数是否大于16</span></span><br><span class="line">	  <span class="comment">//则把区间分割成两段，一端长度为16，另一端为剩余的长度</span></span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若不大于16，直接调用插入排序</span></span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold, __comp);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line"><span class="comment">//该函数找出2^k &lt;= n 的最大值k;</span></span><br><span class="line"><span class="comment">//例如：n=7,得k=2; n=20,得k=4; n=8,得k=3; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Size</span> __<span class="title">lg</span>(_<span class="title">Size</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line">  _Size __k;</span><br><span class="line">  <span class="keyword">for</span> (__k = <span class="number">0</span>; __n != <span class="number">1</span>; __n &gt;&gt;= <span class="number">1</span>) ++__k;</span><br><span class="line">  <span class="keyword">return</span> __k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="comment">//参数__depth_limit表示最大的分割层数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//__stl_threshold为全局常量，其值为16</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//若区间长度大于16</span></span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;<span class="comment">//表示分割恶化</span></span><br><span class="line">      partial_sort(__first, __last, __last);<span class="comment">//转而调用堆排序heap_sort()</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">	<span class="comment">//计算分割点cut，枢纽值是采用首、尾、中央三个的中间值</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">	<span class="comment">//对右半部分递归地进行排序</span></span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">    __last = __cut;<span class="comment">//接下来对左半部分递归地进行排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      partial_sort(__first, __last, __last, __comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>), __comp)),</span><br><span class="line">       __comp);</span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit, __comp);</span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SGI STL的排序算法，迭代器参数的类型必须是随机访问迭代器_RandomAccessIter</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Sorts the elements in the range [first,last) into ascending order.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用默认的operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//进行插入排序</span></span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                 _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">                     __comp);</span><br><span class="line">    __final_insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stable_sort() and its auxiliary functions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle);</span><br><span class="line">  __inplace_stable_sort(__middle, __last);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle, __comp);</span><br><span class="line">  __inplace_stable_sort(__middle, __last, __comp);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle,</span><br><span class="line">                         __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line">  merge(__first, __first + __step_size, __first + __step_size, __last,</span><br><span class="line">        __result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result,</span><br><span class="line">                     __comp);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line"></span><br><span class="line">  merge(__first, __first + __step_size,</span><br><span class="line">        __first + __step_size, __last,</span><br><span class="line">        __result,</span><br><span class="line">        __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_chunk_size = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Distance</span> __<span class="title">chunk_size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">chunk_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size, __comp);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Distance</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size, __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size,</span><br><span class="line">                   __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last, __comp);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()),</span><br><span class="line">                           __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first), </span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial_sort, partial_sort_copy, and auxiliary functions.</span></span><br><span class="line"><span class="comment">//重新安排序列[first,last)，使序列前半部分middle-first个最小元素以递增顺序排序，并将其置于[first,middle)</span></span><br><span class="line"><span class="comment">//其余last-middle个元素不指定任何排序，并将其置于[middle,last)</span></span><br><span class="line"><span class="comment">//注意：迭代器middle是在[first,last)范围之内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the elements before middle are the smallest elements in the entire range </span></span><br><span class="line"><span class="comment">and are sorted in ascending order, while the remaining elements are left without any specific order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	版本一 operator&lt; </span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2) 版本二 comp	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">		<span class="comment">//利用heap的知识，在SGI STL中，是采用最大堆</span></span><br><span class="line">		<span class="comment">//将[first,middle)区间的元素创建成最大堆</span></span><br><span class="line">		<span class="comment">//再根据最大堆的性质，一个一个弹出堆，并将其保存，即堆排序</span></span><br><span class="line">  make_heap(__first, __middle);<span class="comment">//创建最大堆，定义与&lt;stl_heap.h&gt;文件</span></span><br><span class="line">  <span class="comment">//以下是在区间中[first,last)找出middle-first个最小元素</span></span><br><span class="line">  <span class="comment">//这里的是将后半部分[middle,last)的元素依次与最大堆的根节点元素(即堆的最大元素)比较</span></span><br><span class="line">  <span class="comment">//若小于堆的最大元素，则与堆的最大元素交换，并调整堆，使其依次成为最大堆</span></span><br><span class="line">  <span class="comment">//若不小于堆的最大元素，则不作任何操作</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle);<span class="comment">//对最大堆进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  make_heap(__first, __middle, __comp);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__first))</span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partial_sort_copy与partial_sort的实现机制是相同，只是partial_sort_copy将元素排序后放在以result起始的容器中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, </span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first &lt; *__result_first) </span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first));</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last, </span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first, *__result_first))</span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first),</span><br><span class="line">                    __comp);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);  </span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last,</span><br><span class="line">                             __comp,</span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nth_element() and its auxiliary functions.  </span></span><br><span class="line"><span class="comment">//nth_element版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;<span class="comment">//区间长度大于3</span></span><br><span class="line">	  <span class="comment">//获取分割点cut</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)<span class="comment">//若分割点小于指定位置，则nth位置在右半段</span></span><br><span class="line">      __first = __cut;<span class="comment">//再对右半段进行分割</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则，对左半段进行分割</span></span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新排序序列[first,last)，使迭代器nth所指的元素，与“整个[first,last)序列完整排序后，同一位置的元素”同值.</span></span><br><span class="line"><span class="comment">//此外，必须保证[nth,last)内的所有元素不小于[first,nth)内的元素，但是对于序列[first,nth)和序列[nth,last)内的元素的排序顺序不能确定.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the element at the nth position is the element that would be in that position in a sorted sequence.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//nth_element版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>), </span><br><span class="line">                                         *(__last - <span class="number">1</span>),</span><br><span class="line">                                         __comp)),</span><br><span class="line">                            __comp);</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)</span><br><span class="line">      __first = __cut;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_sorted, a predicated testing whether a range is sorted in</span></span><br><span class="line"><span class="comment">// nondescending order.  This is an extension, not part of the C++</span></span><br><span class="line"><span class="comment">// standard.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__next &lt; *__first)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">StrictWeakOrdering</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">               _<span class="title">StrictWeakOrdering</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__next, *__first))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Set和Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Set和Map/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:10:50+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇博客中，讲到了STL中关于红黑树的实现，理解起来比较复杂，正所谓前人种树，后人乘凉，RBTree把树都种好了，接下来就该set和map这类关联式容器来“乘凉”了。</p>
<p>STL的set和map都是基于红黑树实现的，和stack和queue都是基于deque一样，它们仅仅是调用了RBTree提供的接口函数，然后进行外层封装即可。本篇博客理解起来比较轻松，set和map的源代码也不多，大家可以慢慢“品味”。另外，还会介绍multiset和multimap这两个容器，并给出它们的区别和应用等。还等什么呢？走吧，带你理解理解set和map吧！</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set是一种关联式容器，其特性如下：</p>
<ul>
<li>set以RBTree作为底层容器</li>
<li>所得元素的只有key没有value，value就是key</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
<li>不能通过迭代器来改变set的值，因为set的值就是键</li>
</ul>
<p>针对这五点来说，前四点都不用再多作说明，第五点需要做一下说明。如果set中允许修改键值的话，那么首先需要删除该键，然后调节平衡，在插入修改后的键值，再调节平衡，如此一来，严重破坏了set的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值。</p>
<h2 id="set的数据结构"><a href="#set的数据结构" class="headerlink" title="set的数据结构"></a>set的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器默认采用less，内部按照升序排列，配置器默认采用alloc</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//  在set中key就是value, value同时也是key</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Key value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于比较的函数</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;	<span class="comment">// t为内部RBTree容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 设置成const迭代器，set的键值不允许修改</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line">  <span class="comment">// 由于set的性质, value比较和key使用同一个比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明了两个友元函数，重载了==和&lt;操作符</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的构造函数"><a href="#set的构造函数" class="headerlink" title="set的构造函数"></a>set的构造函数</h2><p>set提供了如下几个构造函数用于初始化一个set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：下面相关函数都在set类中定义，为了介绍方便才抽出来单独讲解</span></span><br><span class="line"><span class="comment">// 空构造函数，初始化一个空的set</span></span><br><span class="line"><span class="built_in">set</span>() : t(Compare()) &#123;&#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器，如set&lt;int,greater&lt;int&gt; &gt; myset的初始化</span></span><br><span class="line">explicit set(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 实现诸如set&lt;int&gt; myset(anotherset.begin(),anotherset.end())这样的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">:</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器的初始化操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">:</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 以另一个set来初始化</span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line"><span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	t = x.t;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的操作函数"><a href="#set的操作函数" class="headerlink" title="set的操作函数"></a>set的操作函数</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>插入函数，调用RBTree的插入函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  pair&lt;iterator, <span class="keyword">bool</span>&gt; pair_iterator_bool;</span><br><span class="line"><span class="comment">// 由于set不允许键值重复，所以必须调用RBTree的insert_unique函数</span></span><br><span class="line"><span class="comment">// second表示插入操作是否成功</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="keyword">bool</span>&gt; p = t.insert_unique(x);</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到set中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>擦除函数，用于擦除单个元素或者区间内的元素，直接调用RBTree的函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识set内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.erase(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除指定区间的元素, 会导致红黑树有较大变化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除整个set容器，直接调用RBTree的clean函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找函数，RBTree也提供了，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>查找制定元素的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定元素的个数, set不允许键值重复，其实就是测试元素是否在set中</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.count(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>set重载了==和&lt;操作符，基本上都是调用RBTree的接口函数即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">x</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const set&lt;Key, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const set&lt;Key, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数"><a href="#其他操作函数" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>multiset相对于set来说，区别就是multiset允许键值重复，在multiset中调用的是RBTree的insert_equal函数，其他的基本与set相同。</p>
<p>其他的就不赘述了，下面列举一下跟set不同的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数，</span></span><br><span class="line"><span class="comment">// 注意！！！！插入操作采用的是RBTree的insert_equal，而不是insert_unique</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下：</p>
<ul>
<li>map以RBTree作为底层容器</li>
<li>所有元素都是键+值存在</li>
<li>不允许键重复</li>
<li>所有元素是通过键进行自动排序的</li>
<li>map的键是不能修改的，但是其键对应的值是可以修改的</li>
</ul>
<p>在map中，一个键对应一个值，其中键不允许重复，不允许修改，但是键对应的值是可以修改的，原因可以看上面set中的解释。下面就一起来看看STL中的map的源代码。</p>
<h2 id="map的数据结构"><a href="#map的数据结构" class="headerlink" title="map的数据结构"></a>map的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认比较器为less&lt;key&gt;,元素按照键的大小升序排列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;                         <span class="comment">// key类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T data_type;                          <span class="comment">// value类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;        <span class="comment">// 元素类型, 要保证key不被修改</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;                  <span class="comment">// 用于key比较的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t; <span class="comment">// t为内部RBTree容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 注意：这里与set不一样，map的迭代器是可以修改的</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规的返回迭代器函数</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于map的性质, value和key使用同一个比较函数, 实际上我们并不使用value比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value_compare(t.key_comp()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意: 这里有一个常见的陷阱, 如果访问的key不存在, 会新建立一个</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (*((insert(value_type(k, T()))).first)).second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重载了==和&lt;操作符，后面会有实现</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的构造函数"><a href="#map的构造函数" class="headerlink" title="map的构造函数"></a>map的构造函数</h2><p>map提供了一下的构造函数来初始化一个map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造函数，直接调用RBTree的空构造函数</span></span><br><span class="line"><span class="built_in">map</span>() : t(Compare()) &#123;&#125;</span><br><span class="line">explicit map(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end())的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end(),less&lt;int&gt;)初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int&gt; maMap(anotherMap)的初始化</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 重载=操作符，赋值运算符</span></span><br><span class="line"><span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  t = x.t;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的操作函数"><a href="#map的操作函数" class="headerlink" title="map的操作函数"></a>map的操作函数</h2><h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>同set一样，直接调用RBTree的插入函数即可，注意map不允许键值重复，所以调用的是insert_unique</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于相同的key, 只允许出现一次, bool标识</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x) &#123; <span class="keyword">return</span> t.insert_unique(x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处</span></span><br><span class="line">插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique(position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到map中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase-1"><a href="#erase-1" class="headerlink" title="erase"></a>erase</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.erase(position); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识map内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.erase(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.erase(first, last); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean-1"><a href="#clean-1" class="headerlink" title="clean"></a>clean</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定key的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">````</span><br><span class="line">### 重载运算符</span><br><span class="line">上面介绍到<span class="built_in">map</span>重载了[],==和&lt;运算符，[]的实现已经介绍过，下面是==和&lt;的实现</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 比较map直接是对其底层容器t的比较，直接调用RBTree的比较函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;class Key, class T, class Compare, class Alloc&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const map&lt;Key, T, Compare, Alloc&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数-1"><a href="#其他操作函数-1" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.lower_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.upper_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>multimap和map的关系就跟multiset和set的关系一样，multimap允许键的值相同，因此在插入操作的时候用到insert_equal()，除此之外，基本上与map相同。</p>
<p>下面就仅仅列出不同的地方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// ... 其他地方与map相同</span></span><br><span class="line">  <span class="comment">// 注意下面这些函数都调用的是insert_equal，而不是insert_unique</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">    :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">    :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.insert_equal(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line">  <span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.insert_equal(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入一个区间内的元素</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    t.insert_equal(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其余地方和map相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这四类容器仅仅只是在RBTree上进行了一层封装，首先，set和map的区别就在于键和值是否相同，set中将值作为键，支持STL的提供的一些交集、并集和差集等运算；map的键和值不同，每个键都有自己的值，键不能重复，但是值可以重复。</p>
<p>multimap和multiset就在map和set的基础上，使他们的键可以重复，除此之外基本等同。</p>
<p>关于map和set的用法，大家可以在其源代码中找到，这里就不在赘述，本系列博客也是基于源码的角度来分析这些容器。到此，end！</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/bolgzxy.github.io/page/4/">4</a><a class="page-number" href="/bolgzxy.github.io/page/5/">5</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
