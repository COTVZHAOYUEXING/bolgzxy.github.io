<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/STL函数对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/STL函数对象/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:16:10+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在STL中，函数对象也是比较重要的，有时候可以限定STL算法的行为，例如在前面介绍的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL</a><a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">算法剖析</a>》中，每个算法基本上都提供了两个操作版本，其中就有一个版本允许用户指定函数对象，这样可以根据用户的需要对算法进行操作。函数对象是一种具有函数特质的对象，所以可以作为算法的参数。本文介绍的函数对象比较简单，是基于一元或者二元操作结构的算术类函数对象、关系运算类函数对象、逻辑运算类函数对象。在定义函数对象时，为了使其具有函数行为，则必须重载operator()操作符。本文源码出自SGI STL中的&lt;stl_function.h&gt;文件。</p>
<h3 id="函数对象源码剖析"><a href="#函数对象源码剖析" class="headerlink" title="函数对象源码剖析"></a>函数对象源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">_STL_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">//一元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg argument_type;<span class="comment">//参数类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//二元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg1 first_argument_type;<span class="comment">//参数一类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg2 second_argument_type;<span class="comment">//参数二类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作算术函数对象，继承二元操作binary_function的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加法操作plus&lt;T&gt;,减法操作minus&lt;T&gt;,乘法操作multiplies&lt;T&gt;,除法操作divides&lt;T&gt;,</span></span><br><span class="line"><span class="comment">取模运算modulus&lt;T&gt;,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x + __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x - __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">multiplies</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x * __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">divides</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x / __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">modulus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x % __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一元操作，继承一元操作unary_function结构</span></span><br><span class="line"><span class="comment">//负值操作negate&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// identity_element (not part of the C++ standard).</span></span><br><span class="line"><span class="comment">//证同元素：</span></span><br><span class="line"><span class="comment">//以下只提供的两种证同元素</span></span><br><span class="line"><span class="comment">//加法：任何元素加上0结果都为自身</span></span><br><span class="line"><span class="comment">//乘法：任何元素乘以1结果都为自身</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">plus</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">multiplies</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作关系函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值的类型是bool型别</span></span><br><span class="line"><span class="comment">equal_to,not_equal_to,greater,less,greater_equal,less_equal,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x == __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">not_equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x != __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作逻辑函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中logical_not为一元操作函数</span></span><br><span class="line"><span class="comment">logical_and,logical_or,logical_not</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &amp;&amp; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x || __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// identity is an extensions: it is not part of the standard.</span></span><br><span class="line"><span class="comment">//证同函数</span></span><br><span class="line"><span class="comment">//任何数值通过此函数后，不会有任何修改。所以返回值类型为const引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Identity</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> _<span class="function">Tp&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> _Identity&lt;_Tp&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select1st and select2nd are extensions: they are not part of the standard.</span></span><br><span class="line"><span class="comment">//选择函数</span></span><br><span class="line"><span class="comment">//版本一：选择pair元素的第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：选择pair元素的第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::second_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> _Select1st&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> _Select2nd&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project1st and project2nd are extensions: they are not part of the standard</span></span><br><span class="line"><span class="comment">//投射函数</span></span><br><span class="line"><span class="comment">//版本一：投射出第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project1st</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg1&gt; &#123;</span><br><span class="line">  _<span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp; __x, <span class="keyword">const</span> _Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：投射出第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project2nd</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg2&gt; &#123;</span><br><span class="line">  _<span class="function">Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp;, <span class="keyword">const</span> _Arg2&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project1st</span> :</span> <span class="keyword">public</span> _Project1st&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project2nd</span> :</span> <span class="keyword">public</span> _Project2nd&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Permutation/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:15:08+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文讲解的是STL算法中的permutation排列组合算法，根据输入序列，排列出下一个排列组合或前一个排列组合。</p>
<h3 id="permutation排列组合源码剖析"><a href="#permutation排列组合源码剖析" class="headerlink" title="permutation排列组合源码剖析"></a>permutation排列组合源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next_permutation and prev_permutation, with and without an explicitly </span></span><br><span class="line"><span class="comment">// supplied comparison function.</span></span><br><span class="line"><span class="comment">//next_permutation获取[first,last)区间所标示序列的下一个排列组合，若果没有下一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the next lexicographically greater permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp决定</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若为空，则返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;<span class="comment">//i指向尾端</span></span><br><span class="line">  --__i;<span class="comment">//不断后移</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;<span class="comment">//</span></span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__ii) &#123;<span class="comment">//若前一个元素小于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个大于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端</span></span><br><span class="line">      <span class="keyword">while</span> (!(*__i &lt; *--__j))<span class="comment">//由尾端往前检查，直到遇到比*i大的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);<span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//整个区间全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__ii)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*__i, *--__j))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//next_permutation函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt;' ' &lt;&lt; myints[3]&lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::next_permutation(myints,myints+4) );</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">	  //std::next_permutation(myints,myints+4);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; ' ' &lt;&lt; myints[3]&lt;&lt;'\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	1 2 3 4</span></span><br><span class="line"><span class="comment">	1 2 4 3</span></span><br><span class="line"><span class="comment">	1 3 2 4</span></span><br><span class="line"><span class="comment">	1 3 4 2</span></span><br><span class="line"><span class="comment">	1 4 2 3</span></span><br><span class="line"><span class="comment">	1 4 3 2</span></span><br><span class="line"><span class="comment">	2 1 3 4</span></span><br><span class="line"><span class="comment">	2 1 4 3</span></span><br><span class="line"><span class="comment">	2 3 1 4</span></span><br><span class="line"><span class="comment">	2 3 4 1</span></span><br><span class="line"><span class="comment">	2 4 1 3</span></span><br><span class="line"><span class="comment">	2 4 3 1</span></span><br><span class="line"><span class="comment">	3 1 2 4</span></span><br><span class="line"><span class="comment">	3 1 4 2</span></span><br><span class="line"><span class="comment">	3 2 1 4</span></span><br><span class="line"><span class="comment">	3 2 4 1</span></span><br><span class="line"><span class="comment">	3 4 1 2</span></span><br><span class="line"><span class="comment">	3 4 2 1</span></span><br><span class="line"><span class="comment">	4 1 2 3</span></span><br><span class="line"><span class="comment">	4 1 3 2</span></span><br><span class="line"><span class="comment">	4 2 1 3</span></span><br><span class="line"><span class="comment">	4 2 3 1</span></span><br><span class="line"><span class="comment">	4 3 1 2</span></span><br><span class="line"><span class="comment">	4 3 2 1</span></span><br><span class="line"><span class="comment">	After loop: 1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prev_permutation获取[first,last)区间所标示序列的上一个排列组合，若果没有上一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the previous lexicographically-ordered permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last );</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若区间为空，返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false</span></span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__ii &lt; *__i) &#123;<span class="comment">//若前一个元素大于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个小于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端      </span></span><br><span class="line">      <span class="keyword">while</span> (!(*--__j &lt; *__i))<span class="comment">//由尾端往前检查，直到遇到比*i小的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j); <span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//把区间所有元素逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__ii, *__i)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*--__j, *__i))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prev_permutation函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort, std::reverse</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+3);</span></span><br><span class="line"><span class="comment">	  std::reverse (myints,myints+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::prev_permutation(myints,myints+3) );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	3 2 1</span></span><br><span class="line"><span class="comment">	3 1 2</span></span><br><span class="line"><span class="comment">	2 3 1</span></span><br><span class="line"><span class="comment">	2 1 3</span></span><br><span class="line"><span class="comment">	1 3 2</span></span><br><span class="line"><span class="comment">	1 2 3</span></span><br><span class="line"><span class="comment">	After loop: 3 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/remove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/remove/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:14:31+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的remove删除算法，源码中介绍了函数remove、remove_copy、remove_if、remove_copy_if、unique、unique_copy。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="remove移除算法源码剖析"><a href="#remove移除算法源码剖析" class="headerlink" title="remove移除算法源码剖析"></a>remove移除算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove, remove_if, remove_copy, remove_copy_if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素，并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">OutputIter</span> __<span class="title">result</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__first == __value)) &#123;<span class="comment">//如果不相等</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内被仿函数pred判断为true的元素,并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!__pred(*__first)) &#123;<span class="comment">//若pred判断为false</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  __STL_CONVERTIBLE(_Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find(__first, __last, __value);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy(++__i, __last, __first, __value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有被pred判断为true的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove_if</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">               <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find_if(__first, __last, __pred);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy_if</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy_if(++__i, __last, __first, __pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面四个移除函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::remove</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return ((i%2)==1); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,31,30,20,11,10,20&#125;;      // 10 20 31 30 20 11 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (8);</span></span><br><span class="line"><span class="comment">	  std::remove_copy (myints,myints+8,myvector.begin(),20); // 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // bounds of range:</span></span><br><span class="line"><span class="comment">	  int* pbegin = myints;                          // ^</span></span><br><span class="line"><span class="comment">	  int* pend = myints+sizeof(myints)/sizeof(int); // ^                       ^</span></span><br><span class="line"><span class="comment">	  pend = std::remove (pbegin, pend, 20);         // 10 31 30 11 10 ?  ?  ?</span></span><br><span class="line"><span class="comment">													 // ^              ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector2 (7);</span></span><br><span class="line"><span class="comment">	  std::remove_copy_if (myints,myints+7,myvector2.begin(),IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector2 contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector2.begin(); it!=myvector2.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  pend = std::remove_if (pbegin, pend, IsOdd);   // 10 30 10 ? ? ? ? ?</span></span><br><span class="line"><span class="comment">													 // ^       ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "the range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	myvector contains: 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	range contains: 10 31 30 11 10</span></span><br><span class="line"><span class="comment">	myvector2 contains: 10 30 10 10 0 0 0</span></span><br><span class="line"><span class="comment">	the range contains: 10 30 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique and unique_copy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!(__value == *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为output_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">		<span class="comment">//判断first的value_type类型，根据不同类型调用不同函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为forward_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  *__result = *__first;<span class="comment">//记录第一个元素</span></span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)<span class="comment">//遍历区间</span></span><br><span class="line">	  <span class="comment">//若不存在相邻重复元素，则继续记录到目标区result</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__result == *__first))</span><br><span class="line">      *++__result = *__first;<span class="comment">//记录元素到目标区</span></span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////unique_copy将区间[first,last)内元素复制到以result开头的区间上，但是如果存在相邻重复元素时，只复制其中第一个元素</span></span><br><span class="line"><span class="comment">//和unique一样，这里也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result);</span></span><br><span class="line"><span class="comment">predicate (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result, BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(__value, *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(*__result, *__first)) *++__result = *__first;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除区间[first,last)相邻连续重复的元素</span></span><br><span class="line"><span class="comment">//unique有两个版本</span></span><br><span class="line"><span class="comment">//功能：Removes all but the first element from every consecutive group of equivalent elements in the range [first,last).</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一采用operator==	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二采用pred操作	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                          BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __first = adjacent_find(__first, __last);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = adjacent_find(__first, __last, __binary_pred);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first, __binary_pred);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/merge/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:14:02+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的merge合并算法。源码中介绍了函数merge、inplace_merge。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="merge合并算法源码剖析"><a href="#merge合并算法源码剖析" class="headerlink" title="merge合并算法源码剖析"></a>merge合并算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//将两个已排序的区间[first1,last1)和区间[first2,last2)合并</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Combines the elements in the sorted ranges [first1,last1) and [first2,last2), </span></span><br><span class="line"><span class="comment">into a new range beginning at result with all its elements sorted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2,</span></span><br><span class="line"><span class="comment">          class OutputIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//两个序列都尚未到达尾端，则执行while循环</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若序列二元素较小,则记录到目标区，且移动序列二的迭代器，但是序列一的迭代器不变.</span></span><br><span class="line"><span class="comment">  情况2：若序列一元素较小或相等,则记录到目标区，且移动序列一的迭代器，但是序列二的迭代器不变.</span></span><br><span class="line"><span class="comment">  最后：把剩余元素的序列复制到目标区</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">	  <span class="comment">//情况1</span></span><br><span class="line">    <span class="keyword">if</span> (*__first2 &lt; *__first1) &#123;<span class="comment">//若序列二元素较小</span></span><br><span class="line">      *__result = *__first2;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first2;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//情况2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列一元素较小或相等</span></span><br><span class="line">      *__result = *__first1;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first1;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;<span class="comment">//更新目标区位置，以便下次记录数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若有序列到达尾端，则把没到达尾端的序列剩余元素复制到目标区</span></span><br><span class="line">  <span class="comment">//此时，区间[first1,last1)和区间[first2,last2)至少一个必定为空</span></span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type);</span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first2, *__first1)) &#123;</span><br><span class="line">      *__result = *__first2;</span><br><span class="line">      ++__first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *__result = *__first1;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::merge, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment">	  std::merge (first,first+5,second,second+5,v.begin());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inplace_merge and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//版本一的辅助函数，无缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; *__first)</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle,</span><br><span class="line">                         __len11, __len22);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, *__first))</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,</span><br><span class="line">                         __comp);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span> __<span class="title">rotate_adaptive</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter2</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _BidirectionalIter2 __buffer_end;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2 &amp;&amp; __len2 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列二</span></span><br><span class="line">    __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    copy_backward(__first, __middle, __last);</span><br><span class="line">    <span class="keyword">return</span> copy(__buffer, __buffer_end, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len1 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列一</span></span><br><span class="line">    __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    copy(__middle, __last, __first);</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若缓冲区仍然不够，则调用STL算法rotate，不使用缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> rotate(__first, __middle, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__last2 &lt; *__last1) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__last2, *__last1)) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case1：把序列一放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">	<span class="comment">//直接调用归并函数merge</span></span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case2：把序列二放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//case3：缓冲区不足放置任何一个序列</span></span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;<span class="comment">//若序列一比较长</span></span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;<span class="comment">//计算序列一的一半</span></span><br><span class="line">      advance(__first_cut, __len11);<span class="comment">//让first_cut指向序列一的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__first_cut在[middle,last)区间中的第一个不小于*__first_cut的元素位置</span></span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">	  <span class="comment">//计算middle到__second_cut之间的距离，保存在__len22</span></span><br><span class="line">      distance(__middle, __second_cut, __len22); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列二比较长</span></span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;<span class="comment">//计算序列二的一半</span></span><br><span class="line">      advance(__second_cut, __len22);<span class="comment">//让__second_cut指向序列二的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__second_cut在[first,middle)区间中的第一个大于*__second_cut的元素位置</span></span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">	  <span class="comment">//计算__first到__first_cut之间的距离，保存在__len11</span></span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对左半段递归调用</span></span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对右半段递归调用</span></span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last,</span><br><span class="line">                     __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">      advance(__first_cut, __len11);</span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">      distance(__middle, __second_cut, __len22);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">      advance(__second_cut, __len22);</span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);<span class="comment">//计算序列一的长度</span></span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);<span class="comment">//计算序列二的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用暂时缓冲区</span></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)<span class="comment">//若缓冲区配置失败</span></span><br><span class="line">	  <span class="comment">//则调用不使用缓冲区的合并操作</span></span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2);</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若分配成功</span></span><br><span class="line">	  <span class="comment">//则调用具有缓冲区的合并操作</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);</span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);</span><br><span class="line"></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()),</span><br><span class="line">                     __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个已排序的序列[first,middle)和[middle,last)合并成单一有序序列.</span></span><br><span class="line"><span class="comment">//若原来是增序，现在也是递增排序，若原来是递减排序，现在也是递减排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Merges two consecutive sorted ranges: [first,middle) and [middle,last), </span></span><br><span class="line"><span class="comment">putting the result into the combined sorted range [first,last).</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)<span class="comment">//若有空序列，则之间返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first),</span><br><span class="line">                      __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inplace_merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::inplace_merge, std::sort, std::copy</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  it=std::copy (first, first+5, v.begin());</span></span><br><span class="line"><span class="comment">		 std::copy (second,second+5,it);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::inplace_merge (v.begin(),v.begin()+5,v.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/find/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:13:28+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的find、search查找算法。在STL源码中有关算法的函数大部分在本文介绍，包含findand find_if、adjacent_find、search、search_n、lower_bound、upper_bound、equal_range、binary_search、find_first_of、find_end相关算法，下面对这些算法的源码进行了详细的剖析，并且适当给出应用例子，增加我们对其理解，方便我们使用这些算法。具体详见下面源码剖析。</p>
<h3 id="查找算法源码剖析"><a href="#查找算法源码剖析" class="headerlink" title="查找算法源码剖析"></a>查找算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find and find_if.</span></span><br><span class="line"><span class="comment">//查找区间[first,last)内元素第一个与value值相等的元素，并返回其位置</span></span><br><span class="line"><span class="comment">//其中find函数是采用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//find_if是采用用户自行指定的操作pred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !(*__first == __val))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !__pred(*__first))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find_if</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"><span class="comment">/*find函数功能：Returns an iterator to the first element in the range [first,last) that compares equal to val. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find (InputIterator first, InputIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">            <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find(__first, __last, __val, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*find_if函数功能：Returns an iterator to the first element in the range [first,last) for which pred returns true. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find_if函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find_if 函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find_if(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find和find_if函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_if</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123;</span></span><br><span class="line"><span class="comment">	  return ((i%2)==1);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  myvector.push_back(10);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(25);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(40);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(55);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it = std::find_if (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The first odd value is " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using std::find with vector and iterator:</span></span><br><span class="line"><span class="comment">	  it = find (myvector.begin(), myvector.end(), 40);</span></span><br><span class="line"><span class="comment">	  if (it != myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element not found in myints\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first odd value is 25</span></span><br><span class="line"><span class="comment">	Element found in myvector: 40</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjacent_find.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找区间[first,last)内第一次重复的相邻元素</span></span><br><span class="line"><span class="comment">//若存在返回相邻元素的第一个元素位置</span></span><br><span class="line"><span class="comment">//若不存在返回last位置</span></span><br><span class="line"><span class="comment">/*该函数有两个版本：第一版本是默认操作operator==；第二版本是用户指定的二元操作pred</span></span><br><span class="line"><span class="comment">函数对外接口的原型：</span></span><br><span class="line"><span class="comment">equality (1)：默认操作是operator==</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                                  BinaryPredicate pred);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：默认操作是operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若输入区间为空，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  情况2：若输入区间不为空，且存在相邻重复元素，则返回相邻元素的第一个元素的位置；</span></span><br><span class="line"><span class="comment">  情况3：若输入区间不为空，但是不存在相邻重复元素，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//情况1：</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last)<span class="comment">//若输入区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last;<span class="comment">//直接返回last</span></span><br><span class="line">  <span class="comment">//情况2：</span></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//定义当前位置的下一个位置(即当前元素的相邻元素)</span></span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;<span class="comment">//若还没到达尾端，执行while循环</span></span><br><span class="line">    <span class="keyword">if</span> (*__first == *__next)<span class="comment">//相邻元素值相等，则找到相邻重复元素</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//返回第一个元素的位置</span></span><br><span class="line">    __first = __next;<span class="comment">//若暂时找不到，则继续找，直到到达区间尾端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//情况3：</span></span><br><span class="line">  <span class="keyword">return</span> __last;<span class="comment">//直接返回尾端last</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">//实现过程和版本一一样，只是判断规则不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;</span><br><span class="line">	  <span class="comment">//如果找到相邻元素符合用户指定条件，就返回第一元素位置</span></span><br><span class="line">    <span class="keyword">if</span> (__binary_pred(*__first, *__next))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    __first = __next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//adjacent_find函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::adjacent_find</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;5,20,5,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (myvector.begin(), myvector.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the first pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  //using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (++it, myvector.end(), myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the second pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	the first pair of repeated elements are: 30</span></span><br><span class="line"><span class="comment">	the second pair of repeated elements are: 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search.</span></span><br><span class="line"><span class="comment">//在序列一[first1,last1)所涵盖的区间中，查找序列二[first2,last2)的首次出现点</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search函数功能：Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                            BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2)</span><br><span class="line">    <span class="keyword">return</span> find(__first1, __last1, *__first2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;<span class="comment">//若还没到达区间尾端</span></span><br><span class="line">    __first1 = find(__first1, __last1, *__first2);<span class="comment">//查找*first2在区间[first1,last1)首次出现的位置</span></span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)<span class="comment">//若在[first1,last1)中不存在*first2，即在[first1,last1)不存在子序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//则直接返回区间尾端</span></span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若[first1,last1)只有一个元素，即序列[first1,last1)小于序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//不可能成为其子序列，返回last1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*__current == *__p) &#123;<span class="comment">//若两个序列相对应的值相同</span></span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)<span class="comment">//若序列[first2,last2)只有两个元素，且与序列一匹配</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//则返回匹配的首次位置</span></span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若第一个序列小于第二个序列</span></span><br><span class="line">        <span class="keyword">return</span> __last1;<span class="comment">//返回last1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">BinaryPred</span>  __<span class="title">predicate</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">return</span> __first1;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__predicate(*__first1, *__first2))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">      <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1) <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (__predicate(*__current, *__p)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)</span><br><span class="line">        <span class="keyword">return</span> __last1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search_n.  Search for __count consecutive copies of __val.</span></span><br><span class="line"><span class="comment">//在序列[first,last)查找连续count个符合条件值value元素的位置</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search_n函数功能：Searches the range [first,last) for a sequence of count elements, </span></span><br><span class="line"><span class="comment">each comparing equal to val (or for which pred returns true).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search_n函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                             Size count, const T&amp; val);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n ( ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                              Size count, const T&amp; val, BinaryPredicate pred );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __STL_REQUIRES(_Tp, _EqualityComparable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//首先查找value第一次出现的位置</span></span><br><span class="line">    __first = find(__first, __last, __val);</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;<span class="comment">//若出现的位置不是区间尾端</span></span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;<span class="comment">//更新个数，下面只需查找n=count-1个连续相同value即可</span></span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;<span class="comment">//从当前位置的下一个位置开始查找</span></span><br><span class="line">	  <span class="comment">//若没有到达区间尾端，且个数n大于0，且区间元素与value值相等</span></span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; *__i == __val) &#123;</span><br><span class="line">        ++__i;<span class="comment">//继续查找</span></span><br><span class="line">        --__n;<span class="comment">//减少查找的次数，因为已经找到value再次出现</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)<span class="comment">//若区间尚未到达尾端，但是count个value已经查找到</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//则输出查找到的首次出现value的位置</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        __first = find(__i, __last, __val);<span class="comment">//若尚未找到连续count个value值的位置，则找出value下次出现的位置，并准备下一次while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BinaryPred</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>, </span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__binary_pred(*__first, __val))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;</span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;</span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; __binary_pred(*__i, __val)) &#123;</span><br><span class="line">        ++__i;</span><br><span class="line">        --__n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> __first;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (__i != __last) &#123;</span><br><span class="line">          <span class="keyword">if</span> (__binary_pred(*__i, __val))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++__i;</span><br><span class="line">        &#125;</span><br><span class="line">        __first = __i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//search和search_n函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::search_n</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mypredicate (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[]=&#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 30);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 30s found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 10, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 10s found at position " &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;10,20&#125;;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle1, needle1+2);  </span></span><br><span class="line"><span class="comment">	   if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle2, needle2+3, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	two 30s found at position 2</span></span><br><span class="line"><span class="comment">	two 10s found at position 5</span></span><br><span class="line"><span class="comment">	needle1 found at position 0</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary search (lower_bound, upper_bound, equal_range, binary_search).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//将value值与中间值比较，即是二分查找,若中间值小于value，则继续查找右半部分</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//若该区间存在与value相等的元素，则返回指向第一个与value相等的迭代器</span></span><br><span class="line"><span class="comment">//若该区间不存在与value相等的元素，则返回指向第一个不小于value值的迭代器</span></span><br><span class="line"><span class="comment">//若该区间的任何元素都比value值小，则返回last</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;<span class="comment">//若comp判断为true，则继续在右半部分查找</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若value小于中间元素值</span></span><br><span class="line">      __len = __half;<span class="comment">//查找左半部分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新len的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//返回大于value值的第一个元素的迭代器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator low,up;</span></span><br><span class="line"><span class="comment">	  low=std::lower_bound (v.begin(), v.end(), 20); //          ^</span></span><br><span class="line"><span class="comment">	  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	lower_bound at position 3</span></span><br><span class="line"><span class="comment">	upper_bound at position 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//计算区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间非空</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//len右移一位，相等于除以2，即half为区间的长度的一半</span></span><br><span class="line">    __middle = __first;<span class="comment">//初始化middle的值</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//前进middle位置，使其指向区间中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//若指定元素value大于中间元素值，则在右半部分继续查找</span></span><br><span class="line">		<span class="comment">//下面两行使first指向middle的下一个位置，即右半区间的起始位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若指定元素value小于中间元素值，则在左半部分继续查找</span></span><br><span class="line">      __len = __half;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若指定元素value等于中间元素值</span></span><br><span class="line">		<span class="comment">//在前半部分找lower_bound位置</span></span><br><span class="line">      __left = lower_bound(__first, __middle, __val);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">	  <span class="comment">//在后半部分找upper_bound</span></span><br><span class="line">      __right = upper_bound(++__middle, __first, __val);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);<span class="comment">//返回pair对象，第一个迭代器为left，第二个迭代器为right</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找区间与value相等的相邻重复元素的起始位置和结束位置</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序，思想还是采用二分查找法</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns the bounds of the subrange that includes all the elements of the range [first,last) with values equivalent to val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val,</span></span><br><span class="line"><span class="comment">                  Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __left = lower_bound(__first, __middle, __val, __comp);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">      __right = upper_bound(++__middle, __first, __val, __comp);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;           </span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//equal_range函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::equal_range, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mygreater (int i,int j) &#123; return (i&gt;j); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);                         // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment">	  std::pair&lt;std::vector&lt;int&gt;::iterator,std::vector&lt;int&gt;::iterator&gt; bounds;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                              // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20);            //          ^        ^</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using "mygreater" as comp:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end(), mygreater);                   // 30 30 20 20 20 10 10 10</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20, mygreater); //       ^        ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	bounds at positions 3 and 6</span></span><br><span class="line"><span class="comment">	bounds at positions 2 and 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找法</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !(__val &lt; *__i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val, __comp);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !__comp(__val, *__i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find_first_of, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//以[first2,last2)区间内的某些元素为查找目标，寻找他们在[first1,last1)区间首次出现的位置</span></span><br><span class="line"><span class="comment">//find_first_of函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator to the first element in the range [first1,last1) that matches any of the elements in [first2,last2). </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last1.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                                   BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) <span class="comment">//若序列一不为空，则遍历序列一，每次指定一个元素</span></span><br><span class="line">	  <span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (*__first1 == *__iter)<span class="comment">//若序列一的元素等于序列二的元素，则表示找到</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//返回找到的位置</span></span><br><span class="line">  <span class="keyword">return</span> __last1;<span class="comment">//否则没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) </span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (__comp(*__first1, *__iter))</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">  <span class="keyword">return</span> __last1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_first_of函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_first_of</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment">	#include &lt;cctype&gt;       // std::tolower</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool comp_case_insensitive (char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">	  return (std::tolower(c1)==std::tolower(c2));</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int mychars[] = &#123;'a','b','c','A','B','C'&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt; haystack (mychars,mychars+6);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle[] = &#123;'A','B','C'&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(), needle, needle+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(),</span></span><br><span class="line"><span class="comment">						  needle, needle+3, comp_case_insensitive);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first match is: A</span></span><br><span class="line"><span class="comment">	The first match is: a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">// Search [first2, last2) as a subsequence in [first1, last1), and return</span></span><br><span class="line"><span class="comment">// the *last* possible match.  Note that find_end for bidirectional iterators</span></span><br><span class="line"><span class="comment">// is much faster than for forward iterators.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for forward iterators. </span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为正向迭代器forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)<span class="comment">//若第二个区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last1;<span class="comment">//则直接返回第一个区间的尾端</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//以下利用search函数查找出某个子序列的首次出现点；若找不到直接返回last1</span></span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line"></span><br><span class="line">        = search(__first1, __last1, __first2, __last2);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)<span class="comment">//若返回的位置为尾端，则表示没找到</span></span><br><span class="line">        <span class="keyword">return</span> __result;<span class="comment">//返回last1</span></span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//若在[first1,last1)中找到[first2,last2)首次出现的位置，继续准备下一次查找</span></span><br><span class="line">		  </span><br><span class="line">        __result = __new_result;<span class="comment">//更新返回的位置</span></span><br><span class="line">        __first1 = __new_result;<span class="comment">//更新查找的起始位置</span></span><br><span class="line">        ++__first1;<span class="comment">//确定正确查找起始位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line">        = search(__first1, __last1, __first2, __last2, __comp);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __result = __new_result;</span><br><span class="line">        __first1 = __new_result;</span><br><span class="line">        ++__first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for bidirectional iterators.  Requires partial specialization.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为双向迭代器bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="comment">//利用反向迭代器很快就可以找到</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  <span class="comment">//查找时将序列一和序列二逆方向</span></span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)<span class="comment">//表示没找到</span></span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//找到了</span></span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();<span class="comment">//转会正常迭代器</span></span><br><span class="line">    advance(__result, -distance(__first2, __last2));<span class="comment">//调整回到子序列的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>, </span></span><br><span class="line"><span class="class">           _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2,</span><br><span class="line">                               __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();</span><br><span class="line">    advance(__result, -distance(__first2, __last2));</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">		  <span class="comment">// Dispatching functions for find_end.</span></span><br><span class="line"><span class="comment">//find_end函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">//注意：这里也有偏特化的知识</span></span><br><span class="line"><span class="comment">/*函数功能：Searches the range [first1,last1) for the last occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                              BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2),</span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_end函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_end</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4,5,1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; haystack (myints,myints+10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle1, needle1+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;4,5,1&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle2, needle2+3, myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	needle1 found at position 5</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/sort/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:12:55+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的sort排序算法，SGI STL中的排序算法不是简单的快速排序，而是交叉利用各种排序：堆排序、插入排序和快速排序；这样做的目的是提高效率，针对数据量比较大的采用快速排序，数据量比较小的可以采用堆排序或插入排序。本文介绍了有关排序的算法random_shuffle、partition、stable_partition、sort、stable_sort、partial_sort、partial_sort_copy、nth_element；注意：STL的sort排序算法的迭代器必须是随机访问迭代器。</p>
<h3 id="sort排序算法剖析"><a href="#sort排序算法剖析" class="headerlink" title="sort排序算法剖析"></a>sort排序算法剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a random number in the range [0, __n).  This function encapsulates</span></span><br><span class="line"><span class="comment">// whether we're using rand (part of the standard C library) or lrand48</span></span><br><span class="line"><span class="comment">// (not standard, but a much better choice whenever it's available).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Distance</span> __<span class="title">random_number</span>(_<span class="title">Distance</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">  <span class="keyword">return</span> rand() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> lrand48() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_shuffle</span></span><br><span class="line"><span class="comment">//将区间[first,last)内的元素随机重排</span></span><br><span class="line"><span class="comment">//两个版本的不同是随机数的取得</span></span><br><span class="line"><span class="comment">//版本一是使用内部随机数产生器</span></span><br><span class="line"><span class="comment">//版本二是使用一个会产生随机数的仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) randomly.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">generator by default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">specific generator (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last,</span></span><br><span class="line"><span class="comment">                       RandomNumberGenerator&amp; gen);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __random_number((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __rand((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_sample and random_sample_n (extensions, not part of the standard).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__random_number(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__rand(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first) </span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __random_number(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first)</span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __rand(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __rand,</span><br><span class="line">                         __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition, stable_partition, and their auxiliary functions</span></span><br><span class="line"><span class="comment">//若迭代器的类型为forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">		         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			 _<span class="title">Predicate</span>   __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			 <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;<span class="comment">//若为空，直接退出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__pred(*__first))<span class="comment">//若pred出first的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (++__first == __last) <span class="keyword">return</span> __first;<span class="comment">//先移动迭代器first，在判断是否到达尾端last</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//继续判断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++__next != __last)<span class="comment">//若下一个位置依然不是尾端</span></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__next)) &#123;<span class="comment">//继续pred出next的值，若为true</span></span><br><span class="line">      swap(*__first, *__next);<span class="comment">//交换值</span></span><br><span class="line">      ++__first;<span class="comment">//继续下一位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若迭代器的类型为bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter</span> __<span class="title">partition</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			       _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			       <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//若为空</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//直接退出</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (__pred(*__first))<span class="comment">//first的值符合不移动条件，则不移动该值</span></span><br><span class="line">        ++__first;<span class="comment">//只移动迭代器</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//若头指针符合移动</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    --__last;<span class="comment">//尾指针回溯</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//头指针等于尾指针</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//操作结束</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!__pred(*__last))<span class="comment">//尾指针的元素符合不移动操作</span></span><br><span class="line">        --__last;<span class="comment">//至移动迭代器，并不移动具体元素</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//尾指针的元素符合移动操作</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//头尾指针交换元素</span></span><br><span class="line">    ++__first;<span class="comment">//准备下一次循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将区间[first,last)的元素进行排序，被pred判断为true的放在区间的前段，判定为false的放在区间后段</span></span><br><span class="line"><span class="comment">//该算算可能会使元素的元素位置放生改变.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法功能：Rearranges the elements from the range [first,last), in such a way that all the elements</span></span><br><span class="line"><span class="comment">for which pred returns true precede all those for which it returns false. </span></span><br><span class="line"><span class="comment">The iterator returned points to the first element of the second group.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法原型：</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	BidirectionalIterator partition (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                                   BidirectionalIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">   			      _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			      _<span class="title">Predicate</span>   __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出迭代器first的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partition函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::partition</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return (i%2)==1; &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // set some values:</span></span><br><span class="line"><span class="comment">	  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator bound;</span></span><br><span class="line"><span class="comment">	  bound = std::partition (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // print out content:</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "odd elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "even elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	odd elements: 1 9 3 7 5</span></span><br><span class="line"><span class="comment">	even elements: 6 4 8 2</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">inplace_stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __pred(*__first) ? __last : __first;</span><br><span class="line">  _ForwardIter __middle = __first;</span><br><span class="line">  advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> rotate(__inplace_stable_partition(__first, __middle, __pred, </span><br><span class="line">                                           __len / <span class="number">2</span>),</span><br><span class="line">                __middle,</span><br><span class="line">                __inplace_stable_partition(__middle, __last, __pred,</span><br><span class="line">                                           __len - __len / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Predicate</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">stable_partition_adaptive</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Distance</span> __<span class="title">buffer_size</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len &lt;= __buffer_size) &#123;</span><br><span class="line">    _ForwardIter __result1 = __first;</span><br><span class="line">    _Pointer __result2 = __buffer;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last ; ++__first)</span><br><span class="line">      <span class="keyword">if</span> (__pred(*__first)) &#123;</span><br><span class="line">        *__result1 = *__first;</span><br><span class="line">        ++__result1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__result2 = *__first;</span><br><span class="line">        ++__result2;</span><br><span class="line">      &#125;</span><br><span class="line">    copy(__buffer, __result2, __result1);</span><br><span class="line">    <span class="keyword">return</span> __result1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter __middle = __first;</span><br><span class="line">    advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rotate(__stable_partition_adaptive(</span><br><span class="line">                          __first, __middle, __pred,</span><br><span class="line">                          __len / <span class="number">2</span>, __buffer, __buffer_size),</span><br><span class="line">                    __middle,</span><br><span class="line">                    __stable_partition_adaptive(</span><br><span class="line">                          __middle, __last, __pred,</span><br><span class="line">                          __len - __len / <span class="number">2</span>, __buffer, __buffer_size));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">stable_partition_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_ForwardIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.size() &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __stable_partition_adaptive(__first, __last, __pred,</span><br><span class="line">                                       _Distance(__buf.requested_size()),</span><br><span class="line">                                       __buf.begin(), __buf.size());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __inplace_stable_partition(__first, __last, __pred, </span><br><span class="line">                                      _Distance(__buf.requested_size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                     _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __stable_partition_aux(__first, __last, __pred,</span><br><span class="line">                                  __VALUE_TYPE(__first),</span><br><span class="line">                                  __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出快速排序的枢纽位置</span></span><br><span class="line"><span class="comment">//版本一采用operator&lt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//找出枢纽轴的位置</span></span><br><span class="line">	<span class="comment">//令头端迭代器向尾端方向移动，尾端迭代器向头端移动。</span></span><br><span class="line">	<span class="comment">//当*first不小于枢纽值时，就停下来，当*last不大于枢纽值时也停下来，然后检测两个迭代器是否交错</span></span><br><span class="line">	<span class="comment">//如果first仍然在左侧而last仍然在右侧，就交换两个元素，然后各自调整位置，向中央逼近，再继续执行相同的行为.</span></span><br><span class="line">	<span class="comment">//直到first和last两个迭代器交错，此时表示已找到枢纽轴位置即first所在的位置</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;<span class="comment">//first向尾端移动，直到遇到不小于枢纽值时，停止</span></span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;<span class="comment">//last向头端移动，直到遇到不大于枢纽值时，停止</span></span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))<span class="comment">//检测两个迭代器是否交错</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//交错，则此时已找到，即为first迭代器所指位置</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//否则交换迭代器所指的元素</span></span><br><span class="line">    ++__first;<span class="comment">//继续执行相同行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//版本一采用__comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__comp(*__first, __pivot))</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    iter_swap(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort() and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;</span><br><span class="line">  <span class="comment">//__insertion_sort的内循环</span></span><br><span class="line">  <span class="comment">//注意：一旦不再出现逆转对，循环就结束</span></span><br><span class="line">  <span class="keyword">while</span> (__val &lt; *__next) &#123;<span class="comment">//存在逆转对</span></span><br><span class="line">    *__last = *__next;<span class="comment">//调整元素</span></span><br><span class="line">    __last = __next;<span class="comment">//调整迭代器</span></span><br><span class="line">    --__next;<span class="comment">//左移一个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;<span class="comment">//value的正确插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>, </span></span><br><span class="line"><span class="class">                               _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;  </span><br><span class="line">  <span class="keyword">while</span> (__comp(__val, *__next)) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __val = *__last;<span class="comment">//记录尾元素</span></span><br><span class="line">  <span class="keyword">if</span> (__val &lt; *__first) &#123;<span class="comment">//尾元素比头元素还小</span></span><br><span class="line">	  <span class="comment">//将整个区间向右移一个位置</span></span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;<span class="comment">//令头元素等于原先的尾元素</span></span><br><span class="line">	<span class="comment">//以上两行命令的功能相等于交换两个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//尾元素不小于头元素</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Tp __val = *__last;</span><br><span class="line">  <span class="keyword">if</span> (__comp(__val, *__first)) &#123;</span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort以双层循环形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；</span></span><br><span class="line"><span class="comment">//内循环遍历子区间，将子区间内的每一个“逆转对”倒转过来，如果一旦不存在“逆转对”，表示排序完毕。</span></span><br><span class="line"><span class="comment">//“逆转对”概念：指任何两个迭代器i和j，i&lt;j,而*i&gt;*j.</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>; <span class="comment">//若区间为空，则退出</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)<span class="comment">//外循环，遍历整个区间</span></span><br><span class="line">	  <span class="comment">//[first,i)形成的子空间</span></span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                    _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                       _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first),</span><br><span class="line">                                 __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//判断元素个数是否大于16</span></span><br><span class="line">	  <span class="comment">//则把区间分割成两段，一端长度为16，另一端为剩余的长度</span></span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若不大于16，直接调用插入排序</span></span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold, __comp);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line"><span class="comment">//该函数找出2^k &lt;= n 的最大值k;</span></span><br><span class="line"><span class="comment">//例如：n=7,得k=2; n=20,得k=4; n=8,得k=3; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Size</span> __<span class="title">lg</span>(_<span class="title">Size</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line">  _Size __k;</span><br><span class="line">  <span class="keyword">for</span> (__k = <span class="number">0</span>; __n != <span class="number">1</span>; __n &gt;&gt;= <span class="number">1</span>) ++__k;</span><br><span class="line">  <span class="keyword">return</span> __k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="comment">//参数__depth_limit表示最大的分割层数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//__stl_threshold为全局常量，其值为16</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//若区间长度大于16</span></span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;<span class="comment">//表示分割恶化</span></span><br><span class="line">      partial_sort(__first, __last, __last);<span class="comment">//转而调用堆排序heap_sort()</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">	<span class="comment">//计算分割点cut，枢纽值是采用首、尾、中央三个的中间值</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">	<span class="comment">//对右半部分递归地进行排序</span></span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">    __last = __cut;<span class="comment">//接下来对左半部分递归地进行排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      partial_sort(__first, __last, __last, __comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>), __comp)),</span><br><span class="line">       __comp);</span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit, __comp);</span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SGI STL的排序算法，迭代器参数的类型必须是随机访问迭代器_RandomAccessIter</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Sorts the elements in the range [first,last) into ascending order.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用默认的operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//进行插入排序</span></span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                 _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">                     __comp);</span><br><span class="line">    __final_insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stable_sort() and its auxiliary functions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle);</span><br><span class="line">  __inplace_stable_sort(__middle, __last);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle, __comp);</span><br><span class="line">  __inplace_stable_sort(__middle, __last, __comp);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle,</span><br><span class="line">                         __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line">  merge(__first, __first + __step_size, __first + __step_size, __last,</span><br><span class="line">        __result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result,</span><br><span class="line">                     __comp);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line"></span><br><span class="line">  merge(__first, __first + __step_size,</span><br><span class="line">        __first + __step_size, __last,</span><br><span class="line">        __result,</span><br><span class="line">        __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_chunk_size = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Distance</span> __<span class="title">chunk_size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">chunk_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size, __comp);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Distance</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size, __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size,</span><br><span class="line">                   __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last, __comp);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()),</span><br><span class="line">                           __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first), </span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial_sort, partial_sort_copy, and auxiliary functions.</span></span><br><span class="line"><span class="comment">//重新安排序列[first,last)，使序列前半部分middle-first个最小元素以递增顺序排序，并将其置于[first,middle)</span></span><br><span class="line"><span class="comment">//其余last-middle个元素不指定任何排序，并将其置于[middle,last)</span></span><br><span class="line"><span class="comment">//注意：迭代器middle是在[first,last)范围之内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the elements before middle are the smallest elements in the entire range </span></span><br><span class="line"><span class="comment">and are sorted in ascending order, while the remaining elements are left without any specific order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	版本一 operator&lt; </span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2) 版本二 comp	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">		<span class="comment">//利用heap的知识，在SGI STL中，是采用最大堆</span></span><br><span class="line">		<span class="comment">//将[first,middle)区间的元素创建成最大堆</span></span><br><span class="line">		<span class="comment">//再根据最大堆的性质，一个一个弹出堆，并将其保存，即堆排序</span></span><br><span class="line">  make_heap(__first, __middle);<span class="comment">//创建最大堆，定义与&lt;stl_heap.h&gt;文件</span></span><br><span class="line">  <span class="comment">//以下是在区间中[first,last)找出middle-first个最小元素</span></span><br><span class="line">  <span class="comment">//这里的是将后半部分[middle,last)的元素依次与最大堆的根节点元素(即堆的最大元素)比较</span></span><br><span class="line">  <span class="comment">//若小于堆的最大元素，则与堆的最大元素交换，并调整堆，使其依次成为最大堆</span></span><br><span class="line">  <span class="comment">//若不小于堆的最大元素，则不作任何操作</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle);<span class="comment">//对最大堆进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  make_heap(__first, __middle, __comp);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__first))</span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partial_sort_copy与partial_sort的实现机制是相同，只是partial_sort_copy将元素排序后放在以result起始的容器中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, </span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first &lt; *__result_first) </span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first));</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last, </span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first, *__result_first))</span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first),</span><br><span class="line">                    __comp);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);  </span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last,</span><br><span class="line">                             __comp,</span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nth_element() and its auxiliary functions.  </span></span><br><span class="line"><span class="comment">//nth_element版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;<span class="comment">//区间长度大于3</span></span><br><span class="line">	  <span class="comment">//获取分割点cut</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)<span class="comment">//若分割点小于指定位置，则nth位置在右半段</span></span><br><span class="line">      __first = __cut;<span class="comment">//再对右半段进行分割</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则，对左半段进行分割</span></span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新排序序列[first,last)，使迭代器nth所指的元素，与“整个[first,last)序列完整排序后，同一位置的元素”同值.</span></span><br><span class="line"><span class="comment">//此外，必须保证[nth,last)内的所有元素不小于[first,nth)内的元素，但是对于序列[first,nth)和序列[nth,last)内的元素的排序顺序不能确定.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the element at the nth position is the element that would be in that position in a sorted sequence.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//nth_element版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>), </span><br><span class="line">                                         *(__last - <span class="number">1</span>),</span><br><span class="line">                                         __comp)),</span><br><span class="line">                            __comp);</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)</span><br><span class="line">      __first = __cut;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_sorted, a predicated testing whether a range is sorted in</span></span><br><span class="line"><span class="comment">// nondescending order.  This is an extension, not part of the C++</span></span><br><span class="line"><span class="comment">// standard.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__next &lt; *__first)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">StrictWeakOrdering</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">               _<span class="title">StrictWeakOrdering</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__next, *__first))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Set和Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Set和Map/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:10:50+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇博客中，讲到了STL中关于红黑树的实现，理解起来比较复杂，正所谓前人种树，后人乘凉，RBTree把树都种好了，接下来就该set和map这类关联式容器来“乘凉”了。</p>
<p>STL的set和map都是基于红黑树实现的，和stack和queue都是基于deque一样，它们仅仅是调用了RBTree提供的接口函数，然后进行外层封装即可。本篇博客理解起来比较轻松，set和map的源代码也不多，大家可以慢慢“品味”。另外，还会介绍multiset和multimap这两个容器，并给出它们的区别和应用等。还等什么呢？走吧，带你理解理解set和map吧！</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set是一种关联式容器，其特性如下：</p>
<ul>
<li>set以RBTree作为底层容器</li>
<li>所得元素的只有key没有value，value就是key</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
<li>不能通过迭代器来改变set的值，因为set的值就是键</li>
</ul>
<p>针对这五点来说，前四点都不用再多作说明，第五点需要做一下说明。如果set中允许修改键值的话，那么首先需要删除该键，然后调节平衡，在插入修改后的键值，再调节平衡，如此一来，严重破坏了set的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值。</p>
<h2 id="set的数据结构"><a href="#set的数据结构" class="headerlink" title="set的数据结构"></a>set的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器默认采用less，内部按照升序排列，配置器默认采用alloc</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//  在set中key就是value, value同时也是key</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Key value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于比较的函数</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;	<span class="comment">// t为内部RBTree容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 设置成const迭代器，set的键值不允许修改</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line">  <span class="comment">// 由于set的性质, value比较和key使用同一个比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明了两个友元函数，重载了==和&lt;操作符</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的构造函数"><a href="#set的构造函数" class="headerlink" title="set的构造函数"></a>set的构造函数</h2><p>set提供了如下几个构造函数用于初始化一个set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：下面相关函数都在set类中定义，为了介绍方便才抽出来单独讲解</span></span><br><span class="line"><span class="comment">// 空构造函数，初始化一个空的set</span></span><br><span class="line"><span class="built_in">set</span>() : t(Compare()) &#123;&#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器，如set&lt;int,greater&lt;int&gt; &gt; myset的初始化</span></span><br><span class="line">explicit set(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 实现诸如set&lt;int&gt; myset(anotherset.begin(),anotherset.end())这样的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">:</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器的初始化操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">:</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 以另一个set来初始化</span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line"><span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	t = x.t;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的操作函数"><a href="#set的操作函数" class="headerlink" title="set的操作函数"></a>set的操作函数</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>插入函数，调用RBTree的插入函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  pair&lt;iterator, <span class="keyword">bool</span>&gt; pair_iterator_bool;</span><br><span class="line"><span class="comment">// 由于set不允许键值重复，所以必须调用RBTree的insert_unique函数</span></span><br><span class="line"><span class="comment">// second表示插入操作是否成功</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="keyword">bool</span>&gt; p = t.insert_unique(x);</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到set中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>擦除函数，用于擦除单个元素或者区间内的元素，直接调用RBTree的函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识set内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.erase(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除指定区间的元素, 会导致红黑树有较大变化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除整个set容器，直接调用RBTree的clean函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找函数，RBTree也提供了，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>查找制定元素的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定元素的个数, set不允许键值重复，其实就是测试元素是否在set中</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.count(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>set重载了==和&lt;操作符，基本上都是调用RBTree的接口函数即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">x</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const set&lt;Key, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const set&lt;Key, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数"><a href="#其他操作函数" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>multiset相对于set来说，区别就是multiset允许键值重复，在multiset中调用的是RBTree的insert_equal函数，其他的基本与set相同。</p>
<p>其他的就不赘述了，下面列举一下跟set不同的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数，</span></span><br><span class="line"><span class="comment">// 注意！！！！插入操作采用的是RBTree的insert_equal，而不是insert_unique</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下：</p>
<ul>
<li>map以RBTree作为底层容器</li>
<li>所有元素都是键+值存在</li>
<li>不允许键重复</li>
<li>所有元素是通过键进行自动排序的</li>
<li>map的键是不能修改的，但是其键对应的值是可以修改的</li>
</ul>
<p>在map中，一个键对应一个值，其中键不允许重复，不允许修改，但是键对应的值是可以修改的，原因可以看上面set中的解释。下面就一起来看看STL中的map的源代码。</p>
<h2 id="map的数据结构"><a href="#map的数据结构" class="headerlink" title="map的数据结构"></a>map的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认比较器为less&lt;key&gt;,元素按照键的大小升序排列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;                         <span class="comment">// key类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T data_type;                          <span class="comment">// value类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;        <span class="comment">// 元素类型, 要保证key不被修改</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;                  <span class="comment">// 用于key比较的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t; <span class="comment">// t为内部RBTree容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 注意：这里与set不一样，map的迭代器是可以修改的</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规的返回迭代器函数</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于map的性质, value和key使用同一个比较函数, 实际上我们并不使用value比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value_compare(t.key_comp()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意: 这里有一个常见的陷阱, 如果访问的key不存在, 会新建立一个</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (*((insert(value_type(k, T()))).first)).second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重载了==和&lt;操作符，后面会有实现</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的构造函数"><a href="#map的构造函数" class="headerlink" title="map的构造函数"></a>map的构造函数</h2><p>map提供了一下的构造函数来初始化一个map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造函数，直接调用RBTree的空构造函数</span></span><br><span class="line"><span class="built_in">map</span>() : t(Compare()) &#123;&#125;</span><br><span class="line">explicit map(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end())的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end(),less&lt;int&gt;)初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int&gt; maMap(anotherMap)的初始化</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 重载=操作符，赋值运算符</span></span><br><span class="line"><span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  t = x.t;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的操作函数"><a href="#map的操作函数" class="headerlink" title="map的操作函数"></a>map的操作函数</h2><h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>同set一样，直接调用RBTree的插入函数即可，注意map不允许键值重复，所以调用的是insert_unique</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于相同的key, 只允许出现一次, bool标识</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x) &#123; <span class="keyword">return</span> t.insert_unique(x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处</span></span><br><span class="line">插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique(position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到map中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase-1"><a href="#erase-1" class="headerlink" title="erase"></a>erase</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.erase(position); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识map内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.erase(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.erase(first, last); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean-1"><a href="#clean-1" class="headerlink" title="clean"></a>clean</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定key的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">````</span><br><span class="line">### 重载运算符</span><br><span class="line">上面介绍到<span class="built_in">map</span>重载了[],==和&lt;运算符，[]的实现已经介绍过，下面是==和&lt;的实现</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 比较map直接是对其底层容器t的比较，直接调用RBTree的比较函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;class Key, class T, class Compare, class Alloc&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const map&lt;Key, T, Compare, Alloc&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数-1"><a href="#其他操作函数-1" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.lower_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.upper_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>multimap和map的关系就跟multiset和set的关系一样，multimap允许键的值相同，因此在插入操作的时候用到insert_equal()，除此之外，基本上与map相同。</p>
<p>下面就仅仅列出不同的地方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// ... 其他地方与map相同</span></span><br><span class="line">  <span class="comment">// 注意下面这些函数都调用的是insert_equal，而不是insert_unique</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">    :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">    :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.insert_equal(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line">  <span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.insert_equal(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入一个区间内的元素</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    t.insert_equal(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其余地方和map相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这四类容器仅仅只是在RBTree上进行了一层封装，首先，set和map的区别就在于键和值是否相同，set中将值作为键，支持STL的提供的一些交集、并集和差集等运算；map的键和值不同，每个键都有自己的值，键不能重复，但是值可以重复。</p>
<p>multimap和multiset就在map和set的基础上，使他们的键可以重复，除此之外基本等同。</p>
<p>关于map和set的用法，大家可以在其源代码中找到，这里就不在赘述，本系列博客也是基于源码的角度来分析这些容器。到此，end！</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/RB-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/RB-tree/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:09:42+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>红黑树是平衡二叉搜索树的一种，其通过特定的操作来保持二叉查找树的平衡。首先，我们来复习一下二叉查找树的知识，建议如果对二叉查找树不理解的先去搜一下相关博客来了解一下。</p>
<p>二叉搜索树是指一个空树或者具有以下性质的二叉树：</p>
<ul>
<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点</li>
</ul>
<p>我们知道，一颗由n个节点随机构造的二叉搜索树的高度为logn，但是，由于输入值往往不够随机，导致二叉搜索树可能失去平衡，造成搜索效率低下的情况。从而，引出了平衡二叉搜索树的概念。对于“平衡”这个约束不同的结构有不同的规定，如AVL树要求任何节点的两个子树的高度最大差别为1，可谓是高度平衡啊；而红黑树仅仅确保没有一条路径会比其他路径长出两倍，因而达到接近平衡的目的。红黑数不仅是一个平衡二叉搜索树，而且还定义了相当多的约束来确保插入和删除等操作后能达到平衡。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyj3b8rj30k607xdg6.jpg" alt="balancedTree"></p>
<p>那么，红黑树究竟是怎么定义，来使得能够达到平衡的目的呢？我们接着看下去。</p>
<h1 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h1><p>红黑树既然属于二叉搜索树的一种，当然需要满足上述二叉搜索树的性质，除此之外，红黑树还为每一个节点增加了一个存储位来表示节点的颜色属性，它可以为red或者black，通过对任何一条从根到叶子节点的路径上每个点进行着色方式的限制，来确保没有一条路径会比其他路径长出两倍，因而达到接近平衡的目的。</p>
<p>那么，红黑树是如何进行着色的呢？下面引出了红黑树的五条性质：</p>
<ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>正是这五条性质，使得红黑树的高度能保持在logn，从而达到平衡的目的，进而使得其在查找、插入和删除的时间复杂度最坏为O(logn)，下面就是一棵典型的红黑树。</p>
<p><img src="http://obd5s81mp.bkt.clouddn.com/STLRbtree.png" alt="红黑树"></p>
<blockquote>
<p>注: 因本人能力有限可能无法将红黑树讲得很清楚全面，而且STL红黑树的实现也较为复杂，建议先到下面推荐的几篇博客里去补补知识</p>
<ul>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">教你初步了解红黑树</a></li>
<li><a href="http://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">【数据结构和算法05】 红-黑树（看完包懂~）</a></li>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6124989" target="_blank" rel="noopener">一步一图一代码，一定要让你真正彻底明白红黑树</a></li>
</ul>
</blockquote>
<h1 id="红黑树的节点结构"><a href="#红黑树的节点结构" class="headerlink" title="红黑树的节点结构"></a>红黑树的节点结构</h1><p>红黑树的节点在二叉树的节点结构上增加了颜色属性，而且，为了更好的进行插入和删除操作，进而增加了指向父节点的指针。为了更好的弹性，STL红黑树的节点采用双层设计，将不依赖模板的参数提取出来，作为base结构，然后用带模板的节点结构取继承它。下面是红黑树节点结构的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;  <span class="comment">// 紅色為 0</span></span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色為 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;	<span class="comment">// 节点颜色</span></span><br><span class="line">  base_ptr parent;	<span class="comment">// 指向父节点</span></span><br><span class="line">  base_ptr left;		<span class="comment">// 指向左子节点</span></span><br><span class="line">  base_ptr right;		<span class="comment">// 指向右子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一直往左走，就能找到红黑树的最小值节点</span></span><br><span class="line">  <span class="comment">// 二叉搜索树的性质</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一直往右走，就能找到红黑树的最大值节点</span></span><br><span class="line">  <span class="comment">// 二叉搜索树的性质</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的节点定义，采用双层节点结构</span></span><br><span class="line"><span class="comment">// 基类中不包含模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	Value value_field;    <span class="comment">// 節點實值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的迭代器"><a href="#红黑树的迭代器" class="headerlink" title="红黑树的迭代器"></a>红黑树的迭代器</h1><p>为了将RBtree实现为一个泛型容器，迭代器的设计很关键。我们要考虑它的型别，以及前进(increment)、后退(devrement)、提领(dereference)和成员访问(member access)等操作。</p>
<p>迭代器和节点一样，采用双层设计，STL红黑树的节点<strong>rb_tree_node继承于</strong>rb_tree_node_base；STL的迭代器结构<strong>rb_tree_iterator继承于</strong>rb_tree_base_iterator，我们可以用一张图来解释这样的设计目的。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyhi8o9j30me0cdabl.jpg" alt="STLRbTreeNodeAndIterator"></p>
<p>将这些分开设计，可以保证对节点和迭代器的操作更具有弹性。下面来看迭代器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  base_ptr node;	<span class="comment">// 用来连接红黑树的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找该节点的后继节点上</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;	<span class="comment">// 如果存在右子节点</span></span><br><span class="line">      node = node-&gt;right;		<span class="comment">// 直接跳到右子节点上</span></span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>) <span class="comment">// 然后一直往左子树走，直到左子树为空</span></span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                    <span class="comment">// 没有右子节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;    <span class="comment">// 找出父节点</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;    <span class="comment">// 如果该节点一直为它的父节点的右子节点</span></span><br><span class="line">        node = y;                		<span class="comment">// 就一直往上找，直到不为右子节点为止</span></span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)      <span class="comment">// 若此时该节点不为它的父节点的右子节点</span></span><br><span class="line">        node = y;                <span class="comment">// 此时的父节点即为要找的后继节点</span></span><br><span class="line">                                 <span class="comment">// 否则此时的node即为要找的后继节点，此为特殊情况，如下</span></span><br><span class="line">                                 <span class="comment">// 我们要寻找根节点的下一个节点，而根节点没有右子节点</span></span><br><span class="line">                                 <span class="comment">// 此种情况需要配合rbtree的header节点的特殊设计，后面会讲到</span></span><br><span class="line">    &#125;                        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找该节点你的前置节点</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; <span class="comment">// 如果此节点是红节点</span></span><br><span class="line">        node-&gt;parent-&gt;parent == node)		<span class="comment">// 且父节点的父节点等于自己</span></span><br><span class="line">      node = node-&gt;right;								<span class="comment">// 则其右子节点即为其前置节点</span></span><br><span class="line">    <span class="comment">// 以上情况发生在node为header时，即node为end()时</span></span><br><span class="line">    <span class="comment">// 注意：header的右子节点为mostright，指向整棵树的max节点，后面会有解释</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;					<span class="comment">// 如果存在左子节点</span></span><br><span class="line">      base_ptr y = node-&gt;left;					<span class="comment">// 跳到左子节点上</span></span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)							<span class="comment">// 然后一直往右找，知道右子树为空</span></span><br><span class="line">        y = y-&gt;right;			</span><br><span class="line">      node = y;													<span class="comment">// 则找到前置节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;															<span class="comment">// 如果该节点不存在左子节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;				<span class="comment">// 跳到它的父节点上</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;					<span class="comment">// 如果它等于它的父子节点的左子节点</span></span><br><span class="line">        node = y;												<span class="comment">// 则一直往上查找</span></span><br><span class="line">        y = y-&gt;parent;									</span><br><span class="line">      &#125;																	<span class="comment">// 直到它不为父节点的左子节点未知</span></span><br><span class="line">      node = y;													<span class="comment">// 此时他的父节点即为要找的前置节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_iterator</span> :</span> <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配合迭代器萃取机制的一些声明</span></span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;     iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> Value&amp;, <span class="keyword">const</span> Value*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;   self;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  <span class="comment">// 迭代器的构造函数</span></span><br><span class="line">  __rb_tree_iterator() &#123;&#125;</span><br><span class="line">  __rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">  __rb_tree_iterator(<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line">  <span class="comment">// 提领和成员访问函数，重载了*和-&gt;操作符</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> link_type(node)-&gt;value_field; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">  <span class="comment">// 前置++和后置++</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    increment();		<span class="comment">// 直接调用increment函数</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前置--和后置--</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    decrement();		<span class="comment">// 直接调用decrement函数</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述源代码中，一直提到STL RBTree特殊节点header的设计，这个会在RBTree结构中讲到，下面跟着我一起继续往下看吧。</p>
<h1 id="红黑树的数据结构"><a href="#红黑树的数据结构" class="headerlink" title="红黑树的数据结构"></a>红黑树的数据结构</h1><p>有了上面的节点和迭代器设计，就能很好的定义出一颗RBTree了。废话不多说，一步一步来剖析源代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;		</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator; <span class="comment">// 专属配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 一些类型声明</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// RB-tree的数据结构</span></span><br><span class="line">  size_type node_count; <span class="comment">// 记录树的节点个数</span></span><br><span class="line">  link_type header;  		<span class="comment">// header节点设计</span></span><br><span class="line">  Compare key_compare;	<span class="comment">// 节点间的键值大小比较准则</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下三个函数用来取得header的成员</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下六个函数用来取得节点的成员</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(x)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下六个函数用来取得节点的成员，由于双层设计，导致这里需要两个定义</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(link_type(x)));&#125; </span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(link_type(x)-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求取极大值和极小值，这里直接调用节点结构的函数极可</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (link_type)  __rb_tree_node_base::minimum(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type) __rb_tree_node_base::maximum(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// RBTree的迭代器定义</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt; </span><br><span class="line">          const_iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;	<span class="comment">// 由于红黑树自带排序功能，所以必须传入一个比较器函数</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;        <span class="comment">// RBTree的起始节点为左边最小值节点</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;							<span class="comment">// RBTree的终止节点为右边最大值节点</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;	<span class="comment">// 判断红黑树是否为空	</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;		<span class="comment">// 获取红黑树的节点个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;	<span class="comment">// 获取红黑树的最大节点个数，</span></span><br><span class="line">																												<span class="comment">// 没有容量的概念，故为sizetype最大值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到，在RBTree的数据结构中，定义了RBTree节点和迭代器，然后添加了header节点，以及node_count参数，其他都是一下简单的函数声明和类型声明。除此之外，并没有过多的增加东西。这里理解起来还是比较简单，至于header有什么作用，请继续往下看。</p>
<h1 id="红黑树的构造与内存管理"><a href="#红黑树的构造与内存管理" class="headerlink" title="红黑树的构造与内存管理"></a>红黑树的构造与内存管理</h1><h2 id="红黑树的构造函数"><a href="#红黑树的构造函数" class="headerlink" title="红黑树的构造函数"></a>红黑树的构造函数</h2><p>红黑树的空构造函数将创建一个空树，此”空树“非彼二叉树的空树也。空构造函数首先配置一个节点空间，使header指向该节点空间，然后将header的leftmost和rightmost指向自己，父节点指向0。非空的STL RBTree中，header和root之间互为父节点，然后header的leftmost始终指向该树的最小值节点，rightmost始终指向该树的最大值节点，其示例图如下（左图为空树，右图为非空树）：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfynyzckj30ha0acdgd.jpg" alt="STLRBTreeInit"></p>
<p>下面来看看它的构造函数代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	<span class="comment">// 这部分代码是从红黑树的结构定义中提取出来的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator; <span class="comment">// 专属配置器</span></span><br><span class="line"></span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::allocate(); &#125; <span class="comment">// 配置空间</span></span><br><span class="line"></span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    link_type tmp = get_node();            <span class="comment">// 配置空間</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      construct(&amp;tmp-&gt;value_field, x);    <span class="comment">// 构造内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(put_node(tmp));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化函数，用来初始化一棵RBTree</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = get_node();    <span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">    color(header) = __rb_tree_red; <span class="comment">// 令header为红色，用来区分header和root</span></span><br><span class="line">    root() = <span class="number">0</span>;</span><br><span class="line">    leftmost() = header;    <span class="comment">// 令header的左子节点为其自己</span></span><br><span class="line">    rightmost() = header;    <span class="comment">// 令header的右子节点为其自己</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 真正的默认构造函数</span></span><br><span class="line">  rb_tree(<span class="keyword">const</span> Compare&amp; comp = Compare())</span><br><span class="line">  : node_count(<span class="number">0</span>), key_compare(comp) &#123; init(); &#125;	<span class="comment">// 直接调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带参构造函数，以另一棵RBTree为初值来初始化</span></span><br><span class="line">  rb_tree(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) </span><br><span class="line">    : node_count(<span class="number">0</span>), key_compare(x.key_compare)</span><br><span class="line">  &#123; </span><br><span class="line">    header = get_node();    <span class="comment">// 產生一個節點空間，令 header 指向它</span></span><br><span class="line">    color(header) = __rb_tree_red;    <span class="comment">// 令 header 為紅色</span></span><br><span class="line">    <span class="keyword">if</span> (x.root() == <span class="number">0</span>) &#123;    <span class="comment">//  如果 x 是個空白樹</span></span><br><span class="line">      root() = <span class="number">0</span>;</span><br><span class="line">      leftmost() = header;     <span class="comment">// 令 header 的左子節點為自己。</span></span><br><span class="line">      rightmost() = header; <span class="comment">// 令 header 的右子節點為自己。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">//  x 不是一個空白樹</span></span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        root() = __copy(x.root(), header);        <span class="comment">//调用copy函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      __STL_UNWIND(put_node(header));</span><br><span class="line">      leftmost() = minimum(root());    <span class="comment">// 令 header 的左子節點為最小節點</span></span><br><span class="line">      rightmost() = maximum(root());    <span class="comment">// 令 header 的右子節點為最大節點</span></span><br><span class="line">    &#125;</span><br><span class="line">    node_count = x.node_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// copy函数定义如下</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">typename</span> <span class="title">rb_tree</span>&lt;K, V, KeyOfValue, Compare, Alloc&gt;:</span>:link_type </span><br><span class="line">	rb_tree&lt;K, V, KeyOfValue, Compare, Alloc&gt;::__copy(link_type x, link_type p) &#123;</span><br><span class="line">	  link_type top = clone_node(x); <span class="comment">// 克隆root节点</span></span><br><span class="line">	  top-&gt;parent = p;	<span class="comment">// 将root节点父节点指向p</span></span><br><span class="line">	 	<span class="comment">// 以下为非递归的二叉树复制过程</span></span><br><span class="line">	  __STL_TRY &#123;</span><br><span class="line">	    <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">	      top-&gt;right = __copy(right(x), top); <span class="comment">// 一直copy右子节点</span></span><br><span class="line">	    p = top;	</span><br><span class="line">	    x = left(x);	<span class="comment">// 取左节点</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;	<span class="comment">// 左子节点不为空</span></span><br><span class="line">	      link_type y = clone_node(x);	<span class="comment">// 克隆左子节点</span></span><br><span class="line">	      p-&gt;left = y;	<span class="comment">// p的左子节点设为y</span></span><br><span class="line">	      y-&gt;parent = p;	<span class="comment">// y的父节点设为p</span></span><br><span class="line">	      <span class="keyword">if</span> (x-&gt;right)		<span class="comment">// 如果左子节点还有右子节点，继续复制</span></span><br><span class="line">	        y-&gt;right = __copy(right(x), y);</span><br><span class="line">	      p = y;	<span class="comment">// 直到没有左子节点</span></span><br><span class="line">	      x = left(x);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  __STL_UNWIND(__erase(top));</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// clone一个节点函数</span></span><br><span class="line">  <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span> </span>&#123;    <span class="comment">// 複製一個節點（的值和色）</span></span><br><span class="line">	  link_type tmp = create_node(x-&gt;value_field);</span><br><span class="line">	  tmp-&gt;color = x-&gt;color;</span><br><span class="line">	  tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">	  tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树的析构函数"><a href="#红黑树的析构函数" class="headerlink" title="红黑树的析构函数"></a>红黑树的析构函数</h2><p>析构函数负责清除和释放红黑树上的每一个节点，并且初始化该红黑树为空树，即恢复header为初始状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	<span class="comment">// 这部分代码是从红黑树的结构定义中提取出来的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; rb_tree_node_allocator::deallocate(p); &#125;</span><br><span class="line">	<span class="comment">// 析构一个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">    destroy(&amp;p-&gt;value_field);        <span class="comment">// 析构内容</span></span><br><span class="line">    put_node(p);                    <span class="comment">// 释放空间 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~rb_tree() &#123;</span><br><span class="line">    clear();</span><br><span class="line">    put_node(header);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除整棵树并初始化header节点</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">      __erase(root());</span><br><span class="line">      <span class="comment">// 初始化Header节点</span></span><br><span class="line">      leftmost() = header;</span><br><span class="line">      root() = <span class="number">0</span>;</span><br><span class="line">      rightmost() = header;</span><br><span class="line">      node_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除RBTree的每个节点</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:__erase(link_type x) &#123;</span><br><span class="line">	  <span class="comment">// 直接清，不用调平衡</span></span><br><span class="line">	  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">	    __erase(right(x));</span><br><span class="line">	    link_type y = left(x);</span><br><span class="line">	    destroy_node(x);</span><br><span class="line">	    x = y;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h1><p>红黑树在插入节点的时候，会破坏其平衡，这时候需要旋转和变色来使红黑树重新达到平衡。这才是红黑树的精髓所在啊！所以这部分很长，大家耐心看，最好拿纸笔画一下。</p>
<h2 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h2><p>我们先来看看平衡二叉树的旋转问题。平衡二叉树中，插入一个节点后，有可能会破坏二叉树的平衡，这时候可以通过左旋和右旋函数来使其重新恢复平衡。</p>
<p>通常破坏平衡二叉树平衡的插入情况有如下四种：</p>
<ul>
<li>插入点位于X节点的左子节点的左子树，左左</li>
<li>插入点位于X节点的右子节点的右子树，右右</li>
<li>插入点位于X节点的左子节点的右子树，左右</li>
<li>插入点位于X节点的右子节点的左子树，右左</li>
</ul>
<p>其中，情况1和2彼此对称，称为外侧插入，可以采用单旋转操作来调整；情况3和4彼此对称，称为内侧插入，需要采用双旋转操作来调整。</p>
<h3 id="外侧插入"><a href="#外侧插入" class="headerlink" title="外侧插入"></a>外侧插入</h3><p>对于外侧插入，我们通常采用一次旋转就能解决问题，请看下面两种外侧插入的示意图，其中左图对应上述情况1，右图对应上述情况2。</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfykuu26j30l009baan.jpg" alt="AVLTreeOutSideInsert"></p>
<p>对于左图的情况，采用一次右旋操作，可以使二叉树重新恢复平衡，操作示意图如下所示：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfyjxqufj30li09n0t9.jpg" alt="AVLTreeRightRotate"></p>
<p>对于右图的情况，采用一次左旋操作，可以使二叉树重新恢复平衡，操作示意图如下所示：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfyr8ogqj30kt09474r.jpg" alt="AVLTreeLeftRotate"></p>
<h3 id="内侧插入"><a href="#内侧插入" class="headerlink" title="内侧插入"></a>内侧插入</h3><p>对于内侧插入，通常比较复杂，需要采用两次旋转操作来调整平衡。请看下面的内侧插入的示意图，其中左图对于上述情况3，右图对应上述情况4。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfylqfcnj30su08qwfc.jpg" alt="AVLTreeInsideInsert"></p>
<p>对于左图的情况，需要先进行依次左旋操作，再进行一次右旋操作即可调整平衡，操作示意图如下：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfylqfcnj30su08qwfc.jpg" alt="AVLTreeTwoRatate"></p>
<p>对于右图的情况，需要先进行依次右旋操作，再进行一次左旋操作即可调整平衡，操作示意图如下：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyql0n5j30sr093756.jpg" alt="AVLTreeTwoRatate2"></p>
<h2 id="红黑树的插入-1"><a href="#红黑树的插入-1" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>有了上面的单旋转和双旋转知识，应该就很好理解红黑数的平衡调整过程。红黑树在插入节点的时候，不仅需要考虑插入导致的不平衡，还要考虑颜色属性是否满足其性质要求。为了更清楚的表达整个过程，我们先来定义一下几个标示量，使用X来表示一个新插入的节点，使用P来表示新插入节点的父节点，使用U来表示P节点的兄弟节点，使用G来表示P节点的父亲节点，使用N代表NIL节点。于是，可以将插入情况分为一下几类：</p>
<h3 id="树为空"><a href="#树为空" class="headerlink" title="树为空"></a>树为空</h3><p>新插入的节点为红色，因为此时树为空，那么插入该节点后只需要把节点颜色调整为黑色即可。</p>
<h3 id="父节点为黑"><a href="#父节点为黑" class="headerlink" title="父节点为黑"></a>父节点为黑</h3><p>如果插入的节点的父节点为黑色，那么插入一个红节点将不会影响树的平衡，直接插入即可。这里就体现了黑红树的优势，O(1)时间内就能判断是否破坏了平衡，如果这里是AVL树的话就需要进行一次O(logn)判断是否平衡。</p>
<h3 id="父节点为红色"><a href="#父节点为红色" class="headerlink" title="父节点为红色"></a>父节点为红色</h3><p>当父节点为红色的时候，就不满足条件4，即父节点为红色的时候，子节点必须为黑色，而新加入的节点为红色。这个时候需要考虑如下两种情况</p>
<h4 id="1）叔父节点为红色"><a href="#1）叔父节点为红色" class="headerlink" title="1）叔父节点为红色"></a>1）叔父节点为红色</h4><p>这种情况下，需要将父节点和叔父节点变为黑色，将祖父节点变为红色即可，不过如果祖父节点为红色的话，还是违反了红黑树的性质，此时必须执行一个继续向上迭代的程序来对红黑树的颜色进行调整，最后需要将根节点设置为黑色，如下图所示：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfys6slgj30ob07kwfa.jpg" alt="RBTreeInsert1"></p>
<h4 id="2）叔父节点为黑色-Nil节点为黑"><a href="#2）叔父节点为黑色-Nil节点为黑" class="headerlink" title="2）叔父节点为黑色(Nil节点为黑)"></a>2）叔父节点为黑色(Nil节点为黑)</h4><p>这时候，需要对其进行旋转操作，和上面AVL树的旋转一样，分为4种情况，下面一一举例来说明这四种情况：</p>
<ul>
<li>左左，外侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyphkp5j30iz07a74u.jpg" alt="RBTreeInsert2"></p>
<ul>
<li>左右，内侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyi70nej30q306uaax.jpg" alt="RBTreeInsert3"></p>
<ul>
<li>右左，内侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfymw4rxj30ps07iq3t.jpg" alt="RBTreeInsert4"></p>
<ul>
<li>右右，外侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfysv1zbj30gh06zdgd.jpg" alt="RBTreeInsert5"></p>
<h2 id="红黑树的插入源代码分析"><a href="#红黑树的插入源代码分析" class="headerlink" title="红黑树的插入源代码分析"></a>红黑树的插入源代码分析</h2><p>红黑树的插入主要靠以下三个函数来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 右旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 插入后调节平衡函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 插入的核心函数</span></span><br><span class="line">iterator __insert(base_ptr x, base_ptr y, <span class="keyword">const</span> value_type&amp; v);</span><br></pre></td></tr></table></figure>

<p>上述三个函数就代表了上一小节示例图中的左旋，右旋和变色的源代码接口。</p>
<p>另外，STL还提供了两个个接口函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许出现相同的值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="comment">// 不允许出现相同的值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面就针对这五个函数一一来分析一下他们的源代码(以insert_unique为例)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此插入函数不允许重复</span></span><br><span class="line"><span class="comment">// 返回的是一个pair，第一个元素为红黑树的迭代器，指向新增节点</span></span><br><span class="line"><span class="comment">// 第二个元素表示插入操作是否成功的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span> , <span class="title">class</span> <span class="title">Value</span> , <span class="title">class</span> <span class="title">KeyOfValue</span> , <span class="title">class</span> <span class="title">Compare</span> , <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;typename rb_tree&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;::iterator , bool&gt;  </span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;:</span>:insert_unique(<span class="keyword">const</span> Value &amp;v)  </span><br><span class="line">&#123;  </span><br><span class="line">    rb_tree_node* y = header;    <span class="comment">// 根节点root的父节点  </span></span><br><span class="line">    rb_tree_node* x = root();    <span class="comment">// 从根节点开始  </span></span><br><span class="line">    <span class="keyword">bool</span> comp = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        y = x;  </span><br><span class="line">        comp = key_compare(KeyOfValue()(v) , key(x));    <span class="comment">// v键值小于目前节点之键值？  </span></span><br><span class="line">        x = comp ? left(x) : right(x);   <span class="comment">// 遇“大”则往左，遇“小于或等于”则往右  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 离开while循环之后，y所指即插入点之父节点（此时的它必为叶节点）  </span></span><br><span class="line">    iterator j = iterator(y);     <span class="comment">// 令迭代器j指向插入点之父节点y  </span></span><br><span class="line">    <span class="keyword">if</span>(comp)     <span class="comment">// 如果离开while循环时comp为真（表示遇“大”，将插入于左侧）  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(j == begin())    <span class="comment">// 如果插入点之父节点为最左节点  </span></span><br><span class="line">            <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(_insert(x , y , z) , <span class="literal">true</span>);<span class="comment">// 调用_insert函数</span></span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">// 否则（插入点之父节点不为最左节点）  </span></span><br><span class="line">            --j;   <span class="comment">// 调整j，回头准备测试  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(key_compare(key(j.node) , KeyOfValue()(v) ))  </span><br><span class="line">        <span class="comment">// 新键值不与既有节点之键值重复，于是以下执行安插操作  </span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(_insert(x , y , z) , <span class="literal">true</span>);  </span><br><span class="line">    <span class="comment">// 以上，x为新值插入点，y为插入点之父节点，v为新值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 进行至此，表示新值一定与树中键值重复，那么就不应该插入新值  </span></span><br><span class="line">    <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(j , <span class="literal">false</span>);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正地插入执行程序 _insert()  </span></span><br><span class="line"><span class="comment">// 返回新插入节点的迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span> , <span class="title">class</span> <span class="title">Value</span> , <span class="title">class</span> <span class="title">KeyOfValue</span> , <span class="title">class</span> <span class="title">Compare</span> , <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">typename</span>&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;:</span>:_insert(base_ptr x_ , base_ptr y_ , <span class="keyword">const</span> Value &amp;v)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 参数x_ 为新值插入点，参数y_为插入点之父节点，参数v为新值  </span></span><br><span class="line">    link_type x = (link_type) x_;  </span><br><span class="line">    link_type y = (link_type) y_;  </span><br><span class="line">    link_type z;  </span><br><span class="line">    <span class="comment">// key_compare 是键值大小比较准则。应该会是个function object  </span></span><br><span class="line">    <span class="keyword">if</span>(y == header || x != <span class="number">0</span> || key_compare(KeyOfValue()(v) , key(y) ))  </span><br><span class="line">    &#123;  </span><br><span class="line">        z = create_node(v);    <span class="comment">// 产生一个新节点  </span></span><br><span class="line">        left(y) = z;           <span class="comment">// 这使得当y即为header时，leftmost() = z  </span></span><br><span class="line">        <span class="keyword">if</span>(y == header)  </span><br><span class="line">        &#123;  </span><br><span class="line">            root() = z;  </span><br><span class="line">            rightmost() = z;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == leftmost())     <span class="comment">// 如果y为最左节点  </span></span><br><span class="line">            leftmost() = z;          <span class="comment">// 维护leftmost()，使它永远指向最左节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        z = create_node(v);        <span class="comment">// 产生一个新节点  </span></span><br><span class="line">        right(y) = z;              <span class="comment">// 令新节点成为插入点之父节点y的右子节点  </span></span><br><span class="line">        <span class="keyword">if</span>(y == rightmost())  </span><br><span class="line">            rightmost() = z;       <span class="comment">// 维护rightmost()，使它永远指向最右节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    parent(z) = y;      <span class="comment">// 设定新节点的父节点  </span></span><br><span class="line">    left(z) = <span class="number">0</span>;        <span class="comment">// 设定新节点的左子节点  </span></span><br><span class="line">    right(z) = <span class="number">0</span>;       <span class="comment">// 设定新节点的右子节点  </span></span><br><span class="line">    <span class="comment">// 新节点的颜色将在_rb_tree_rebalance()设定（并调整）  </span></span><br><span class="line">    _rb_tree_rebalance(z , header-&gt;parent);      <span class="comment">// 参数一为新增节点，参数二为根节点root  </span></span><br><span class="line">    ++node_count;       <span class="comment">// 节点数累加  </span></span><br><span class="line">    <span class="keyword">return</span> iterator(z);  <span class="comment">// 返回一个迭代器，指向新增节点  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数  </span></span><br><span class="line"><span class="comment">// 重新令树形平衡（改变颜色及旋转树形）  </span></span><br><span class="line"><span class="comment">// 参数一为新增节点，参数二为根节点root  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rebalance(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    x-&gt;color = _rb_tree_red;    <span class="comment">//新节点必为红  </span></span><br><span class="line">    <span class="keyword">while</span>(x != root &amp;&amp; x-&gt;parent-&gt;color == _rb_tree_red)    <span class="comment">// 父节点为红  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)      <span class="comment">// 父节点为祖父节点之左子节点  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;    <span class="comment">// 令y为伯父节点  </span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 伯父节点存在，且为红  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色  </span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色  </span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)   <span class="comment">// 如果新节点为父节点之右子节点  </span></span><br><span class="line">                &#123;  </span><br><span class="line">                    x = x-&gt;parent;  </span><br><span class="line">                    _rb_tree_rotate_left(x , root);    <span class="comment">// 第一个参数为左旋点  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;  </span><br><span class="line">                _rb_tree_rotate_right(x-&gt;parent-&gt;parent , root);    <span class="comment">// 第一个参数为右旋点  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>          <span class="comment">// 父节点为祖父节点之右子节点  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left;    <span class="comment">// 令y为伯父节点  </span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 有伯父节点，且为红  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色  </span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色  </span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;          <span class="comment">// 准备继续往上层检查  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)        <span class="comment">// 如果新节点为父节点之左子节点  </span></span><br><span class="line">                &#123;  </span><br><span class="line">                    x = x-&gt;parent;  </span><br><span class="line">                    _rb_tree_rotate_right(x , root);    <span class="comment">// 第一个参数为右旋点  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;  </span><br><span class="line">                _rb_tree_rotate_left(x-&gt;parent-&gt;parent , root);    <span class="comment">// 第一个参数为左旋点  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//while  </span></span><br><span class="line">    root-&gt;color = _rb_tree_black;    <span class="comment">// 根节点永远为黑色  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 左旋函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rotate_left(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// x 为旋转点  </span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;right;          <span class="comment">// 令y为旋转点的右子节点  </span></span><br><span class="line">    x-&gt;right = y-&gt;left;  </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != <span class="number">0</span>)  </span><br><span class="line">        y-&gt;left-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点  </span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）  </span></span><br><span class="line">    <span class="keyword">if</span>(x == root)    <span class="comment">// x为根节点  </span></span><br><span class="line">        root = y;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)         <span class="comment">// x为其父节点的左子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;left = y;  </span><br><span class="line">    <span class="keyword">else</span>                                  <span class="comment">// x为其父节点的右子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;right = y;  </span><br><span class="line">    y-&gt;left = x;  </span><br><span class="line">    x-&gt;parent = y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 右旋函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rotate_right(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// x 为旋转点  </span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;left;          <span class="comment">// 令y为旋转点的左子节点  </span></span><br><span class="line">    x-&gt;left = y-&gt;right;  </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right != <span class="number">0</span>)  </span><br><span class="line">        y-&gt;right-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点  </span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）  </span></span><br><span class="line">    <span class="keyword">if</span>(x == root)  </span><br><span class="line">        root = y;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)         <span class="comment">// x为其父节点的右子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;right = y;  </span><br><span class="line">    <span class="keyword">else</span>                                  <span class="comment">// x为其父节点的左子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;left = y;  </span><br><span class="line">    y-&gt;right = x;  </span><br><span class="line">    x-&gt;parent = y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h1><p>红黑树在删除节点后，需要调整以使得红黑树保持平衡，由于删除后调节平衡实在太复杂，本文就不做分析，只提供其接口函数。</p>
<p>如果对其感兴趣的话，可以参考一下这篇博文：<a href="https://www.cnblogs.com/deliver/p/5392768.html" target="_blank" rel="noopener">(图解）红黑树的插入和删除</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点后调节平衡</span></span><br><span class="line"><span class="keyword">inline</span> __rb_tree_node_base*</span><br><span class="line">__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,</span><br><span class="line">                              __rb_tree_node_base*&amp; root,</span><br><span class="line">                              __rb_tree_node_base*&amp; leftmost,</span><br><span class="line">                              __rb_tree_node_base*&amp; rightmost);</span><br></pre></td></tr></table></figure>

<p>STL为红黑树提供了以下删除操作的节点函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line"><span class="comment">// 删除迭代器区间位置内的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"><span class="comment">// 清除所有的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面来看看它们的源码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:erase(iterator position) &#123;</span><br><span class="line">  <span class="comment">// 删除节点后需要使其重新恢复平衡</span></span><br><span class="line">  link_type y = (link_type) __rb_tree_rebalance_for_erase(position.node,</span><br><span class="line">                                                          header-&gt;parent,</span><br><span class="line">                                                          header-&gt;left,</span><br><span class="line">                                                          header-&gt;right);</span><br><span class="line">  <span class="comment">// 清除掉被删除的节点，释放内存</span></span><br><span class="line">  destroy_node(y);</span><br><span class="line">  --node_count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除掉区间内的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:erase(iterator first, </span><br><span class="line">                                                            iterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == begin() &amp;&amp; last == end())</span><br><span class="line">    clear();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) erase(first++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除所有的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里不需要调用上面的__rb_tree_rebalance_for_erase</span></span><br><span class="line">    <span class="comment">// 而是直接调用不需要调节平衡的删除节点函数，见下面</span></span><br><span class="line">    __erase(root()); </span><br><span class="line">    leftmost() = header;</span><br><span class="line">    root() = <span class="number">0</span>;</span><br><span class="line">    rightmost() = header;</span><br><span class="line">    node_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 删除红黑树的节点，删除过程中不需要调节平衡</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:__erase(link_type x) &#123;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    __erase(right(x));</span><br><span class="line">    link_type y = left(x);</span><br><span class="line">    destroy_node(x);</span><br><span class="line">    x = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的元素搜寻"><a href="#红黑树的元素搜寻" class="headerlink" title="红黑树的元素搜寻"></a>红黑树的元素搜寻</h1><p>find函数用于查找是否存在键值为k的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找RBTree中是否存在键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::find(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header;        <span class="comment">// Last node which is not less than k. </span></span><br><span class="line">  link_type x = root();        <span class="comment">// Current node. </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// key_compare是节点键值大小比较函数</span></span><br><span class="line">    <span class="keyword">if</span> (!key_compare(key(x), k)) </span><br><span class="line">      <span class="comment">// 如果节点x的键值大于k，则继续往左子树查找</span></span><br><span class="line">      y = x, x = left(x);    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果节点x的键值小于k，则继续往右子树查找</span></span><br><span class="line">      x = right(x);</span><br><span class="line">  iterator j = iterator(y); </span><br><span class="line">  <span class="comment">// y的键值不小于k，返回的时候需要判断与k是相等还是小于  </span></span><br><span class="line">  <span class="keyword">return</span> (j == end() || key_compare(k, key(j.node))) ? end() : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，STL的红黑树还针对multiset和multimap提供了几个搜寻函数，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算键值为x的节点的个数</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 提供了查询与某个键值相等的节点迭代器范围</span></span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x);</span><br><span class="line"><span class="comment">//返回不小于k的第一个节点迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line"><span class="comment">//返回大于k的第一个节点迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其实现函数也一并贴出来，让大家好理解一下吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算RBTree的节点值为k的节点个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:size_type </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::count(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  pair&lt;const_iterator, const_iterator&gt; p = equal_range(k);</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  distance(p.first, p.second, n);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询与键值k相等的节点迭代器范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;typename rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator,</span></span><br><span class="line"><span class="class">            typename rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:equal_range(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, iterator&gt;(lower_bound(k), upper_bound(k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回不小于k的第一个节点迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::lower_bound(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is not less than k. */</span></span><br><span class="line">  link_type x = root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!key_compare(key(x), k))</span><br><span class="line">      y = x, x = left(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      x = right(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterator(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回大于k的第一个节点迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::upper_bound(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is greater than k. */</span></span><br><span class="line">  link_type x = root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">     <span class="keyword">if</span> (key_compare(k, key(x)))</span><br><span class="line">       y = x, x = left(x);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       x = right(x);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> iterator(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Stcak和Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Stcak和Queue/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:09:07+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇博客，<a href="https://zcheng.ren/2016/08/26/STLDeque/" target="_blank" rel="noopener">带你深入理解STL之Deque容器</a>中详细介绍了deque容器的源码实现方式。结合前面介绍的两个容器vector和list，在使用的过程中，我们确实要知道在什么情况下需要选择恰当的容器来满足需求和提升效率。一般选择的准则有如下几条：</p>
<ul>
<li>如果需要随机访问一个容器，vector比list要好</li>
<li>如果需要经常插入和删除操作的话，list比vector要好</li>
<li>如果既要随机存取，又要关心两端数据的插入和删除，则选择deque</li>
</ul>
<p>好了，复习完前面的知识后，开始介绍今天的两个容器stack和queue。由于stack和queue都是基于deque来实现的，所以相应的代码会比较简单，也是比较轻松易实现的，下面一起去看看吧。</p>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>如果把deque比作一个管道，两头都可进可出的话，stack就是一个桶！只能一头进一头出，而且，压在下面的东西你看不到，你要是想看，只能把上面的东西拿出来再去看。</p>
<p>stack是一种先进后出的数据结构，允许新增元素、移除元素和取得最顶端的元素，除了最顶端，没有任何其他方法可以存取stack中的元素，也就是说stack没有遍历行为，因此，stack是没有迭代器的！！！！！</p>
<p>以deque为底层容器来实现stack这种数据结构，简直不能再简单，基本的操作函数都已经定义好了，deque可以为它完成所有工作。与其说stack是一种容器，倒不如说它是一种配接器，一种容器适配器。</p>
<p>下面我们就来看看stack的源码，真的没骗你，超级简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt;  // 以<span class="title">deque</span>作为缺省底层容器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// #define __STL_NULL_TMPL_ARGS &lt;&gt;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">// 底层容器，stack全靠它来实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 以下函数直接调用底层容器的接口即可实现</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断stack是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;	</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack中元素个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶元素, 注意这里返回的是引用!!!</span></span><br><span class="line">  <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈顶追加新元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈顶元素, 注意不返回元素的引用,</span></span><br><span class="line">  <span class="comment">// 很多初学者随机用此容器时经常误认为pop()操作同时会返回栈顶元素的引用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个stack是否相等, 就要测试其内部维护容器是否相等</span></span><br><span class="line"><span class="comment">// x.c == y.c会调用容器重载的operator ==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个迭代器的大小，即比较底层容器的大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>你没有看错，stack的源码就只有上面几句话，全是调用底层容器的接口。下面再来看看它的同胞queue，同样很简单。</p>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>queue是一种先进先出的数据结构，上面说道，dequeu是个双向可进可出的管道，stack是一个桶，queue就是一个单向的水管，只能一端进，一端出。</p>
<p>queue允许新增元素、移除元素、从最底端插入元素，从最顶端取得元素，但是，从了最底端插入，最顶端取出之外，没有任何其他方法可以存取queue里面的元素，queue和stack一样，不允许有遍历行为，因此，queue也没有迭代器！！！！</p>
<p>queue和stack一样，也是一种容器适配器，只需要调用底层容器的接口就能实现。下面来看看它的源码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">queue</span>&amp; x, <span class="keyword">const</span> <span class="built_in">queue</span>&amp; y);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">queue</span>&amp; x, <span class="keyword">const</span> <span class="built_in">queue</span>&amp; y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 由于queue仅支持对队头和队尾的操作, 所以不定义STL要求的</span></span><br><span class="line">  <span class="comment">// pointer, iterator, difference_type</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">// 底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 以下操作和stack一样</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_front(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载==操作符，比较底层容器即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博客的两个”容器“比较容易理解，因为底层都已经学过了，只需要调用接口即可。最后再啰嗦两句，stack是一个先进后出的容器，queue是一个先进先出的容器，在使用过程中，需要根据你的需求来选择。我在刷leetcode的时候，碰到遍历二叉树的问题，基本上前、中后序遍历的非递归实现中，都会用到stack，而树的层序遍历中，会采用queue，具体的做法可以参考我的这片博文，<a href="https://zcheng.ren/2016/08/01/【数据结构和算法】全面剖析树的各类遍历方法/" target="_blank" rel="noopener">全面剖析树的各类遍历方法</a>,相信看完你会对stack和queue的使用有进一步的理解！</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Deque/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:08:22+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。</p>
<p>而list是以节点形式来存放数据，使用的是非连续的内存空间来存放数据，因此，在其内部插入和删除元素的时间复杂度都是O(1),但是其不支持随机访问和存取，不支持下标，而且比vector占用的内存要多。</p>
<p>综合上述的优缺点，我们貌似需要一个支持随机访问和存取，支持下标访问，而且插入和删除的效率高的容器。于是，STL的deque诞生了，下面就跟着我一起去看看deque的设计和源码实现吧！</p>
<h1 id="Deque概述"><a href="#Deque概述" class="headerlink" title="Deque概述"></a>Deque概述</h1><p>vector是一个单向开口的容器，deque则是一个双向开口的容器，所谓双向开口就是再头尾两端均可以做元素的插入和删除操作。deque容器给我们的直观感觉大概是下面这样的(配图来自STL源码剖析)：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfqlslx9j30jk064jrp.jpg" alt="Deque"></p>
<p>deque相比于vector最大的差异就在于支持常熟时间内对首尾两端进行插入和删除操作，而且deque没有容量的概念，其内部采用分段连续内存空间来存储元素，在插入元素的时候随时都可以重新增加一段新的空间并链接起来。</p>
<p>deque提供了Ramdon Access Iterator，同时也支持随机访问和存取，但是它也为此付出了昂贵的代价，其复杂度不能跟vector的原生指针迭代器相提并论。在下面的讲解中会一一为大家介绍STL是怎样”辛苦地”维持一个随机访问迭代器的。</p>
<h1 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h1><p>deque为了维持整体连续的假象，设计一个中控器，其用来记录deque内部每一段连续空间的地址。大体上可以理解为deque中的每一段连续空间分布在内存的不连续空间上，然后用一个所谓的map作为主控，记录每一段内存空间的入口，从而做到整体连续的假象。其布局大概如下(配图来自STL源码剖析)</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfql0k0oj30ig0fdq4a.jpg" alt="STLDequeMap"></p>
<p>看完图解，再来看看源码会很好理解的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向map, map是一个连续的空间, 其每个元素都是一个指向缓冲区的指针</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛弃型别定义，我们可以看到map实际上就是一个指向指针的指针(T**)，map所指向的是一个指针，该指针指向型别为T的一块内存空间。理解到这里，大概就清楚了deque的实现原理，不过，这些都不是重点！重点是deque的各种运算符的实现。做好心理准备，咱们继续往下看！！！</p>
<h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>deque提供的是一个随机访问迭代器，由于是分段连续空间，其必须记录当前元素所在段的信息，从而在该段连续空间的边缘进行前进或者后退的时候能知道跳跃到的上一个或下一个缓冲区。deque必须完完全全地掌握和控制这些信息，以达到正确地跳跃！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意deque的迭代器没有重载STL的Iterator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下为支持Iterator_traits而定义的一些类型</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;      </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                      </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;                                       </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                     </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;                        </span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存容器中的结点</span></span><br><span class="line">  T* cur;       <span class="comment">// 指向当前缓冲区中的元素</span></span><br><span class="line">  T* first;     <span class="comment">// 当前缓冲区的起点</span></span><br><span class="line">  T* last;      <span class="comment">// 当前缓冲区的终点</span></span><br><span class="line"></span><br><span class="line">  map_pointer node;   <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">random_access_iterator_tag</span></span></span><br><span class="line"><span class="class"><span class="title">iterator_category</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> random_access_iterator_tag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">value_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ptrdiff_t</span>* <span class="title">distance_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，deque的迭代器中有cur,first,last和node四个指针，前三个记录了迭代器与缓冲区的联系，最后一个记录了迭代器于中控器的关系。从下面这张图可以很好的看出其关系：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfqm9euaj30mh0cft9h.jpg" alt="STLDequeIterator"></p>
<p>仅仅定义了迭代器结构还只是开始，迭代器是一个随机访问迭代器，所以其必须提供++，–，下标操作符等运算符。下面就来一一剖析吧！</p>
<h2 id="buffer-size函数"><a href="#buffer-size函数" class="headerlink" title="buffer_size函数"></a>buffer_size函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回deque的buffer_size大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果n不为0，传回n，表示buffer size由用户自己定义</span></span><br><span class="line"><span class="comment"> * 如果n为0，表示buffer_size采用默认值，</span></span><br><span class="line"><span class="comment"> * 				  那么如果sz(元素大小)小于512，传回512/sz</span></span><br><span class="line"><span class="comment"> * 					如果sz不小于512，传回1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-node函数"><a href="#set-node函数" class="headerlink" title="set_node函数"></a>set_node函数</h2><p>当迭代器处在当前缓冲区的边缘时，一旦前进或者后退，就要考虑超过当前缓冲区的情况，此时需要跳转到下一个缓冲区，这时候set_node就派上用场了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node = new_node;		<span class="comment">// 跳转到相应缓冲区</span></span><br><span class="line">  first = *new_node;	<span class="comment">// 更新跳转后缓冲区first信息</span></span><br><span class="line">  last = first + difference_type(buffer_size());  <span class="comment">// 更新跳转后缓冲区last的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各种运算子"><a href="#各种运算子" class="headerlink" title="各种运算子"></a>各种运算子</h2><p>以下源码都是deque迭代器重载的运算子，以满足随机访问迭代器的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个迭代器之间的距离，重载了‘-’运算子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">    (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前缀自增，注意前缀自增返回自身引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  ++cur;	<span class="comment">// 先自增当前元素的指针</span></span><br><span class="line">  <span class="keyword">if</span> (cur == last) &#123;	<span class="comment">// 判断是否为当前缓冲区最后一个</span></span><br><span class="line">    set_node(node + <span class="number">1</span>);	<span class="comment">// 如果为当前缓冲区最后一个，则跳转到下一个缓冲区</span></span><br><span class="line">    cur = first;	<span class="comment">// 更新为下一缓冲区的起始点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	后缀自增</span></span><br><span class="line"><span class="comment"> *	返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	前缀自减, 处理方式类似于前缀自增</span></span><br><span class="line"><span class="comment"> *	如果当前迭代器指向元素是当前缓冲区的第一个元素</span></span><br><span class="line"><span class="comment"> *	则将迭代器状态调整为前一个缓冲区的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">    set_node(node - <span class="number">1</span>);</span><br><span class="line">    cur = last;</span><br><span class="line">  &#125;</span><br><span class="line">  --cur;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理方法同后缀自增</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  --*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现p+=n的功能</span></span><br><span class="line"><span class="comment"> *	迭代器向前移动n个元素，其中n可能为负。实现步骤如下：</span></span><br><span class="line"><span class="comment"> *	1、计算相对于该缓冲区起始位置的偏移量offset</span></span><br><span class="line"><span class="comment"> *	2、如果offset没有超出缓冲区，则直接cur+=n</span></span><br><span class="line"><span class="comment"> *	3、如果offset超过了缓冲区空间</span></span><br><span class="line"><span class="comment"> *			-- 如果offset大于0，计算向前移动多少个缓冲区，offset / difference_type(buffer_size())</span></span><br><span class="line"><span class="comment"> *			-- 如果offset小于0，计算向后移动多少个缓冲区,-difference_type((-offset - 1) / buffer_size()) - 1;</span></span><br><span class="line"><span class="comment"> *	4、调整到移动后的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type offset = n + (cur - first);</span><br><span class="line">  <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))</span><br><span class="line">    cur += n;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type node_offset =</span><br><span class="line">      offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())</span><br><span class="line">                 : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;</span><br><span class="line">    set_node(node + node_offset);</span><br><span class="line">    cur = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现诸如p+n的功能</span></span><br><span class="line"><span class="comment"> * 此函数中直接调用operator +=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里调用了operator +=()可以自动调整指针状态</span></span><br><span class="line">  <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-=n的功能</span></span><br><span class="line"><span class="comment"> * 此处直接利用operator += ，改变一下n的正负即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-n的功能</span></span><br><span class="line"><span class="comment"> * 直接调用operator -=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下标运算子，支持随机存取的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下述都是一些判断运算的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h1><p>先前在deque的中控器中讲到，deque维护着一个map，用来记录每个缓冲区的位置。除了map外，deque的数据结构中还维护着start和finish两个迭代器，分别指向deque的首尾。此外，它还必须知道map的大小，一旦map所提供的节点不足，就需要配置一块更大的map。</p>
<p>接下来，我们来看看deque的数据结构源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="comment">// 这里省略一堆支持iterator_traits型别定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;  iterator;	<span class="comment">// deque的迭代器</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  iterator start;               <span class="comment">// 表中第一个节点</span></span><br><span class="line">  iterator finish;              <span class="comment">// 表中最后一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是前面讲到map指针，用来记录每一个缓冲区的地址</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个元素大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个指针大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存, 不进行构造</span></span><br><span class="line">	<span class="function">pointer <span class="title">allocate_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_allocator::allocate(buffer_size()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放内存, 不进行析构</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate_node</span><span class="params">(pointer n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		data_allocator::deallocate(n, buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述结构体下，可以很轻松地实现“连续”容器的各种机能函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// 返回第一个节点的迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// 返回最后一个节点的迭代器</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// const版本</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// const版本</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *	提供随机访问的下标运算子</span></span><br><span class="line"><span class="comment">   *	这里计算实际地址的时候是经过一系列的计算得到的，效率上有缺失</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> start[difference_type(n)]; &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> start[difference_type(n)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 以下函数分别返回首尾元素的引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    const_iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	返回deque的大小，这里直接调用迭代器重载的‘-’运算符 </span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125;</span><br><span class="line">  <span class="comment">//	返回deque最大容量</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deque为空的时, 只有一个缓冲区</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的构造函数"><a href="#deque的构造函数" class="headerlink" title="deque的构造函数"></a>deque的构造函数</h1><p>deque和vector、list一样，提供了多种构造函数。我们先来看看默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>() : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(<span class="number">0</span>);	<span class="comment">// 直接调用create_map_and_nodes函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map最少为8个</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建内部使用的map，并配置每一个缓冲区</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:create_map_and_nodes(size_type num_elements)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 需要的结点数, 元素个数 / 每个缓冲区能容纳的元素数 + 1</span></span><br><span class="line">  <span class="comment">// 这里如果能整除，会多分配一个</span></span><br><span class="line">  size_type num_nodes = num_elements / buffer_size() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map要维护的结点, 这里最小的值为8，最多为所需节点数+1，前后各留一个以便扩充</span></span><br><span class="line">  map_size = max(initial_map_size(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 调用deque专属空间配置器，配置map空间</span></span><br><span class="line">  <span class="built_in">map</span> = map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将[nstart, nfinish)区间设置在map的中间,</span></span><br><span class="line">  <span class="comment">// 这样就能保证前后增长而尽可能减少map的重新分配次数</span></span><br><span class="line">  map_pointer nstart = <span class="built_in">map</span> + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配结点空间</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">    	<span class="comment">// 为每一个map指针指向的缓冲区的每一个元素分配内存空间 </span></span><br><span class="line">      *cur = allocate_node();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护指针状态，为deque的两个迭代器start和finish赋初值</span></span><br><span class="line">  start.set_node(nstart);</span><br><span class="line">  finish.set_node(nfinish);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">  finish.cur = finish.first + num_elements % buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了默认构造函数，deque还提供了一系列的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span>&amp; x)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配置map和元素</span></span><br><span class="line">  create_map_and_nodes(x.size());</span><br><span class="line">  <span class="comment">// 将x的元素拷贝到本deque内</span></span><br><span class="line">  uninitialized_copy(x.begin(), x.end(), start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个deque，含有n个值为value的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  fill_initialize(n, value);	<span class="comment">// 调用fill_initialize函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配n个结点, 并以value为元素值初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:fill_initialize(size_type n,</span><br><span class="line">    <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">  	<span class="comment">// 为每一个缓冲区设定初值</span></span><br><span class="line">    <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">      uninitialized_fill(*cur, *cur + buffer_size(), value);</span><br><span class="line">    <span class="comment">// 尾端可能留有备用空间，不必设初值</span></span><br><span class="line">    uninitialized_fill(finish.first, finish.cur, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer n = start.node; n &lt; cur; ++n)</span><br><span class="line">      destroy(*n, *n + buffer_size());</span><br><span class="line">    destroy_map_and_nodes();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以区间值来构造deque</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  range_initialize(first, last, iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:range_initialize(ForwardIterator first,</span><br><span class="line">    ForwardIterator last,</span><br><span class="line">    forward_iterator_tag) &#123;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, n);	<span class="comment">// 计算有多少个元素</span></span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  uninitialized_copy(first, last, start);	<span class="comment">// 调用全局函数，将[first,last)拷贝到新配置的空间上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，deque还提供了很多种构造函数，基本上都调用上述函数来构造map和缓冲区，这里就不在赘述！</p>
<h1 id="deque的析构函数"><a href="#deque的析构函数" class="headerlink" title="deque的析构函数"></a>deque的析构函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">deque</span>()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start, finish);     <span class="comment">// 调用全局函数</span></span><br><span class="line">  destroy_map_and_nodes();		<span class="comment">// 释放map和缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:destroy_map_and_nodes()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt;= finish.node; ++cur)</span><br><span class="line">    deallocate_node(*cur);	<span class="comment">// 释放每一个节点</span></span><br><span class="line">  map_allocator::deallocate(<span class="built_in">map</span>, map_size);	<span class="comment">// 释放map空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque支持的操作函数"><a href="#deque支持的操作函数" class="headerlink" title="deque支持的操作函数"></a>deque支持的操作函数</h1><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>push_back完成在尾部插入一个元素，根绝上述的deque的结构特点，里面有很多情况需要考虑。</p>
<ul>
<li>如果备用空间足够，就直接push进去</li>
<li>如果备用空间不足，就要考虑配置一个新的缓冲区</li>
</ul>
<p>配置新缓冲区的时候，还需要考虑map空间是否足够</p>
<ul>
<li>如果map空间足够，就直接配置一块新的缓冲区，链接到map中</li>
<li>如果map空间不足，就需要考虑重新配置一块map</li>
</ul>
<p>可见，为了维持整体连续的假象，确确实实，deque的操作函数需要考虑各个方面。下面来看看源代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在deque的尾部压入一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里采用STL的前闭后开原则</span></span><br><span class="line">  <span class="comment">// 所以last要-1</span></span><br><span class="line">  <span class="comment">// 如果deque里面还有备用空间，则直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">    construct(finish.cur, t);</span><br><span class="line">    ++finish.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 容量已满就要新申请内存了</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_back_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅当finish.cur == finish.last - 1才调用</span></span><br><span class="line"><span class="comment"> * 即最后一个缓冲区没有空间才调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_back_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  <span class="comment">// 判断是否需要调整map空间</span></span><br><span class="line">  reserve_map_at_back();</span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    construct(finish.cur, t_copy);	<span class="comment">// 构造新加入的元素</span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);	<span class="comment">// 调整finish</span></span><br><span class="line">    finish.cur = finish.first;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map空间不足，需要调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))</span><br><span class="line">		<span class="comment">// 此时，需要调整map，更换一个更大的map</span></span><br><span class="line">		reallocate_map(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新配置map, 不会对缓冲区进行操作, map维护的是指向缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:reallocate_map(size_type nodes_to_add,</span><br><span class="line">    <span class="keyword">bool</span> add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">  map_pointer new_nstart;</span><br><span class="line">  <span class="comment">// 此处为了防止出现一端已经用完，另一端却还有很多剩余的情况</span></span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">  	<span class="comment">// 调整新的map中的起始点</span></span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果前端剩余很多</span></span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">// 尾端剩余很多</span></span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;	<span class="comment">// map不够用了，就需要配置一块更大的map</span></span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 配置一块大的map</span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);</span><br><span class="line">    <span class="comment">// 始终要使start和finish处在map空间的中间</span></span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 拷贝到新的map空间中去</span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="comment">// 释放旧的空间</span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);</span><br><span class="line">    <span class="comment">// 改变map和size参数</span></span><br><span class="line">    <span class="built_in">map</span> = new_map;</span><br><span class="line">    map_size = new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调整新的start和finish</span></span><br><span class="line">  start.set_node(new_nstart);</span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>pop_back是将deque的尾部元素弹出，即拿掉该元素并释放空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果尾端不是该缓冲区最开始的那个元素</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">    --finish.cur;</span><br><span class="line">    destroy(finish.cur);  <span class="comment">// 直接拿掉并释放空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_back_aux();   <span class="comment">// 需要调整map的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在pop_back中，如果碰到为首元素的情况，调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>: pop_back_aux()</span><br><span class="line">&#123;</span><br><span class="line">  deallocate_node(finish.first);	<span class="comment">// 释放节点</span></span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);	<span class="comment">// 重新设定finish</span></span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">  destroy(finish.cur);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h2><p>此函数用来在deque的头部压入一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 还是一样，不需要调整map的情况，直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">    construct(start.cur - <span class="number">1</span>, t);</span><br><span class="line">    --start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_front_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有再start.cur== start.first的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_front_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  reserve_map_at_front();	<span class="comment">// 同push_back()，检查是否需要调整map</span></span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);	<span class="comment">// 调整start</span></span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">    construct(start.cur, t_copy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    deallocate_node(*(start.node - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h2><p>此函数实现从头部弹出一个元素，同pop_back()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    destroy(start.cur);</span><br><span class="line">    ++start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_front_aux();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在start.cur == start.last - 1的时候调用</span></span><br><span class="line"><span class="comment"> * 此时需要调整map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:pop_front_aux()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start.cur);</span><br><span class="line">  deallocate_node(start.first);</span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>擦除deque中的每一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先析构除起点和终点的所有元素, 并释放相应空间</span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">    destroy(*node, *node + buffer_size());</span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果deque本身不为空, 析构所有对象, 并释放掉结尾的内存</span></span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;</span><br><span class="line">    destroy(start.cur, start.last);  <span class="comment">// 将头缓冲区的元素清除</span></span><br><span class="line">    destroy(finish.first, finish.cur);  <span class="comment">//将尾缓冲区的元素清除</span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size()); <span class="comment">// 头缓冲区保留，释放尾缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构所有元素, 但是不释放空间, 因为deque要满足这个前置条件</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    destroy(start.cur, finish.cur);</span><br><span class="line"></span><br><span class="line">  finish = start; <span class="comment">// 调整finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>erase实现了擦除单个指定元素和擦出区间两个版本，源代码分析如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数实现擦除单个指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iterator next = pos;</span><br><span class="line">  ++next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算待擦除点前的元素个数</span></span><br><span class="line">  difference_type index = pos - start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断待擦除结点前后元素的个数, 哪部分少就移动哪部分</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 前面部分的元素少</span></span><br><span class="line">    copy_backward(start, pos, next);  </span><br><span class="line">    pop_front();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后面部分的元素少</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    copy(next, finish, pos); </span><br><span class="line">    pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除[first,last)区间的元素。此函数按下列步骤来擦除区间。</p>
<ul>
<li>需要擦除整个空间，直接调用clear()</li>
<li>需要擦出中间指定区间</li>
</ul>
<p>擦除中间指定区间，需要考虑一下两种情况</p>
<ul>
<li>区间前面的元素少，就移动前面的元素</li>
<li>区间后面的元素少，就移动后面的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;	<span class="comment">// 需要擦除整个deque</span></span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type n = last - first;	<span class="comment">// 清除区间的长度</span></span><br><span class="line">    difference_type elems_before = first - start;  <span class="comment">// 待清除区间前方的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;	<span class="comment">// 如果前方的元素个数较少</span></span><br><span class="line">      copy_backward(start, first, last);	<span class="comment">// 向后移动前方元素</span></span><br><span class="line">      iterator new_start = start + n;     <span class="comment">// 调整新的起始点</span></span><br><span class="line">      destroy(start, new_start);          <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());   <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 后方元素比较少的情况</span></span><br><span class="line">      copy(last, finish, first);	<span class="comment">// 向前移动后方元素</span></span><br><span class="line">      iterator new_finish = finish - n; <span class="comment">// 调整新的finish迭代器</span></span><br><span class="line">      destroy(new_finish, finish);      <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>在指定位置前插入元素，deque的源码中，为insert提供了多个版本，这里列举插入一个元素和n和元素的版本。</p>
<p>在指定位置插入一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果是在deque的最前端插入, 那么直接push_front()即可</span></span><br><span class="line">  <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">    push_front(x);</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是在deque的末尾插入, 直接调用push_back()</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">    push_back(x);</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> insert_aux(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不在首尾插入元素的时候调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type index = pos - start;  <span class="comment">// 插入元素前面的元素个数</span></span><br><span class="line">  value_type x_copy = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;  <span class="comment">// 如果前端的元素比较少</span></span><br><span class="line">    push_front(front());  <span class="comment">// 在最前面插入一个与第一个元素一样的数</span></span><br><span class="line">    iterator front1 = start;  <span class="comment">// 记录起始点</span></span><br><span class="line">    ++front1;</span><br><span class="line">    iterator front2 = front1; </span><br><span class="line">    ++front2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    iterator pos1 = pos;</span><br><span class="line">    ++pos1;</span><br><span class="line">    copy(front2, pos1, front1); <span class="comment">// 拷贝空间，将[front2,pos1)拷贝到front1以后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 后端的元素比较少，原理用上</span></span><br><span class="line">    push_back(back());</span><br><span class="line">    iterator back1 = finish;</span><br><span class="line">    --back1;</span><br><span class="line">    iterator back2 = back1;</span><br><span class="line">    --back2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    copy_backward(pos, back2, back1);</span><br><span class="line">  &#125;</span><br><span class="line">  *pos = x_copy;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在指定位置插入n个元素的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert(iterator pos,</span><br><span class="line">                                      size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;   <span class="comment">// 如果插入点再最前端</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 调整新的start位置</span></span><br><span class="line">    uninitialized_fill(new_start, start, x);	<span class="comment">//直接在前端构造n个元素</span></span><br><span class="line">    start = new_start;  <span class="comment">// 调整新的start</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">  	<span class="comment">// 与reserve_elements_at_front相同</span></span><br><span class="line">  	<span class="comment">// 考虑篇幅，这里不列出源代码</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n); </span><br><span class="line">    uninitialized_fill(finish, new_finish, x);</span><br><span class="line">    finish = new_finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insert_aux(pos, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入区间前方备用空间能否容纳n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">reserve_elements_at_front</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  size_type vacancies = start.cur - start.first;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; vacancies)   <span class="comment">// 如果容纳不了，就需要重新配置map</span></span><br><span class="line">    new_elements_at_front(n - vacancies);</span><br><span class="line">  <span class="keyword">return</span> start - difference_type(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在前方备用空间容纳不了待插入的n个元素的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:new_elements_at_front(size_type new_elements)</span><br><span class="line">&#123;</span><br><span class="line">  size_type new_nodes = (new_elements + buffer_size() - <span class="number">1</span>) / buffer_size();</span><br><span class="line">  reserve_map_at_front(new_nodes);  <span class="comment">// 调整map</span></span><br><span class="line">  size_type i;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= new_nodes; ++i)</span><br><span class="line">      *(start.node - i) = allocate_node(); <span class="comment">// 为每一个map指针配置空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      deallocate_node(*(start.node - j));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整map的前端，以在前端能连接更多缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)</span><br><span class="line">    reallocate_map(nodes_to_add, <span class="literal">true</span>);  <span class="comment">// 此函数上面有说明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好吧，这里才是最重要的insert_aux函数，实现在中间某个位置插入n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert_aux(iterator pos,</span><br><span class="line">    size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;  <span class="comment">// 计算该位置前面的元素个数</span></span><br><span class="line">  size_type length = size();</span><br><span class="line">  value_type x_copy = x;</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;  <span class="comment">// 如果位置前面的元素比较少</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 同上</span></span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= difference_type(n)) &#123; </span><br><span class="line">        iterator start_n = start + difference_type(n);</span><br><span class="line">        uninitialized_copy(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        copy(start_n, pos, old_start);</span><br><span class="line">        fill(pos - difference_type(n), pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);</span><br><span class="line">        start = new_start;</span><br><span class="line">        fill(old_start, pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_front(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 该位置后面的元素比较少</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = difference_type(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; difference_type(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - difference_type(n);</span><br><span class="line">        uninitialized_copy(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        copy_backward(pos, finish_n, old_finish);</span><br><span class="line">        fill(pos, pos + difference_type(n), x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_fill_copy(finish, pos + difference_type(n),</span><br><span class="line">        x_copy,</span><br><span class="line">        pos, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        fill(pos, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_back(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/bolgzxy.github.io/page/4/">4</a><a class="page-number" href="/bolgzxy.github.io/page/5/">5</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
